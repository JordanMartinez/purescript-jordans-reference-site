<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PureScript: Jordan&#x27;s Reference</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="An in-depth beginner-oriented guide to learning PureScript from Foundations-up.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="License.html">License</a></li><li class="chapter-item expanded affix "><a href="Versioning-Policy.html">Versioning Policy</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> .ci</div></li><li class="chapter-item expanded "><a href="content/01-Getting-Started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/01-Getting-Started/01-Why-Learn-PureScript.html"><strong aria-hidden="true">2.1.</strong> Why Learn PureScript</a></li><li class="chapter-item expanded "><a href="content/01-Getting-Started/02-The-Strengths-of-PureScript.html"><strong aria-hidden="true">2.2.</strong> The Strengths of PureScript</a></li><li class="chapter-item expanded "><a href="content/01-Getting-Started/03-FAQs-on-PureScript.html"><strong aria-hidden="true">2.3.</strong> FAQs on PureScript</a></li><li class="chapter-item expanded "><a href="content/01-Getting-Started/04-Install-Guide.html"><strong aria-hidden="true">2.4.</strong> Install Guide</a></li><li class="chapter-item expanded "><a href="content/01-Getting-Started/05-The-REPL.html"><strong aria-hidden="true">2.5.</strong> The REPL</a></li><li class="chapter-item expanded "><a href="content/01-Getting-Started/06-Other-Important-Info.html"><strong aria-hidden="true">2.6.</strong> Other Important Info</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> FP Philosophical Foundations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/01-Composition-Everywhere.html"><strong aria-hidden="true">3.1.</strong> Composition Everywhere</a></li><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/02-Pure-vs-Impure-Functions.html"><strong aria-hidden="true">3.2.</strong> Pure vs Impure Functions</a></li><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/03-Data-Types.html"><strong aria-hidden="true">3.3.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/04-Lazy-vs-Strict.html"><strong aria-hidden="true">3.4.</strong> Lazy vs Strict</a></li><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/05-Looping-via-Recursion.html"><strong aria-hidden="true">3.5.</strong> Looping via Recursion</a></li><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/06-Type-Classes.html"><strong aria-hidden="true">3.6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/07-Equational-Reasoning.html"><strong aria-hidden="true">3.7.</strong> Equational Reasoning</a></li><li class="chapter-item expanded "><a href="content/02-FP-Philosophical-Foundations/11-FP--The-Big-Picture.html"><strong aria-hidden="true">3.8.</strong> FP: The Big Picture</a></li></ol></li><li class="chapter-item expanded "><a href="content/03-Build-Tools/index.html"><strong aria-hidden="true">4.</strong> Build Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/03-Build-Tools/01-Dependency-Managers/index.html"><strong aria-hidden="true">4.1.</strong> Dependency Managers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/03-Build-Tools/01-Dependency-Managers/01-Bower-Explained.html"><strong aria-hidden="true">4.1.1.</strong> Bower Explained</a></li><li class="chapter-item expanded "><a href="content/03-Build-Tools/01-Dependency-Managers/02-Spago-Explained.html"><strong aria-hidden="true">4.1.2.</strong> Spago Explained</a></li><li class="chapter-item expanded "><a href="content/03-Build-Tools/01-Dependency-Managers/03-Why-We-Need-Both.html"><strong aria-hidden="true">4.1.3.</strong> Why We Need Both</a></li></ol></li><li class="chapter-item expanded "><a href="content/03-Build-Tools/02-Spago--Project-Workflow.html"><strong aria-hidden="true">4.2.</strong> Spago: Project Workflow</a></li><li class="chapter-item expanded "><a href="content/03-Build-Tools/03-Bower--Project-Workflow.html"><strong aria-hidden="true">4.3.</strong> Bower: Project Workflow</a></li><li class="chapter-item expanded "><a href="content/03-Build-Tools/04-Continuous-Integration.html"><strong aria-hidden="true">4.4.</strong> Continuous Integration</a></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/index.html"><strong aria-hidden="true">5.</strong> Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/index.html"><strong aria-hidden="true">5.1.</strong> Basic Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/00-Comments-ps.html"><strong aria-hidden="true">5.1.1.1.</strong> Comments.purs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.2.</strong> Preliminary Concepts</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/01-Preliminary-Concepts/01-Value-Function-Data-Syntax-ps.html"><strong aria-hidden="true">5.1.1.2.1.</strong> Value Function Data Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/01-Preliminary-Concepts/02-Explaining-Kinds.html"><strong aria-hidden="true">5.1.1.2.2.</strong> Explaining Kinds</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/01-Preliminary-Concepts/03-The-Prim-Module-ps.html"><strong aria-hidden="true">5.1.1.2.3.</strong> The Prim Module.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.3.</strong> Data and Functions</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/02-Data-and-Functions/01-Defining-Values-and-Functions-ps.html"><strong aria-hidden="true">5.1.1.3.1.</strong> Defining Values and Functions.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/02-Data-and-Functions/02-Function-Currying-ps.html"><strong aria-hidden="true">5.1.1.3.2.</strong> Function Currying.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/02-Data-and-Functions/03-Abbreviated-Function-Body-ps.html"><strong aria-hidden="true">5.1.1.3.3.</strong> Abbreviated Function Body.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/02-Data-and-Functions/04-Keyword--Data-ps.html"><strong aria-hidden="true">5.1.1.3.4.</strong> Keyword: Data.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/02-Data-and-Functions/05-Pattern-Matching-in-Functions-ps.html"><strong aria-hidden="true">5.1.1.3.5.</strong> Pattern Matching in Functions.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.4.</strong> Special Compiler Features</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/03-Special-Compiler-Features/01-Typed-Holes-ps.html"><strong aria-hidden="true">5.1.1.4.1.</strong> Typed Holes.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/03-Special-Compiler-Features/02-Typed-Wildcards-ps.html"><strong aria-hidden="true">5.1.1.4.2.</strong> Typed Wildcards.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.5.</strong> Various Keywords</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/04-Various-Keywords/01-Keyword--Forall-ps.html"><strong aria-hidden="true">5.1.1.5.1.</strong> Keyword: Forall.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/04-Various-Keywords/02-Keyword--Type-ps.html"><strong aria-hidden="true">5.1.1.5.2.</strong> Keyword: Type.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/04-Various-Keywords/03-Keywords--Case-expression-of-ps.html"><strong aria-hidden="true">5.1.1.5.3.</strong> Keywords: Case expression of.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/04-Various-Keywords/04-Keywords--Where-and-Let-In-ps.html"><strong aria-hidden="true">5.1.1.5.4.</strong> Keywords: Where and Let In.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/04-Various-Keywords/05-Indentation-Rules-ps.html"><strong aria-hidden="true">5.1.1.5.5.</strong> Indentation Rules.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/04-Various-Keywords/06-Let-Lacks-Generalization-ps.html"><strong aria-hidden="true">5.1.1.5.6.</strong> Let Lacks Generalization.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/04-Various-Keywords/07-Keywords--If-Then-Else-ps.html"><strong aria-hidden="true">5.1.1.5.7.</strong> Keywords: If Then Else.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.6.</strong> Records</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/05-Records/01-Basic-Syntax-ps.html"><strong aria-hidden="true">5.1.1.6.1.</strong> Basic Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/05-Records/02-Quoted-Key-Syntax-ps.html"><strong aria-hidden="true">5.1.1.6.2.</strong> Quoted Key Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/05-Records/03-Row-Polymorphism-ps.html"><strong aria-hidden="true">5.1.1.6.3.</strong> Row Polymorphism.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.7.</strong> Infix Notation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/06-Infix-Notation/01-Regular-ps.html"><strong aria-hidden="true">5.1.1.7.1.</strong> Regular.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/06-Infix-Notation/02-Extended-ps.html"><strong aria-hidden="true">5.1.1.7.2.</strong> Extended.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/07-Functions-and-Data-with-Higher-Kinded-Types-ps.html"><strong aria-hidden="true">5.1.1.8.</strong> Functions and Data with Higher Kinded Types.purs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.9.</strong> TypeClasses</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/01-Single-Paramter-ps.html"><strong aria-hidden="true">5.1.1.9.1.</strong> Single Paramter.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/02-Constraining-Types-Using-Typeclasses-ps.html"><strong aria-hidden="true">5.1.1.9.2.</strong> Constraining Types Using Typeclasses.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/03-Dictionaries--How-Type-Classes-Work-ps.html"><strong aria-hidden="true">5.1.1.9.3.</strong> Dictionaries: How Type Classes Work.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/04-Deriving-Common-Typeclass-Instances-for-Custom-Types-ps.html"><strong aria-hidden="true">5.1.1.9.4.</strong> Deriving Common Typeclass Instances for Custom Types.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/05-Typeclass-Relationships-ps.html"><strong aria-hidden="true">5.1.1.9.5.</strong> Typeclass Relationships.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/06-Typeclasses-with-No-Definitions-ps.html"><strong aria-hidden="true">5.1.1.9.6.</strong> Typeclasses with No Definitions.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/07-Multi-Paramter-ps.html"><strong aria-hidden="true">5.1.1.9.7.</strong> Multi Paramter.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/08-Functional-Dependencies-ps.html"><strong aria-hidden="true">5.1.1.9.8.</strong> Functional Dependencies.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/09-Instance-Chains-ps.html"><strong aria-hidden="true">5.1.1.9.9.</strong> Instance Chains.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/11-Type-Equality-Not-Propagate-ps.html"><strong aria-hidden="true">5.1.1.9.10.</strong> Type Equality Not Propagate.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/11-TypeClasses/91-Designing-Typeclasses.html"><strong aria-hidden="true">5.1.1.9.11.</strong> Designing Typeclasses</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.10.</strong> Newtypes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/12-Newtypes/10-Keyword--Newtype-ps.html"><strong aria-hidden="true">5.1.1.10.1.</strong> Keyword: Newtype.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/12-Newtypes/22-Deriving-Typeclass-Instances-for-Newtyped-Types-ps.html"><strong aria-hidden="true">5.1.1.10.2.</strong> Deriving Typeclass Instances for Newtyped Types.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/13-Global-Instances.html"><strong aria-hidden="true">5.1.1.11.</strong> Global Instances</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/21-Documentation-ps.html"><strong aria-hidden="true">5.1.1.12.</strong> Documentation.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/22-Unicode-Syntax-Support-ps.html"><strong aria-hidden="true">5.1.1.13.</strong> Unicode Syntax Support.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/01-Basic-Syntax/src/31-Understanding-Type-Inference.html"><strong aria-hidden="true">5.1.1.14.</strong> Understanding Type Inference</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/02-Foreign-Function-Interface/index.html"><strong aria-hidden="true">5.2.</strong> Foreign Function Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/02-Foreign-Function-Interface/src/Same-File-Name-js.html"><strong aria-hidden="true">5.2.1.1.</strong> Same File Name.js</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/02-Foreign-Function-Interface/src/Same-File-Name-ps.html"><strong aria-hidden="true">5.2.1.2.</strong> Same File Name.purs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/index.html"><strong aria-hidden="true">5.3.</strong> Type Level Programming Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/01-An-Overview-of-Terms-and-Concepts.html"><strong aria-hidden="true">5.3.1.1.</strong> An Overview of Terms and Concepts</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.1.2.</strong> Basic Syntax</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/02-Basic-Syntax/01-Defining-Custom-Kinds-ps.html"><strong aria-hidden="true">5.3.1.2.1.</strong> Defining Custom Kinds.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/02-Basic-Syntax/02-Kind-Signatures-ps.html"><strong aria-hidden="true">5.3.1.2.2.</strong> Kind Signatures.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/02-Basic-Syntax/03-Polymorphic-Kinds-ps.html"><strong aria-hidden="true">5.3.1.2.3.</strong> Polymorphic Kinds.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/02-Basic-Syntax/04-Proxy-ps.html"><strong aria-hidden="true">5.3.1.2.4.</strong> Proxy.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/03-Defining-Functions/index.html"><strong aria-hidden="true">5.3.1.3.</strong> Defining Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/03-Defining-Functions/01-Single-Arg-Syntax-ps.html"><strong aria-hidden="true">5.3.1.3.1.</strong> Single Arg Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/03-Defining-Functions/02-Multi-Arg-Syntax-ps.html"><strong aria-hidden="true">5.3.1.3.2.</strong> Multi Arg Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/03-Defining-Functions/03-Pattern-Matching-Using-Instances-ps.html"><strong aria-hidden="true">5.3.1.3.3.</strong> Pattern Matching Using Instances.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/03-Defining-Functions/04-Pattern-Matching-Using-Instance-Chains-ps.html"><strong aria-hidden="true">5.3.1.3.4.</strong> Pattern Matching Using Instance Chains.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.1.4.</strong> Using Type Level Values</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/04-Using-Type-Level-Values/01-Reflection-ps.html"><strong aria-hidden="true">5.3.1.4.1.</strong> Reflection.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/04-Using-Type-Level-Values/02-Reification-ps.html"><strong aria-hidden="true">5.3.1.4.2.</strong> Reification.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/04-Using-Type-Level-Values/10-Conventions-ps.html"><strong aria-hidden="true">5.3.1.4.3.</strong> Conventions.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/05-Symbol-Syntax-ps.html"><strong aria-hidden="true">5.3.1.5.</strong> Symbol Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/06-Row-Syntax-ps.html"><strong aria-hidden="true">5.3.1.6.</strong> Row Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/03-Type-Level-Programming-Syntax/src/07-RowList.html"><strong aria-hidden="true">5.3.1.7.</strong> RowList</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/index.html"><strong aria-hidden="true">5.4.</strong> Module Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/01-Basic-Syntax-ps.html"><strong aria-hidden="true">5.4.1.1.</strong> Basic Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/02-Basic-Exporting-ps.html"><strong aria-hidden="true">5.4.1.2.</strong> Basic Exporting.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/03-Basic-Importing-ps.html"><strong aria-hidden="true">5.4.1.3.</strong> Basic Importing.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/04-Resolving-Naming-Conflicts-Using-Keyword--Hiding-ps.html"><strong aria-hidden="true">5.4.1.4.</strong> Resolving Naming Conflicts Using Keyword: Hiding.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/04-Resolving-Naming-Conflicts-Using-Module-Aliases-ps.html"><strong aria-hidden="true">5.4.1.5.</strong> Resolving Naming Conflicts Using Module Aliases.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/05-Re-exporting-Modules-or-Submodules-ps.html"><strong aria-hidden="true">5.4.1.6.</strong> Re exporting Modules or Submodules.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/06-Exporting-Entire-Current-Module-ps.html"><strong aria-hidden="true">5.4.1.7.</strong> Exporting Entire Current Module.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/04-Module-Syntax/src/11-Full-Module-Syntax-ps.html"><strong aria-hidden="true">5.4.1.8.</strong> Full Module Syntax.purs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/05-Prelude-Syntax/index.html"><strong aria-hidden="true">5.5.</strong> Prelude Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/05-Prelude-Syntax/src/01-Discard.html"><strong aria-hidden="true">5.5.1.1.</strong> Discard</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/05-Prelude-Syntax/src/02-Do-Notation-ps.html"><strong aria-hidden="true">5.5.1.2.</strong> Do Notation.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/05-Prelude-Syntax/src/03-Reading-Do-As-Nested-Binds.html"><strong aria-hidden="true">5.5.1.3.</strong> Reading Do As Nested Binds</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/05-Prelude-Syntax/src/04-Ado-Notation-ps.html"><strong aria-hidden="true">5.5.1.4.</strong> Ado Notation.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/05-Prelude-Syntax/src/05-Natural-Transformation-ps.html"><strong aria-hidden="true">5.5.1.5.</strong> Natural Transformation.purs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/11-Syntax/06-Modifying-Do-Ado-Syntax-Sugar/index.html"><strong aria-hidden="true">5.6.</strong> Modifying Do Ado Syntax Sugar</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/11-Syntax/06-Modifying-Do-Ado-Syntax-Sugar/src/01-Rebindable-Ado-ps.html"><strong aria-hidden="true">5.6.1.1.</strong> Rebindable Ado.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/06-Modifying-Do-Ado-Syntax-Sugar/src/01-Rebindable-Do-ps.html"><strong aria-hidden="true">5.6.1.2.</strong> Rebindable Do.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/06-Modifying-Do-Ado-Syntax-Sugar/src/11-Introducing-Qualified-Do-Ado.html"><strong aria-hidden="true">5.6.1.3.</strong> Introducing Qualified Do Ado</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/06-Modifying-Do-Ado-Syntax-Sugar/src/12-MonadLikeTypeClasses-ps.html"><strong aria-hidden="true">5.6.1.4.</strong> MonadLikeTypeClasses.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/06-Modifying-Do-Ado-Syntax-Sugar/src/13-Qualified-Do-ps.html"><strong aria-hidden="true">5.6.1.5.</strong> Qualified Do.purs</a></li><li class="chapter-item expanded "><a href="content/11-Syntax/06-Modifying-Do-Ado-Syntax-Sugar/src/14-Qualified-Ado-ps.html"><strong aria-hidden="true">5.6.1.6.</strong> Qualified Ado.purs</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/index.html"><strong aria-hidden="true">6.</strong> Hello World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/index.html"><strong aria-hidden="true">6.1.</strong> Prelude ish</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.1.</strong> Basic FP Data Types</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/01-Basic-FP-Data-Types/01-Sum-and-Product-Types.html"><strong aria-hidden="true">6.1.1.1.</strong> Sum and Product Types</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/01-Basic-FP-Data-Types/02-List.html"><strong aria-hidden="true">6.1.1.2.</strong> List</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.2.</strong> Common Types and Functions</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/02-Common-Types-and-Functions/01-Useful-Types.html"><strong aria-hidden="true">6.1.2.1.</strong> Useful Types</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/02-Common-Types-and-Functions/02-Useful-Functions.html"><strong aria-hidden="true">6.1.2.2.</strong> Useful Functions</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/03-Preludes-Type-Classes.html"><strong aria-hidden="true">6.1.3.</strong> Preludes Type Classes</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/04-Laws.html"><strong aria-hidden="true">6.1.4.</strong> Laws</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.5.</strong> Composition Typeclasses</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/05-Composition-Typeclasses/05-Objecty--Show-and-Equal-to-Bounded.html"><strong aria-hidden="true">6.1.5.1.</strong> Objecty: Show and Equal to Bounded</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/05-Composition-Typeclasses/06-Arrows--Semigroupoid-and-Category.html"><strong aria-hidden="true">6.1.5.2.</strong> Arrows: Semigroupoid and Category</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/07-Appendable-Typeclasses.html"><strong aria-hidden="true">6.1.6.</strong> Appendable Typeclasses</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/index.html"><strong aria-hidden="true">6.1.7.</strong> Control Flow Typeclasses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/01-Functor.html"><strong aria-hidden="true">6.1.7.1.</strong> Functor</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/02-Apply.html"><strong aria-hidden="true">6.1.7.2.</strong> Apply</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/03-Applicative.html"><strong aria-hidden="true">6.1.7.3.</strong> Applicative</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/04-Bind.html"><strong aria-hidden="true">6.1.7.4.</strong> Bind</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/05-Monad.html"><strong aria-hidden="true">6.1.7.5.</strong> Monad</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/11-How-the-Computer-Executes-FP-Programs.html"><strong aria-hidden="true">6.1.7.6.</strong> How the Computer Executes FP Programs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/12-Useful-Monads.html"><strong aria-hidden="true">6.1.7.7.</strong> Useful Monads</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/13-Monoids-Reconsidered.html"><strong aria-hidden="true">6.1.7.8.</strong> Monoids Reconsidered</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/14-One-Monadic-Type-Per-Monadic-Context.html"><strong aria-hidden="true">6.1.7.9.</strong> One Monadic Type Per Monadic Context</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/01-Prelude-ish/09-Numeric-Hierarchy.html"><strong aria-hidden="true">6.1.8.</strong> Numeric Hierarchy</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/index.html"><strong aria-hidden="true">6.2.</strong> Effect and Aff</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.1.1.</strong> Effect</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/01-Native-Side-Effects-via-Effect.html"><strong aria-hidden="true">6.2.1.1.1.</strong> Native Side Effects via Effect</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/02-Hello-World-ps.html"><strong aria-hidden="true">6.2.1.1.2.</strong> Hello World.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/03-Hello-Number-ps.html"><strong aria-hidden="true">6.2.1.1.3.</strong> Hello Number.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/04-Hello-Do-Notation-ps.html"><strong aria-hidden="true">6.2.1.1.4.</strong> Hello Do Notation.purs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.1.1.5.</strong> Other Effects</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/05-Other-Effects/01-Random-Number-ps.html"><strong aria-hidden="true">6.2.1.1.5.1.</strong> Random Number.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/05-Other-Effects/02-Current-Date-and-Time-ps.html"><strong aria-hidden="true">6.2.1.1.5.2.</strong> Current Date and Time.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/05-Other-Effects/03-Timeout-and-Interval-ps.html"><strong aria-hidden="true">6.2.1.1.5.3.</strong> Timeout and Interval.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/06-Mutable-State/index.html"><strong aria-hidden="true">6.2.1.1.6.</strong> Mutable State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/06-Mutable-State/01-Global-ps.html"><strong aria-hidden="true">6.2.1.1.6.1.</strong> Global.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/06-Mutable-State/02-Local-ps.html"><strong aria-hidden="true">6.2.1.1.6.2.</strong> Local.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/01-Effect/10-Summary-of-Effect-Libraries.html"><strong aria-hidden="true">6.2.1.1.7.</strong> Summary of Effect Libraries</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/02-Effect-Eff-and-Aff.html"><strong aria-hidden="true">6.2.1.2.</strong> Effect Eff and Aff</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/index.html"><strong aria-hidden="true">6.2.1.3.</strong> Aff</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/01-Basics/index.html"><strong aria-hidden="true">6.2.1.3.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/01-Basics/01-Launching-Aff-ps.html"><strong aria-hidden="true">6.2.1.3.1.1.</strong> Launching Aff.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/01-Basics/02-Delay-ps.html"><strong aria-hidden="true">6.2.1.3.1.2.</strong> Delay.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/01-Basics/03-Fork-Join-ps.html"><strong aria-hidden="true">6.2.1.3.1.3.</strong> Fork Join.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/01-Basics/04-Suspend-Join-ps.html"><strong aria-hidden="true">6.2.1.3.1.4.</strong> Suspend Join.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/01-Basics/05-Cached-Join-ps.html"><strong aria-hidden="true">6.2.1.3.1.5.</strong> Cached Join.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/01-Basics/06-Switching-Contexts-ps.html"><strong aria-hidden="true">6.2.1.3.1.6.</strong> Switching Contexts.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.1.3.2.</strong> Lifting Monads</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/02-Lifting-Monads/01-MonadEffect.html"><strong aria-hidden="true">6.2.1.3.2.1.</strong> MonadEffect</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/02-Lifting-Monads/02-SpecialLog-ps.html"><strong aria-hidden="true">6.2.1.3.2.2.</strong> SpecialLog.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/02-Lifting-Monads/03-Timeout-and-Interval-ps.html"><strong aria-hidden="true">6.2.1.3.2.3.</strong> Timeout and Interval.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.1.3.3.</strong> Node ReadLine</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/03-Node-ReadLine/01-Readline-API.html"><strong aria-hidden="true">6.2.1.3.3.1.</strong> Readline API</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/03-Node-ReadLine/02-ReadLine-Effect-ps.html"><strong aria-hidden="true">6.2.1.3.3.2.</strong> ReadLine Effect.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/03-Node-ReadLine/03-Converting-Effects-with-Callbacks-into-Aff.html"><strong aria-hidden="true">6.2.1.3.3.3.</strong> Converting Effects with Callbacks into Aff</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/03-Node-ReadLine/04-ReadLine-Aff-ps.html"><strong aria-hidden="true">6.2.1.3.3.4.</strong> ReadLine Aff.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/02-Effect-and-Aff/src/03-Aff/04-Useful-Aff-Libraries.html"><strong aria-hidden="true">6.2.1.3.4.</strong> Useful Aff Libraries</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/index.html"><strong aria-hidden="true">6.3.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/01-General-Debugging.html"><strong aria-hidden="true">6.3.1.1.</strong> General Debugging</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/02-Custom-Type-Errors/index.html"><strong aria-hidden="true">6.3.1.2.</strong> Custom Type Errors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/02-Custom-Type-Errors/01-Overview-API-ps.html"><strong aria-hidden="true">6.3.1.2.1.</strong> Overview API.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/02-Custom-Type-Errors/02-Values-ps.html"><strong aria-hidden="true">6.3.1.2.2.</strong> Values.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/02-Custom-Type-Errors/03-Functions-ps.html"><strong aria-hidden="true">6.3.1.2.3.</strong> Functions.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/02-Custom-Type-Errors/04-Type-Class-Instances-ps.html"><strong aria-hidden="true">6.3.1.2.4.</strong> Type Class Instances.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/03-Debug/index.html"><strong aria-hidden="true">6.3.1.3.</strong> Debug</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/03-Debug/01-Debug-ps.html"><strong aria-hidden="true">6.3.1.3.1.</strong> Debug.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/03-Debug/02-DebugWarning.html"><strong aria-hidden="true">6.3.1.3.2.</strong> DebugWarning</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/03-Debug/03-Local-State-ps.html"><strong aria-hidden="true">6.3.1.3.3.</strong> Local State.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/04-Console-Based-Debugging.html"><strong aria-hidden="true">6.3.1.4.</strong> Console Based Debugging</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/03-Debugging/src/05-Other-Tips.html"><strong aria-hidden="true">6.3.1.5.</strong> Other Tips</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/index.html"><strong aria-hidden="true">6.4.</strong> Collections and Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/src/01-Foldable.html"><strong aria-hidden="true">6.4.1.1.</strong> Foldable</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/src/02-Traversable.html"><strong aria-hidden="true">6.4.1.2.</strong> Traversable</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/src/03-Their-Variations.html"><strong aria-hidden="true">6.4.1.3.</strong> Their Variations</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/src/11-PureScript-Filterable.html"><strong aria-hidden="true">6.4.1.4.</strong> PureScript Filterable</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/src/21-Unfoldable.html"><strong aria-hidden="true">6.4.1.5.</strong> Unfoldable</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/src/22-Unfoldable1.html"><strong aria-hidden="true">6.4.1.6.</strong> Unfoldable1</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/04-Collections-and-Loops/src/31-Closing-Thoughts.html"><strong aria-hidden="true">6.4.1.7.</strong> Closing Thoughts</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/index.html"><strong aria-hidden="true">6.5.</strong> Application Structure</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/00-A-Bad-Program-ps.html"><strong aria-hidden="true">6.5.1.1.</strong> A Bad Program.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/01-Monads-and-Effects.html"><strong aria-hidden="true">6.5.1.2.</strong> Monads and Effects</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/index.html"><strong aria-hidden="true">6.5.1.3.</strong> MTL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/01-Foundations.md/index.html"><strong aria-hidden="true">6.5.1.3.1.</strong> Foundations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/01-Foundations.md/01-The-Function-Monad.html"><strong aria-hidden="true">6.5.1.3.1.1.</strong> The Function Monad</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/01-Foundations.md/02-Do-Notation-for-Monadic-Functions.html"><strong aria-hidden="true">6.5.1.3.1.2.</strong> Do Notation for Monadic Functions</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/01-Foundations.md/03-Special-Output.html"><strong aria-hidden="true">6.5.1.3.1.3.</strong> Special Output</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/01-Foundations.md/04-Introducing-Monad-Transformers.html"><strong aria-hidden="true">6.5.1.3.1.4.</strong> Introducing Monad Transformers</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/02-Implementing-a-Monad-Transformer/index.html"><strong aria-hidden="true">6.5.1.3.2.</strong> Implementing a Monad Transformer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/02-Implementing-a-Monad-Transformer/01-Looking-at-OO-for-a-Pattern.html"><strong aria-hidden="true">6.5.1.3.2.1.</strong> Looking at OO for a Pattern</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/02-Implementing-a-Monad-Transformer/02-Implementing-the-Pattern.html"><strong aria-hidden="true">6.5.1.3.2.2.</strong> Implementing the Pattern</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/02-Implementing-a-Monad-Transformer/03-A-Magical-Monad.html"><strong aria-hidden="true">6.5.1.3.2.3.</strong> A Magical Monad</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/02-Implementing-a-Monad-Transformer/04-Proving-the-Syntax.html"><strong aria-hidden="true">6.5.1.3.2.4.</strong> Proving the Syntax</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.3.3.</strong> Ask and Reader</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/11-Ask-and-Reader/01-Overview.html"><strong aria-hidden="true">6.5.1.3.3.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/11-Ask-and-Reader/02-Monad-Ask-Example-ps.html"><strong aria-hidden="true">6.5.1.3.3.2.</strong> Monad Ask Example.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/11-Ask-and-Reader/03-Monad-Reader-Example-ps.html"><strong aria-hidden="true">6.5.1.3.3.3.</strong> Monad Reader Example.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.3.4.</strong> Monad State</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/12-Monad-State/01-Monad-State.html"><strong aria-hidden="true">6.5.1.3.4.1.</strong> Monad State</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/12-Monad-State/02-Monad-State-Example-ps.html"><strong aria-hidden="true">6.5.1.3.4.2.</strong> Monad State Example.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.3.5.</strong> Tell and Writer</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/13-Tell-and-Writer/01-Overview.html"><strong aria-hidden="true">6.5.1.3.5.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/13-Tell-and-Writer/02-Monad-Tell-Example-ps.html"><strong aria-hidden="true">6.5.1.3.5.2.</strong> Monad Tell Example.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/13-Tell-and-Writer/03-Monad-Writer-Example-ps.html"><strong aria-hidden="true">6.5.1.3.5.3.</strong> Monad Writer Example.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.3.6.</strong> Throw and Error</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/14-Throw-and-Error/01-Overview.html"><strong aria-hidden="true">6.5.1.3.6.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/14-Throw-and-Error/02-Monad-Throw-Example-ps.html"><strong aria-hidden="true">6.5.1.3.6.2.</strong> Monad Throw Example.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/14-Throw-and-Error/03-Monad-Error-Example-ps.html"><strong aria-hidden="true">6.5.1.3.6.3.</strong> Monad Error Example.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.3.7.</strong> Monad Cont</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/15-Monad-Cont/01-A-Quick-Explanation.html"><strong aria-hidden="true">6.5.1.3.7.1.</strong> A Quick Explanation</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/15-Monad-Cont/02-Monad-Cont.html"><strong aria-hidden="true">6.5.1.3.7.2.</strong> Monad Cont</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/15-Monad-Cont/03-Monad-Cont-Example-ps.html"><strong aria-hidden="true">6.5.1.3.7.3.</strong> Monad Cont Example.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/16-Other-Monad-Transformers.html"><strong aria-hidden="true">6.5.1.3.8.</strong> Other Monad Transformers</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.3.9.</strong> Using a Monad Transformer</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/21-Using-a-Monad-Transformer/01-How-Monad-Trans-Works.html"><strong aria-hidden="true">6.5.1.3.9.1.</strong> How Monad Trans Works</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/21-Using-a-Monad-Transformer/02-Using-Monad-Trans.html"><strong aria-hidden="true">6.5.1.3.9.2.</strong> Using Monad Trans</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/21-Using-a-Monad-Transformer/03-Monad-Transformer-Stacks.html"><strong aria-hidden="true">6.5.1.3.9.3.</strong> Monad Transformer Stacks</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.3.10.</strong> Monad Trans</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/22-Monad-Trans/01-Monad-Trans.html"><strong aria-hidden="true">6.5.1.3.10.1.</strong> Monad Trans</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/22-Monad-Trans/02-Monad-Trans-Example-ps.html"><strong aria-hidden="true">6.5.1.3.10.2.</strong> Monad Trans Example.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/31-Drawbacks-of-MTL.html"><strong aria-hidden="true">6.5.1.3.11.</strong> Drawbacks of MTL</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/02-MTL/32-The-ReaderT-Capability-Design-Pattern.html"><strong aria-hidden="true">6.5.1.3.12.</strong> The ReaderT Capability Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/index.html"><strong aria-hidden="true">6.5.1.4.</strong> Free</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.1.4.1.</strong> What Is The Free Monad</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/01-What-Is-The-Free-Monad/01-What-Are-Free-SomeTypeClass-Types.html"><strong aria-hidden="true">6.5.1.4.1.1.</strong> What Are Free SomeTypeClass Types</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/01-What-Is-The-Free-Monad/02-What-Is-And-Is-Not-The-Free-Monad.html"><strong aria-hidden="true">6.5.1.4.1.2.</strong> What Is And Is Not The Free Monad</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/01-What-Is-The-Free-Monad/03-The-Original-Free-Monad.html"><strong aria-hidden="true">6.5.1.4.1.3.</strong> The Original Free Monad</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/01-What-Is-The-Free-Monad/04-The-Remorseless-Free-Monad.html"><strong aria-hidden="true">6.5.1.4.1.4.</strong> The Remorseless Free Monad</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/index.html"><strong aria-hidden="true">6.5.1.4.2.</strong> Why Use the Free Monad</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/01-Seeing-and-Solving-a-Simple-Example.html"><strong aria-hidden="true">6.5.1.4.2.1.</strong> Seeing and Solving a Simple Example</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/02-Reducing-Boilerplate-via-Either.html"><strong aria-hidden="true">6.5.1.4.2.2.</strong> Reducing Boilerplate via Either</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/03-Seeing-and-Solving-a-Harder-Example.html"><strong aria-hidden="true">6.5.1.4.2.3.</strong> Seeing and Solving a Harder Example</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/04-Writing-the-Evaluate-Function.html"><strong aria-hidden="true">6.5.1.4.2.4.</strong> Writing the Evaluate Function</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/05-Optional-Read--Writing-the-Show-Function.html"><strong aria-hidden="true">6.5.1.4.2.5.</strong> Optional Read: Writing the Show Function</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/06-From-Expression-to-Free/index.html"><strong aria-hidden="true">6.5.1.4.2.6.</strong> From Expression to Free</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/06-From-Expression-to-Free/01-Value-ps.html"><strong aria-hidden="true">6.5.1.4.2.6.1.</strong> Value.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/06-From-Expression-to-Free/02-Add-ps.html"><strong aria-hidden="true">6.5.1.4.2.6.2.</strong> Add.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/06-From-Expression-to-Free/03-Multiply-ps.html"><strong aria-hidden="true">6.5.1.4.2.6.3.</strong> Multiply.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/06-From-Expression-to-Free/04-AddAndMultiply-ps.html"><strong aria-hidden="true">6.5.1.4.2.6.4.</strong> AddAndMultiply.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/07-Defining-Modular-Monads.html"><strong aria-hidden="true">6.5.1.4.2.7.</strong> Defining Modular Monads</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/02-Why-Use-the-Free-Monad/08-Layered-Compilers.html"><strong aria-hidden="true">6.5.1.4.2.8.</strong> Layered Compilers</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/index.html"><strong aria-hidden="true">6.5.1.4.3.</strong> From Free to Run</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/01-From-Either-to-Variant.html"><strong aria-hidden="true">6.5.1.4.3.1.</strong> From Either to Variant</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/02-From-Coproduct-to-VariantF/index.html"><strong aria-hidden="true">6.5.1.4.3.2.</strong> From Coproduct to VariantF</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/02-From-Coproduct-to-VariantF/01-Value-ps.html"><strong aria-hidden="true">6.5.1.4.3.2.1.</strong> Value.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/02-From-Coproduct-to-VariantF/02-Add-ps.html"><strong aria-hidden="true">6.5.1.4.3.2.2.</strong> Add.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/02-From-Coproduct-to-VariantF/03-Multiply-ps.html"><strong aria-hidden="true">6.5.1.4.3.2.3.</strong> Multiply.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/02-From-Coproduct-to-VariantF/11-Original-Gist.html"><strong aria-hidden="true">6.5.1.4.3.2.4.</strong> Original Gist</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/03-Explaining-Run/index.html"><strong aria-hidden="true">6.5.1.4.3.3.</strong> Explaining Run</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/03-Explaining-Run/01-Value-ps.html"><strong aria-hidden="true">6.5.1.4.3.3.1.</strong> Value.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/03-Explaining-Run/02-Add-ps.html"><strong aria-hidden="true">6.5.1.4.3.3.2.</strong> Add.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/03-Explaining-Run/03-Multiply-ps.html"><strong aria-hidden="true">6.5.1.4.3.3.3.</strong> Multiply.purs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/03-Free/04-Drawbacks-of-Free.html"><strong aria-hidden="true">6.5.1.4.4.</strong> Drawbacks of Free</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/11-Hello-World/index.html"><strong aria-hidden="true">6.5.1.5.</strong> Hello World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/11-Hello-World/01-Design-Thought-Process.html"><strong aria-hidden="true">6.5.1.5.1.</strong> Design Thought Process</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/11-Hello-World/02-ReaderT-ps.html"><strong aria-hidden="true">6.5.1.5.2.</strong> ReaderT.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/11-Hello-World/03-Free-ps.html"><strong aria-hidden="true">6.5.1.5.3.</strong> Free.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/11-Hello-World/04-Run-ps.html"><strong aria-hidden="true">6.5.1.5.4.</strong> Run.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/12-Number-Comparison/index.html"><strong aria-hidden="true">6.5.1.6.</strong> Number Comparison</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/12-Number-Comparison/01-Design-Thought-Process.html"><strong aria-hidden="true">6.5.1.6.1.</strong> Design Thought Process</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/12-Number-Comparison/02-ReaderT-ps.html"><strong aria-hidden="true">6.5.1.6.2.</strong> ReaderT.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/12-Number-Comparison/03-Free-ps.html"><strong aria-hidden="true">6.5.1.6.3.</strong> Free.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/12-Number-Comparison/04-Run-ps.html"><strong aria-hidden="true">6.5.1.6.4.</strong> Run.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/05-Application-Structure/src/21-Modern-FP-Architecture.html"><strong aria-hidden="true">6.5.1.7.</strong> Modern FP Architecture</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/06-Type-Level-Programming/index.html"><strong aria-hidden="true">6.6.</strong> Type Level Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.1.</strong> src</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/06-Type-Level-Programming/src/01-Understanding-a-Type-Level-Function.html"><strong aria-hidden="true">6.6.1.1.</strong> Understanding a Type Level Function</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/06-Type-Level-Programming/src/02-Symbol-Example-ps.html"><strong aria-hidden="true">6.6.1.2.</strong> Symbol Example.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/06-Type-Level-Programming/src/03-Row-Example-ps.html"><strong aria-hidden="true">6.6.1.3.</strong> Row Example.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/06-Type-Level-Programming/src/04-Type-Level-Primitives.html"><strong aria-hidden="true">6.6.1.4.</strong> Type Level Primitives</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.1.5.</strong> RowList</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/06-Type-Level-Programming/src/05-RowList/01-Simple-ps.html"><strong aria-hidden="true">6.6.1.5.1.</strong> Simple.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/06-Type-Level-Programming/src/05-RowList/02-Advanced-ps.html"><strong aria-hidden="true">6.6.1.5.2.</strong> Advanced.purs</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/index.html"><strong aria-hidden="true">6.7.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/index.html"><strong aria-hidden="true">6.7.1.</strong> test</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/index.html"><strong aria-hidden="true">6.7.1.1.</strong> Unit</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.7.1.1.1.</strong> Spec Examples</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.7.1.1.1.1.</strong> Self Contained</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/01-Self-Contained/01-Console-Reporter-ps.html"><strong aria-hidden="true">6.7.1.1.1.1.1.</strong> Console Reporter.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/01-Self-Contained/02-Dot-Reporter-ps.html"><strong aria-hidden="true">6.7.1.1.1.1.2.</strong> Dot Reporter.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/01-Self-Contained/03-Spec-Reporter-ps.html"><strong aria-hidden="true">6.7.1.1.1.1.3.</strong> Spec Reporter.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/01-Self-Contained/04-Tap-Reporter-ps.html"><strong aria-hidden="true">6.7.1.1.1.1.4.</strong> Tap Reporter.purs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.7.1.1.1.2.</strong> Modulated</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/02-Modulated/Runner-ps.html"><strong aria-hidden="true">6.7.1.1.1.2.1.</strong> Runner.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/02-Modulated/Spec1-ps.html"><strong aria-hidden="true">6.7.1.1.1.2.2.</strong> Spec1.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/02-Modulated/Spec2-ps.html"><strong aria-hidden="true">6.7.1.1.1.2.3.</strong> Spec2.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/02-Modulated/Spec3-ps.html"><strong aria-hidden="true">6.7.1.1.1.2.4.</strong> Spec3.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/01-Unit/01-Spec-Examples/FocusedSpec-ps.html"><strong aria-hidden="true">6.7.1.1.1.3.</strong> FocusedSpec.purs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/index.html"><strong aria-hidden="true">6.7.1.2.</strong> Quick Check and Laws</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/01-Gen-and-MonadGen.html"><strong aria-hidden="true">6.7.1.2.1.</strong> Gen and MonadGen</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/02-Test-Syntax-ps.html"><strong aria-hidden="true">6.7.1.2.2.</strong> Test Syntax.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/03-Generating-Random-Data-ps.html"><strong aria-hidden="true">6.7.1.2.3.</strong> Generating Random Data.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/04-Generating-Strings-ps.html"><strong aria-hidden="true">6.7.1.2.4.</strong> Generating Strings.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/05-Arbitrary-ps.html"><strong aria-hidden="true">6.7.1.2.5.</strong> Arbitrary.purs</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/06-Coarbitrary.html"><strong aria-hidden="true">6.7.1.2.6.</strong> Coarbitrary</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/07-Problems-with-Arbitrary.html"><strong aria-hidden="true">6.7.1.2.7.</strong> Problems with Arbitrary</a></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/02-Quick-Check-and-Laws/08-Quick-Check-Laws-ps.html"><strong aria-hidden="true">6.7.1.2.8.</strong> Quick Check Laws.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/07-Testing/test/03-Property-Testing-Libraries-Comparison.html"><strong aria-hidden="true">6.7.1.3.</strong> Property Testing Libraries Comparison</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/08-Benchmarking/index.html"><strong aria-hidden="true">6.8.</strong> Benchmarking</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.8.1.</strong> benchmark</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/21-Hello-World/08-Benchmarking/benchmark/01-Benchmark-Syntax-ps.html"><strong aria-hidden="true">6.8.1.1.</strong> Benchmark Syntax.purs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/21-Hello-World/11-Next-Steps.html"><strong aria-hidden="true">6.9.</strong> Next Steps</a></li></ol></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/index.html"><strong aria-hidden="true">7.</strong> Design Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/31-Design-Patterns/01-Smart-Constructors.html"><strong aria-hidden="true">7.1.</strong> Smart Constructors</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/index.html"><strong aria-hidden="true">7.2.</strong> Partial Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/01-Via-Partial-ps.html"><strong aria-hidden="true">7.2.1.</strong> Via Partial.purs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/02-Via-Maybe-ps.html"><strong aria-hidden="true">7.2.2.</strong> Via Maybe.purs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/03-Via-Either-String-ps.html"><strong aria-hidden="true">7.2.3.</strong> Via Either String.purs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/04-Via-Either-ErrorType-ps.html"><strong aria-hidden="true">7.2.4.</strong> Via Either ErrorType.purs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/05-Via-Refined-Types-ps.html"><strong aria-hidden="true">7.2.5.</strong> Via Refined Types.purs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/06-Using-Variant-Based-Errors.html"><strong aria-hidden="true">7.2.6.</strong> Using Variant Based Errors</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/02-Partial-Functions/07-Via-Default-Values.html"><strong aria-hidden="true">7.2.7.</strong> Via Default Values</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Phantom Types</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/31-Design-Patterns/03-Phantom-Types/01-What-Are-Phantom-Types.html"><strong aria-hidden="true">7.3.1.</strong> What Are Phantom Types</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/03-Phantom-Types/02-Restricting-Argument-Types-ps.html"><strong aria-hidden="true">7.3.2.</strong> Restricting Argument Types.purs</a></li></ol></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/04-Records--Use-Type-Data-or-Newtype.html"><strong aria-hidden="true">7.4.</strong> Records: Use Type Data or Newtype</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/05-A-Better-TODO.html"><strong aria-hidden="true">7.5.</strong> A Better TODO</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/06-Boolean-Blindness.html"><strong aria-hidden="true">7.6.</strong> Boolean Blindness</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/07-Fairbairn-Threshold.html"><strong aria-hidden="true">7.7.</strong> Fairbairn Threshold</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/08-Keyword-Argument-Pattern.html"><strong aria-hidden="true">7.8.</strong> Keyword Argument Pattern</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/09-Project-Prelude.html"><strong aria-hidden="true">7.9.</strong> Project Prelude</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/21-Internal-Modules.html"><strong aria-hidden="true">7.10.</strong> Internal Modules</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/22-Generics.html"><strong aria-hidden="true">7.11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/23-Stack-Safety.html"><strong aria-hidden="true">7.12.</strong> Stack Safety</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/24-Data-Validation-via-Applicative.html"><strong aria-hidden="true">7.13.</strong> Data Validation via Applicative</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/25-Parsing.html"><strong aria-hidden="true">7.14.</strong> Parsing</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/26-Serialization-via-Codecs.html"><strong aria-hidden="true">7.15.</strong> Serialization via Codecs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/31-Zipper.html"><strong aria-hidden="true">7.16.</strong> Zipper</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/32-Optics.html"><strong aria-hidden="true">7.17.</strong> Optics</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/33-Recursion-Schemes.html"><strong aria-hidden="true">7.18.</strong> Recursion Schemes</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/34-Defunctionalization.html"><strong aria-hidden="true">7.19.</strong> Defunctionalization</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/35-Church-Encoding.html"><strong aria-hidden="true">7.20.</strong> Church Encoding</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/41-GADTs.html"><strong aria-hidden="true">7.21.</strong> GADTs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/42-Existential-Types-ps.html"><strong aria-hidden="true">7.22.</strong> Existential Types.purs</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/43-Higher-Kinded-Data.html"><strong aria-hidden="true">7.23.</strong> Higher Kinded Data</a></li><li class="chapter-item expanded "><a href="content/31-Design-Patterns/61-Hyperfunctions.html"><strong aria-hidden="true">7.24.</strong> Hyperfunctions</a></li></ol></li><li class="chapter-item expanded "><a href="content/91-Type-Classes/index.html"><strong aria-hidden="true">8.</strong> Type Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/91-Type-Classes/External-Explanations.html"><strong aria-hidden="true">8.1.</strong> External Explanations</a></li><li class="chapter-item expanded "><a href="content/91-Type-Classes/Functors.html"><strong aria-hidden="true">8.2.</strong> Functors</a></li><li class="chapter-item expanded "><a href="content/91-Type-Classes/Group-Like.html"><strong aria-hidden="true">8.3.</strong> Group Like</a></li><li class="chapter-item expanded "><a href="content/91-Type-Classes/Type-Level-Programming.html"><strong aria-hidden="true">8.4.</strong> Type Level Programming</a></li><li class="chapter-item expanded "><a href="content/91-Type-Classes/Utility-Functions.html"><strong aria-hidden="true">8.5.</strong> Utility Functions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">PureScript: Jordan&#x27;s Reference</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/jordanmartinez/purescript-jordans-reference" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#preface" id="preface">Preface</a></h1>
<p>This repo is my way of using the <a href="https://medium.com/taking-note/learning-from-the-feynman-technique-5373014ad230">Feynman Technique</a> to learn Purescript and its ecosystem.</p>
<p>Feynman used simple language, storytelling, comprehensively wrote down everything he knew about the topic, then attempted to teach it such that a child could understand it. Without jargon but with brevity, he identified what he didn't know to the audience and had his content organized.</p>
<h2><a class="header" href="#intended-audience" id="intended-audience">Intended Audience</a></h2>
<p>The intended reader is one who has some background in programming, but no background in the Functional Programming paradigm. A reader should consult the summarized version of the Table of Contents below before determining what and how much to read.</p>
<p>If you want to understand why you should care about PureScript, read through the <a href="./content/01-Getting-Started/01-Why-Learn-PureScript.html">Why Learn PureScript</a> page and <strong>Philosophical Foundations</strong> section, starting with <a href="./content/02-FP-Philosophical-Foundations/01-Composition-Everywhere.html">Composition Everywhere</a>.</p>
<p>If you want to learn PureScript, read the entire work from start to finish.</p>
<h2><a class="header" href="#overview-and-scope-of-the-work" id="overview-and-scope-of-the-work">Overview and Scope of the Work</a></h2>
<p>All code in this work uses PureScript <code>0.14.2</code></p>
<p>This work was created so a reader can understand PureScript and how to use it properly from a deep foundational understanding. Most other resources will get you started quickly, but then you will get confused at some point along the way. This resource takes longer to get started, but you will either not be confused or be less confused when we get to more advanced topics (e.g. monad transformers, type-level programming, etc.)</p>
<p>This work does not cover how to use PureScript to do web-development. In other words, things like the following:</p>
<ul>
<li>how to use a PureScript single-page application (SPA) framework to build a frontend</li>
<li>how to use a web server framework to build a backend</li>
<li>how to do bundling and/or code-splitting effectively</li>
<li>how to use HTML and CSS correctly, etc.</li>
</ul>
<p>None of the above things need to be known to learn PureScript, but one will need to learn the above things outside of this work before they can build a great application via PureScript.</p>
<h2><a class="header" href="#how-to-read-this-work" id="how-to-read-this-work">How to Read This Work</a></h2>
<p>This work is intended to be read in the following order:</p>
<ol>
<li>Getting Started</li>
<li>FP Philosophical Foundations</li>
<li>Building Tools</li>
<li>Syntax</li>
<li>Hello World</li>
</ol>
<p>The &quot;Design Patterns&quot; section should be read alongside of the &quot;Syntax&quot; and &quot;Hello World&quot; folders.</p>
<p>Check the issue tracker for any <a href="https://github.com/JordanMartinez/purescript-jordans-reference/issues?q=is%3Aissue+is%3Aopen+label%3Abug">unresolved issues via the <code>bug</code> label</a>.</p>
<h2><a class="header" href="#summarized-table-of-contents" id="summarized-table-of-contents">Summarized Table of Contents</a></h2>
<p>There are currently 8 parts to this book. I summarize what is in each section below by showing the kinds of questions the section answers:</p>
<ul>
<li><strong>00-Getting-Started</strong>:
<ul>
<li>Why learn/use PureScript?</li>
<li>How do I set up an editor (using Atom)?</li>
<li>How do I use the REPL?</li>
<li>What other things should I know before starting my learning journey?</li>
</ul>
</li>
<li><strong>01-Philosophical Foundations</strong>:
<ul>
<li>What are some foundational ideas I need to understand before FP makes more sense?</li>
<li>What is the &quot;big idea&quot; behind using FP languages?</li>
<li>What are the drawbacks of using FP languages?</li>
</ul>
</li>
<li><strong>02-Build-Tools</strong>:
<ul>
<li>Which tools do I use to compile and build my libraries/applications?</li>
<li>What are the workflows behind using those tools?</li>
<li>What other optional tools help me be more productive?</li>
</ul>
</li>
<li><strong>11-Syntax</strong>:
<ul>
<li>How do I learn PureScript's syntax easily?</li>
<li>What other compiler features exist syntactically?</li>
<li>How do I read/write type-level programming?</li>
<li>How does <code>do notation</code> and <code>ado notation</code> work?</li>
<li>How does rebinding <code>do notation</code> and rebinding <code>ado notation</code> work?</li>
</ul>
</li>
<li><strong>21-Hello-World</strong>:
<ul>
<li>How do I write a simple program?</li>
<li>How do I debug a program?</li>
<li>How do I write a complex program using modern FP architecture?</li>
<li>How do I test a program?</li>
<li>How do I benchmark a program or function within a program?</li>
<li>What are some examples of simple and complex real-world projects?</li>
</ul>
</li>
<li><strong>31-Design Patterns</strong>:
<ul>
<li>What are commonly-used patterns or idioms to solve problems in FP languages?</li>
<li>What are other FP principles or concepts not explained in the &quot;Hello World&quot; part of this work?</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#contributing" id="contributing">Contributing</a></h2>
<p>Feel free to <a href="https://github.com/jordanmartinez/purescript-jordans-reference/issues">open a new issue</a> for:</p>
<ul>
<li>Clarification on something you don't understand. If I don't know it yet and I'm interested, it'll force me to learn it</li>
<li>A link to something you'd like me to research more. If I'm interested or see the value, I'll look into it and try to document it or explain the idea in a clear way</li>
<li>Corrections for any mistakes or typos I've made</li>
<li>Improvements to anything I've written thus far</li>
</ul>
<h1><a class="header" href="#license" id="license">License</a></h1>
<p>Unless stated otherwise in a specific folder or file, this project is licensed under the <code>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</code>: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">(Human-readable version)</a>, <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode">(Actual License)</a></p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a></p>
<h1><a class="header" href="#versioning-policy" id="versioning-policy">Versioning Policy</a></h1>
<p>The below versioning policy was created to abide by the following principles:</p>
<h3><a class="header" href="#principles" id="principles">Principles</a></h3>
<ul>
<li><strong>Indicate PS version:</strong>
<ul>
<li>The release should indicate which major PureScript version is being used for the library. This helps one know whether the work is still up-to-date.</li>
</ul>
</li>
<li><strong>Provide &quot;stable&quot; versions...</strong>:
<ul>
<li>Readers of a given version should be able to read and bookmark files without worrying about those files/links breaking due to changes in its name (via renaming/reordering files, headers in files, etc.)</li>
<li>Older versions should be available via <code>git tag</code>.</li>
</ul>
</li>
<li><strong>...without restricting developer creativity</strong>:
<ul>
<li>I should be able to continue writing new content and re-ordering things without concern</li>
</ul>
</li>
<li><strong>Load the latest release:</strong>
<ul>
<li>This repo should show the latest release version of this project, not the one on which I'm working. In other words, the default branch should coincide with the last release.</li>
</ul>
</li>
<li><strong>Lessen maintenance as much as possible:</strong>
<ul>
<li>There should only be two branches, <code>latestRelease</code> and <code>development</code> since a branch name like <code>master</code> is overloaded with connotations. Those who want to read older versions can checkout a tag.</li>
<li>I currently will not hyperlink to other files within this project until either a <code>1.0.0</code> release is made or I find a way to automate that.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#release-syntax-and-explanation" id="release-syntax-and-explanation">Release Syntax and Explanation</a></h3>
<p><code>ps-[purescript's major release]-v[Major].[Minor].[Patch]</code> where</p>
<ul>
<li>purescript's major release means
<ul>
<li>Normally, this would be <code>1.x.x</code>, but we don't yet have a <code>1.0</code> release yet. Thus, it is currently <code>0.13.x</code></li>
<li><code>x</code> is a placeholder for the latest minor/patch release.</li>
</ul>
</li>
<li>major change means
<ul>
<li>a file/folder name has changed, so that bookmarks or links to that file/folder are now broken</li>
<li>files/folders have been modified, so that one is recommended to re-read the modified parts</li>
<li>a dependency (e.g. PureScript, Spago, etc.) was updated to a breaking change release</li>
</ul>
</li>
<li>minor change means
<ul>
<li>a file's contents have been modified/updated to such a degree that one is recommended to re-read the modified parts- Read through these links about learning:</li>
<li>a file's header name has changed, so that bookmarks or links to that header/section are now broken</li>
<li>Spago was updated to a minor release</li>
</ul>
</li>
<li>patch means
<ul>
<li>additional files/folders have been added without breaking links</li>
<li>a file's contents have been modified/updated to a minor degree that one could re-read the modified parts but is not likely to benefit much from it.</li>
<li>a file's contents have been slightly updated (typos, markdown rendering issues, etc.)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This folder will cover the following topics:</p>
<ul>
<li>Why learn PureScript</li>
<li>How to install Purescript</li>
<li>Getting familiar with the REPL</li>
<li>Other info you should know before working through the other folders in this project</li>
</ul>
<h1><a class="header" href="#why-learn-purescript" id="why-learn-purescript">Why Learn PureScript?</a></h1>
<p>All languages make tradeoffs in various areas and on various spectrums:</p>
<ul>
<li>learning curve</li>
<li>abstractions</li>
<li>syntax</li>
<li>errors</li>
<li>type systems</li>
<li>etc.</li>
</ul>
<p>The question is &quot;Which combination of tradeoffs provides the most benefits in prioritized areas?&quot; &quot;Good&quot; languages happen to select specific tradeoffs that make the language well-suited for specific problems. For example, Python is well-suited for creating dirty one-time-run scripts to do tedious work on a computer. While Python can be used to create financial or medical applications that need to be extremely fast and secure, it would be better to use a different language that is better suited for such a task, such as Rust.</p>
<p>PureScript has chosen tradeoffs that its developers think are the best for creating simple to complex front-end applications that &quot;just work;&quot; that are easy to refactor, debug, and test; and help make developers more productive rather than less.</p>
<p>It can be said that other front-end languages buy &quot;popularity&quot; at the cost of &quot;power and productivity.&quot;
PureScript buys &quot;power and productivity&quot; at the cost of &quot;popularity.&quot;</p>
<p>To fully answer &quot;Why learn PureScript?&quot; we must answer three other questions:</p>
<ul>
<li>Why one should use Javascript to build programs...</li>
<li>...but not write Javascript to build it...</li>
<li>...and write Purescript instead of alternatives</li>
</ul>
<h2><a class="header" href="#why-one-should-use-javascript-to-build-programs" id="why-one-should-use-javascript-to-build-programs">Why one should use Javascript to build programs...</a></h2>
<ul>
<li>The web browser is the new <a href="https://www.youtube.com/embed/YI34UIMgkxs?start=1762&amp;end=1828">&quot;dumb terminal&quot;</a> / platform-independent OS:
<ul>
<li><a href="https://whatwebcando.today/">What can web do today?</a></li>
</ul>
</li>
<li><a href="https://article.voxsnap.com/atrium/founders-should-build-website-not-mobile-app">Why Founders Should Start With a Website, Not a Mobile App</a></li>
<li>The points mentioned in this article: <a href="https://web.archive.org/web/20181201032915/https://medium.com/zerotomastery/learn-to-code-in-2018-get-hired-and-have-fun-along-the-way-b338247eed6a">Learn Javascript in 2018</a></li>
</ul>
<h2><a class="header" href="#but-not-write-javascript-to-build-it" id="but-not-write-javascript-to-build-it">...but not write Javascript to build it...</a></h2>
<ul>
<li><a href="https://medium.com/javascript-non-grata/javascript-is-a-dysfunctional-programming-language-a1f4866e186f">JavaScript is a Dysfunctional Programming Language</a></li>
<li><a href="https://medium.com/javascript-non-grata/the-top-10-things-wrong-with-javascript-58f440d6b3d8">Top 10 Things Wrong with JavaScript</a></li>
<li><a href="https://whydoesitsuck.com/why-does-javascript-suck/">Why JavaScript Sucks</a></li>
</ul>
<p>Some other ideas that are relevant:</p>
<ul>
<li>dynamic typing leads to errors that do not appear until after you have already shipped the code to your customers</li>
<li>a linter is just a basic static type checker</li>
<li>it is sometimes easier to write, read, and understand a 'safer language' that compiles to efficient Javascript than to write, read, and understand JavaScript itself (as the above articles show)</li>
</ul>
<h2><a class="header" href="#and-write-purescript-instead-of-alternatives" id="and-write-purescript-instead-of-alternatives">...and write Purescript instead of alternatives</a></h2>
<p><strong>TL;DR</strong></p>
<ul>
<li><a href="https://youtu.be/vDe-4o8Uwl8?t=8">The Power of Composition</a></li>
<li><a href="https://www.youtube.com/watch?time_continue=22&amp;v=5AtyWgQ3vv0">Purescript: Tomorrow's Javascript Today</a></li>
<li><a href="https://youtu.be/GlUcCPmH8wI?t=24">Code Reuse in PureScript: Functions, Type Classes, and Interpreters</a></li>
<li><a href="https://gist.github.com/paf31/adfd15fbb1ac8b99fc68be2c9aca8427">Phil Freeman's post: 'Why You Should Use PureScript'</a></li>
<li>PureScript's &quot;Real World App&quot;s
<ul>
<li>See the <a href="https://github.com/thomashoneyman/purescript-halogen-realworld">Halogen version of 'Real World App'</a></li>
<li>See the <a href="https://github.com/jonasbuntinx/purescript-react-realworld">React version of 'Real World App'</a></li>
</ul>
</li>
<li><a href="https://discourse.purescript.org/t/language-highlights/1471">A Discourse pose describing some of the disadvantages of TypeScript and Elm when compared to PureScript</a></li>
</ul>
<h3><a class="header" href="#language-comparisons" id="language-comparisons">Language Comparisons</a></h3>
<p>For a full list of possible alternatives to JavaScript, see <a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">CoffeeScript's wiki's list of 'Languages that compile to JavaScript'</a></p>
<p><strong>Note</strong>: the below comparisons are still a WIP. To fully support this claim, it would help to compare each languages' various &quot;overall rating&quot; on various aspects. Unfortunately, since I'm not familiar with every other language mentioned, it's very difficult for me to do that. If you are familiar with such languages, consider opening an issue on this repo and discussing it with me.</p>
<p>In short, the below comparison will be biased towards PureScript and will not yet fairly represent the corresponding side in some situations. Consider this a starting point for your own research.</p>
<h4><a class="header" href="#purescript-vs-typescript" id="purescript-vs-typescript">PureScript vs TypeScript</a></h4>
<p>One of the main issues with JavaScript is a poor type system. Many errors aren't discovered until a person, usually a customer, runs the program. Many of these same errors could be detected and fixed before shipping code if one used a language with a better type system.</p>
<p>TypeScript seems to address this type safety issue. Just consider its name! However, a few people who are using PureScript now have said this about TypeScript: &quot;You might as well be writing Javascript.&quot; TypeScript does not provide any real guarantees; it only pretends. PureScript does provide such guarantees.</p>
<ul>
<li><a href="https://blog.logrocket.com/typescript-vs-purescript-not-all-compilers-are-created-equal-c16dadaa7d3e">TypeScript vs PureScript: Not All Compilers Are Created Equal</a></li>
<li><a href="https://www.youtube.com/watch?v=JTEfpNtEoSA">JavaScript, TypeScript, and PureScript</a> or &quot;Why TypeScript only 'pretends' to have types.&quot;</li>
<li><a href="https://discourse.purescript.org/t/type-system-showdown-purescript-and-typescript/2084">Various examples comparing PureScript and TypeScript</a></li>
</ul>
<h4><a class="header" href="#purescript-vs-elm" id="purescript-vs-elm">PureScript vs Elm</a></h4>
<p>Since Elm is founded on the similar philosophical foundations as PureScript, one can use Elm and gain many of the same benefits as PureScript due to its type safety. However, there is a ceiling on the abstractions one can express in Elm. PureScript's ceiling is much higher than Elm's because it has type classes.</p>
<p>Elm</p>
<ul>
<li>... sacrifices the following features ...
<ul>
<li>type classes, which
<ul>
<li>reduce boilerplate code since the compiler can write code for you</li>
<li>enable one to define and uphold constraints about their program (e.g. this sequence of commands must be executed in the correct order)</li>
</ul>
</li>
</ul>
</li>
<li>... to gain the following ...
<ul>
<li>clear actionable error messages because there are less ambiguous cases to deal with in the type system</li>
</ul>
</li>
</ul>
<p>Elm and PureScript can both be used to build a complex website. However, one will need to write more lines of code in Elm than they would in PureScript.</p>
<h4><a class="header" href="#purescript-vs-ocaml--reason" id="purescript-vs-ocaml--reason">PureScript vs OCaml / Reason</a></h4>
<p>This section has not yet been written.</p>
<h4><a class="header" href="#purescript-vs-ghcjs" id="purescript-vs-ghcjs">PureScript vs GHCJS</a></h4>
<p>Haskell, which heavily influenced PureScript, has an option for compiling Haskell to JavaScript via GHCJS. However, that comes with its own tradeoffs. PureScript was developed partly because those tradeoffs were too costly.</p>
<p>See <a href="https://discourse.purescript.org/t/ps-or-ghcjs-for-frontend-with-haskell-backend/666/2">PS or ghcjs for Frontend with Haskell backend</a> for my summary of the main issues at play here.</p>
<h1><a class="header" href="#the-strengths-of-purescript" id="the-strengths-of-purescript">The Strengths of PureScript</a></h1>
<p>In this file, I'll cover what some of the tradeoffs PureScript makes are and why they are good. These ideas will be further explained in the &quot;FP Philosophical Foundations&quot; folder that appears later in this repository.</p>
<h2><a class="header" href="#strongly-adheres-to-the-functional-programming-paradigm" id="strongly-adheres-to-the-functional-programming-paradigm">Strongly Adheres to the Functional Programming Paradigm</a></h2>
<ul>
<li><a href="https://www.ramanan.com/personal-blog/2019/2/25/functional-programming-and-venture-capital">A Secret Weapon for Startups -- Functional Programming?</a></li>
<li>Paradigm shifts, such as the one demonstrated by this video using C++, are what enable programs with less problems: <a href="https://www.youtube.com/embed/i9CU4CuHADQ?start=540">Logging a function's name each time it is called: migrating an &quot;object-oriented paradigm&quot; solution to an &quot;functional paradigm&quot; solution</a>. As will be explained later, this is what is known as the &quot;Writer Monad.&quot;</li>
<li><a href="http://blog.ezyang.com/2010/05/design-patterns-in-haskel/">Object-oriented &quot;design patterns&quot; in FP languages</a> are often just functions in disguise. Rather than learning the 20 different design patterns, one can learn how functions work and can be used to create really beautiful concepts and solutions.</li>
<li><a href="https://www.youtube.com/watch?v=US8QG9I1XW0">Functional Architecture: The Pits of Success</a>. To summarize this video, FP languages force you to structure your code in a way that makes it:
<ul>
<li>easy to test in an unbiased way (Can I prove that the logic/algorithm that solves the business problem is correct and works according to the specification despite any programmer's laziness or lack of foresight in thinking of a possible scenario where the code could fail?)</li>
<li>easy to add/change/remove a &quot;backend&quot; to account for trends, new insights, or faster code (Without introducing a new bug or deleting a current feature, can I switch from Company A's database to Company B's database without rewriting more than 30 lines of code?)</li>
<li>unconcerning to allow a new developer to work on the code, knowing that he/she cannot screw up anything major (Can the Lead/Senior Developer take the weekend off and return, knowing that it's extraordinarily difficult for developers with little experience to break something?)</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#powerful-static-type-system" id="powerful-static-type-system">Powerful Static Type System</a></h2>
<ul>
<li>This video explains how a type system with <code>algebraic data types</code> comes with a number of benefits (note: it uses a different syntax than PureScript: <a href="https://www.youtube.com/watch?v=Up7LcbGZFuo">Domain Modeling Made Functional</a>. To summarize it, <code>algebraic data types</code>
<ul>
<li>allow you to model a domain at a 1-to-1 ratio</li>
<li>make impossible states impossible</li>
<li>become your always-up-to-date UML diagrams</li>
<li>make it easy for new developers to learn how the code is structured</li>
<li>guide how business logic should be implemented</li>
</ul>
</li>
<li>The PureScript compiler infers most of your types for you. For those who are curious and want to understand how that works, see this video: <a href="https://www.youtube.com/watch?v=ytPAlhnAKro">Type Inference From Scratch</a></li>
<li>The compiler (via its warning and error messages) is your friend, not your enemy. It
<ul>
<li>prevents you from releasing bug-filled code to a customer. (Can I guarantee that the code &quot;just works&quot; or cannot be built at all?)</li>
<li>forces you to handle most errors correctly the first time rather than permit you to throw them under the rug because you are lazy (Can I guarantee all possible errors will not create future problems that lead to short-term hard-to-understand code that rarely gets cleaned up and ultimately costs the company more time to fix than if it had just been written correctly the first time?)</li>
<li>helps you figure out how to implement functions correctly via &quot;Typed Holes&quot; (explained later in the <code>Syntax</code> folder)</li>
</ul>
</li>
<li>This video explains how a type system with <code>type classes</code> allow one to re-use &quot;dumb old data structures&quot; (i.e. <code>algebraic data types</code>) rather than create many new data structures that differ only one slight way: <a href="https://www.youtube.com/watch?v=hIZxTQP1ifo">Type Classes vs the World</a>. To summarize it, <code>type classes</code>
<ul>
<li>allow you to write declarative code (&quot;this is what will be true&quot;) rather than imperative code (&quot;this is how to make truth true (hopefully, you got it right)&quot;)</li>
<li>enables the compiler to infer runtime code</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#immutable-persistent-data-structures-by-default" id="immutable-persistent-data-structures-by-default">Immutable Persistent Data Structures by Default</a></h2>
<p>In PureScript, immutable data structures are the default rather than being &quot;opt-in.&quot; In most other languages, mutable data structures are the default with immutable ones being &quot;opt-in.&quot;</p>
<p>Immutable data structures are</p>
<ul>
<li>easier to reason about because the value never changes</li>
<li>are always thread-safe, preventing many typical issues with concurrency</li>
<li>can be as performant as mutable data structures in most cases</li>
</ul>
<h2><a class="header" href="#multiple-backends-with-easy-foreign-function-interface" id="multiple-backends-with-easy-foreign-function-interface">Multiple Backends with Easy Foreign Function Interface</a></h2>
<p>Most languages have their own backend.</p>
<ul>
<li>Javascript is compiled and run via a Javascript engine.</li>
<li>Java compiles to bytecode that can be run on a Java Virtual Machine.</li>
<li>Python gets compiled into bytecode that is then interpreted.</li>
</ul>
<p>PureScript does not have a backend. Rather, it's source code can be compiled to other languages. While JavaScript is the focus, <a href="https://github.com/purescript/documentation/blob/master/ecosystem/Alternate-backends.md">PureScript compiles to other languages besides JavaScript</a>. Thus, writing one library in PureScript can work in multiple languages, and one can choose the backend (or a combination of them) that best solves their problem.</p>
<p>Caveat: PureScript's support for non-Javascript backends is still a work-in-progress. In future releases, they will be getting first-class support.</p>
<p>This backend-independent nature of PureScript makes &quot;Foreign Function Interface&quot; very clean. At various times, Language X needs to use code from another language, Language Y. For code written in one language to use code written in another language, there needs to be a &quot;Foreign Function Interface&quot; or FFI.</p>
<p>Many languages' FFI can be difficult to work with. Language X made various language tradeoff decisions that are different than Language Y. Getting two languages to work together is difficult to say the least. However, PureScript's FFI is very easy because PureScript already compiles to that language.</p>
<p>If you are compiling PureScript to Javascript, you can still write JavaScript as FFI for PureScript. This makes it possible to wrap Javascript libraries on which you heavily depend. It also enables one to easily migrate from some other language or framework (e.g. TypeScript, Angular, etc.) to PureScript in a modular, piece-by-piece fashion</p>
<h1><a class="header" href="#faqs-on-purescript" id="faqs-on-purescript">FAQs on PureScript</a></h1>
<p>I'll answer a few possible questions the below audiences may have:</p>
<ul>
<li>A developer who is already competent/productive in Javascript or a compile-to-Javascript language (e.g. Coffeescript, Typescript, etc.)</li>
<li>A developer who is only starting to learn web technologies, but has heard that Javascript is horrible and is investigating other compile-to-Javascript languages.</li>
<li>A business person who knows very little about programming or programming languages but who wants to know more about what options are available and what their pros/cons are.</li>
</ul>
<p>These are the kinds of questions the above people might be asking:</p>
<ul>
<li>Cost-Benefit Issue: Is the price of the steep learning curve worth the benefits of using PureScript in code?</li>
<li>Job Prospects Issue: If I learn PureScript, can I get a good developer job?</li>
<li>When-to-Learn Issue: Should I learn PureScript now or wait until sometime later?</li>
<li>Time-to-Productivity Issue: How long will it take me before I can write idiomatic code and be productive in PureScript?</li>
<li>Opportunity Cost Issue: If I choose to learn PureScript, will I later regret not having spent that same time learning a different compile-to-Javascript language (e.g. TypeScript, CoffeeScript, etc.) or a &quot;compile to WebAssembly&quot;-capable language (e.g. Rust) instead?</li>
<li>Ecosystem Issue: How mature is the Ecosystem? Will I need to initially spend time writing/improving/documenting libraries for this language or can I immediately use libraries that are stable and mature?</li>
<li>Foreign Function Interface Issue: How hard it is to use another language's libraries via bindings?</li>
<li>Program Tools Experience: How easy/pleasant is it to use the language's build tools (e.g. compiler, linter/type checker, dependency manager, etc.) and text editor tools (e.g. ease of setup, refactoring support, pop-up documentation, etc.)?</li>
<li>Community Friendliness Issue: How friendly, helpful, responsive, inspiring, determined, and collaborative are the people who use and contribute to this language and its ecosystem?</li>
<li>Code Migration Issue: What problems do developer teams typically encounter when migrating from Language X to PureScript and how hard are these to overcome?</li>
</ul>
<p>Let's answer these one at a time. <strong>Each answer is my opinion and could be backed up with better arguments and explanations in some areas.</strong>.</p>
<h3><a class="header" href="#is-the-price-of-the-steep-learning-curve-worth-the-benefits-of-using-purescript-in-code" id="is-the-price-of-the-steep-learning-curve-worth-the-benefits-of-using-purescript-in-code">Is the price of the steep learning curve worth the benefits of using PureScript in code?</a></h3>
<p>Yes. Most mainstream languages force you to depend on the IDE, linters, and other tools outside of the language to help you write correct code. Such languages often lack the features within the language itself to help you express certain ideas and constraints within your program. PureScript's powerful language features allow you to express what other languages cannot.</p>
<p>Even if one ultimately decides not to use PureScript, the language itself can be a helpful environment for training your mind to think more precisely about how to write code.</p>
<h3><a class="header" href="#if-i-learn-purescript-can-i-get-a-good-developer-job" id="if-i-learn-purescript-can-i-get-a-good-developer-job">If I learn PureScript, can I get a good developer job?</a></h3>
<ul>
<li>See the community-curated list of <a href="https://github.com/ajnsit/purescript-companies">companies who use PureScript in production right now</a>.</li>
<li>See <a href="https://discourse.purescript.org/t/do-you-have-a-purescript-app-in-production/20">Do you have a PureScript app in production?</a></li>
<li>Check for PureScript jobs listed on <a href="https://functionaljobs.com/jobs/search/?q=PureScript">Functional Jobs</a></li>
</ul>
<h3><a class="header" href="#should-i-learn-purescript-now-or-wait-until-sometime-later" id="should-i-learn-purescript-now-or-wait-until-sometime-later">Should I learn PureScript now or wait until sometime later?</a></h3>
<p>You might want to learn it <strong>now</strong> for these reasons:</p>
<ul>
<li>PureScript is actually quite mature and close to a <code>1.0</code>. Many are already using it in production code.</li>
<li>PureScript is syntactically and conceptually very similar to Haskell. If you learn PureScript, you've basically learned Haskell, too. I believe that PureScript provides a better environment for learning Functional Paradigm concepts than Haskell since it's easier to install, build, and experiment with.
<ul>
<li>No need to use any language extensions (e.g. <code>OverloadedStrings</code>)</li>
<li>Better record syntax</li>
<li>More granular type class hierarchy</li>
</ul>
</li>
<li>This project covers enough items that you should be able to learn PureScript relatively quickly. Still, while this project's code compiles and runs, its accuracy has not been verified by an &quot;expert in the language&quot; per say.</li>
</ul>
<p>You might want to learn it <strong>later</strong> for these reasons:</p>
<ul>
<li>PureScript's documentation could be improved in a number of ways:
<ul>
<li>Documentation for libraries are good in some areas and lacking in others.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#how-long-will-it-take-me-before-i-can-write-idiomatic-code-and-be-productive-in-purescript" id="how-long-will-it-take-me-before-i-can-write-idiomatic-code-and-be-productive-in-purescript">How long will it take me before I can write idiomatic code and be productive in PureScript?</a></h3>
<p>The average time for learning FP languages in general is usually 6 months due to the below reasons. This repository hopes to speed that process up, but, as always, people learn at different paces:</p>
<ul>
<li>Many tutorials/guides assume their readers already know foundational principles. New learners who read them often do not know, nor are even aware of, those foundational principles.
<ul>
<li>This project's <code>Hello World/FP Philosophical Foundations</code> folder exists to counter this issue</li>
</ul>
</li>
<li>No one really explains what the &quot;big picture&quot; that FP programming is all about. Thus, it's hard to see how some concept fits in the larger scheme of things, much less why that concept is so fundamental to everything.
<ul>
<li>See this project's <code>Hello World/FP Philosophical Foundations/07-FP--The-Big-Picture.md</code> file</li>
</ul>
</li>
<li>People (wrongly) believe that they must know a very abstract mathematics called &quot;Category Theory&quot; in order to use/write PureScript or another FP language. Due to its very abstract nature, Category Theory can be difficult to grasp and scares people off.
<ul>
<li>This &quot;myth&quot; is false. Most FP developers do not understand Category Theory and yet they already have an intuition for some of its ideas.</li>
</ul>
</li>
<li>The syntax for FP languages are paradigmatically different than the syntax with which most developers are familiar (C/Java/Python). It takes a while to get used to a &quot;different&quot; syntax family before it feels normal. Until it feels normal, reading through code examples will be harder.
<ul>
<li>This project's <code>Syntax</code> folder exists to counter the above issue.</li>
</ul>
</li>
<li>Related to the above, FP languages often use symbol-based aliases to refer to functions that are well-known to FP Programmers instead of those functions' literal names (e.g. <code>&lt;$&gt;</code> instead of <code>map</code>, <code>&lt;$</code> instead of <code>voidRight</code>, <code>$&gt;</code> instead of <code>voidLeft</code>). It's more concise and similarities between these symbol-based aliases add meaning to them, such as their &quot;direction.&quot; Since new learners do not already know that to which function a symbol refers, it can be hard to know what that function even does.
<ul>
<li><a href="https://pursuit.purescript.org/search?q=%28%3C%24%3E%29">A Pursuit search that wraps the symbol in parenthensis (e.g. <code>(&lt;$&gt;)</code>)</a> fixes this problem</li>
<li>This project's <code>Type Classes/ReadMe.md#Functions</code> section explains how to read the <code>Type Classes/assets/Type-Class-Functions.xlsx</code> file, which provides a table that indicates what those symbol-based fuction names are and from where they come.</li>
</ul>
</li>
<li>Due to their powerful type systems, FP languages trade errors that occur when running the program (runtime errors) with errors that occur when attempting to build the program via the compiler (compile-time errors). To understand how to debug these compile-time &quot;your program would not work if it was built&quot; errors, one must have a strong understanding of how the compiler and its type system works.
<ul>
<li>This project's <code>Syntax</code> folder (and more specifically, the <code>Syntax/Type-Level Programming Syntax</code> folder) explain enough to help one understand why some (but not all) problems arise.</li>
<li>The <a href="https://github.com/purescript/documentation/tree/master/errors">Error Documentation</a> sometimes explains what the error is and how to fix it (<a href="https://github.com/purescript/documentation/blob/master/errors/NoInstanceFound.md">example</a>) and other times is simply left unexplained (<a href="https://github.com/purescript/documentation/blob/master/errors/AmbiguousTypeVariables.md">example</a>).</li>
<li>The <code>purescript-beginner</code> Slack channel is active and often helps people troubleshoot the error messages.</li>
</ul>
</li>
<li>Related to the above point, the powerful type system enables one to model some abstract ideas in a very precise way using well-defined types or things called type classes. When these features start to stack, a new learner can become overwhelmed.
<ul>
<li>If one reads this work in order, they are unlikely to be overwhelmed.</li>
<li>Most of the &quot;cool type things&quot; one can do are helpful but not always necessary. Consider <a href="https://patrickmn.com/software/the-haskell-pyramid/">the Haskell Pyramid</a>. &quot;Monads&quot; are an important and fundamental FP concept, but new learners do not need to learn what they are or how to use them right away.</li>
</ul>
</li>
<li>Many people try to re-explain something that another has already explained well and they write a poor re-explanation. It's hard to determine which explanations are accurate and correct and which are vague and mistaken until after you have already read it and/or know better.
<ul>
<li>I've been you. This work is my attempt to sift through the noise and present things in the best and simplest way possible. In various cases, I summarize and/or link to other posts that I believe to be credible that also explain a concept clearly. My sources include <code>Haskell Weekly</code>, the Functional Programming Slack channels of <code>#purescript</code> and <code>#purescript-beginners</code>, a number of books I've read on FP programming, a number of papers I've read on FP programming, and various videos I've watched regarding FP programming.</li>
</ul>
</li>
<li>There are few sites or locations that &quot;centralize&quot; a lot of high-quality FP guides/explanations. Thus, it's hard for new learners to find them.
<ul>
<li>This project exists partly because of this issue and hopes to resolve some of these problems.</li>
<li>For other &quot;centralized&quot; locations, see <code>Hello World/ReadMe.md#other-learning-resources</code>.</li>
</ul>
</li>
<li>Many ideas are explained in papers that are not written for new learners but for academics. Understanding these papers' contents sometimes requires an understanding of high-level math, notation for specific concepts, etc., making the entry barrier higher
<ul>
<li>In various situations, I link to such papers and only in one situation do I walk a read through such a paper. In other words, this problem is still at large.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#if-i-choose-to-learn-purescript-will-i-later-regret-not-having-spent-that-same-time-learning-a-different-compile-to-javascript-language-eg-typescript-coffeescript-etc-or-a-compile-to-webassembly-capable-language-eg-rust-instead" id="if-i-choose-to-learn-purescript-will-i-later-regret-not-having-spent-that-same-time-learning-a-different-compile-to-javascript-language-eg-typescript-coffeescript-etc-or-a-compile-to-webassembly-capable-language-eg-rust-instead">If I choose to learn PureScript, will I later regret not having spent that same time learning a different compile-to-Javascript language (e.g. TypeScript, CoffeeScript, etc.) or a &quot;compile to WebAssembly&quot;-capable language (e.g. Rust) instead?</a></h3>
<p>You might regret it if you are not being honest or thoughtful about the purpose you are trying to achieve. Not being aware of your expectations, nor having realistic ones, will almost always end in having those expectatiosn broken, leaving you angry, disappointed, or frustrated.</p>
<p>Some facts:</p>
<ul>
<li>WebAssembly holds promise, but it is still being developed.</li>
<li>Languages that are popular or backed by companies with many resources are not necessarily the best languages to use for your particular purposes</li>
<li>While PureScript offers more guarantees than most other languages, it unfortunately might not be the best language to use/learn if
<ul>
<li>you need mature libraries for a particular need that hasn't yet been written in PureScript. This is one benefit of TypeScript/Javascript.</li>
<li>you find that Elm's tradeoffs are &quot;good enough&quot; for your purposes.</li>
</ul>
</li>
<li>A few people who are using PureScript now have said this about TypeScript: &quot;You might as well be writing Javascript&quot;</li>
</ul>
<h3><a class="header" href="#how-mature-is-the-ecosystem-will-i-need-to-initially-spend-time-writingimprovingdocumenting-libraries-for-this-language-or-can-i-immediately-use-libraries-that-are-stable-and-mature" id="how-mature-is-the-ecosystem-will-i-need-to-initially-spend-time-writingimprovingdocumenting-libraries-for-this-language-or-can-i-immediately-use-libraries-that-are-stable-and-mature">How mature is the Ecosystem? Will I need to initially spend time writing/improving/documenting libraries for this language or can I immediately use libraries that are stable and mature?</a></h3>
<p>It's primarily good for front-end work and not so much (yet) for back-end work. When it is lacking, one will likely need to use FFI to utilize JS libraries. See <a href="https://github.com/passy/awesome-purescript">awesome-purescript</a> and the documentation site, <a href="http://pursuit.purescript.org/">Pursuit</a>.</p>
<p>Also, attempting to port over Haskell libraries to this language are harder at times and have unexpected performance. Why? Because Haskell is a lazily-evaluated language, but PureScript is a strictly-evaluated language.</p>
<h3><a class="header" href="#how-hard-it-is-to-use-another-languages-libraries-via-bindings" id="how-hard-it-is-to-use-another-languages-libraries-via-bindings">How hard it is to use another language's libraries via bindings?</a></h3>
<p>Writing bindings is simple. See the <code>Syntax/Foreign Function Interface</code> folder for examples of how simple bindings are and things related to this.</p>
<p>However, using FFI via bindings can introduce runtime errors. Whenever one uses a library via FFI, you don't know whether a function will throw an exception or not. This can produce unexpected runtime errors even though you've written your code in a type-safe language. On stable mature well-tested libraries, this shouldn't be a big problem.</p>
<p>Lastly, writing bindings is tedious. PureScript uses algebraic data types (ADTs), but most libraries will define one function that can take multiple sets of arguments. For example, one might call the function, <code>foo</code>, with any of these sets of arguments:</p>
<ul>
<li><code>foo(&quot;apple&quot;)</code> (the first String argument, <code>apple</code>, is required)</li>
<li><code>foo(&quot;apple&quot;, [&quot;banana&quot;, &quot;orange&quot;])</code> (the Array of Strings argument is optional)</li>
<li><code>foo(&quot;apple&quot;, [&quot;banana&quot;, &quot;orange&quot;], true)</code> (the boolean flag is optional, too)</li>
<li><code>foo(&quot;apple&quot;, {first:&quot;banana&quot;, second:&quot;orange&quot;}, true)</code> (the array can be passed in as a record/map/dictionary/object, too)</li>
<li><code>foo(&quot;apple&quot;, {first:&quot;banana&quot;, second:&quot;orange&quot;, optional: true}, true)</code> (the second argument can have optional fields in addition to its required ones)</li>
</ul>
<p>In reality, <code>foo</code> is at least 5 different functions that are all using the same name. Thus, writing bindings for <code>foo</code> is tedious to do in a language like PureScript due to PureScript's type-safe nature. However, there is a <a href="https://github.com/jvliwanag/purescript-untagged-union">library for handling</a> these kind of situations.</p>
<p>Others have also worked on writing code-generators that, for example, can look at the code of a library written in TypeScript and generate the corresponding PureScript bindings for that code. Such a tool is still a work-in-progress.</p>
<h3><a class="header" href="#how-easypleasant-is-it-to-use-the-languages-build-tools-eg-compiler-lintertype-checker-dependency-manager-etc-and-text-editor-tools-eg-ease-of-setup-refactoring-support-pop-up-documentation-etc" id="how-easypleasant-is-it-to-use-the-languages-build-tools-eg-compiler-lintertype-checker-dependency-manager-etc-and-text-editor-tools-eg-ease-of-setup-refactoring-support-pop-up-documentation-etc">How easy/pleasant is it to use the language's build tools (e.g. compiler, linter/type checker, dependency manager, etc.) and text editor tools (e.g. ease of setup, refactoring support, pop-up documentation, etc.)?</a></h3>
<p>The build tools are pretty good. One will typically use a <code>spago</code>-based workflow. These are explained in <code>Build Tools/Tool Comparisons/Dependency Managers.md</code>.</p>
<p>See the <code>Build Tools/</code> folder for more up-to-date information. Likewise, see <a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md">Editor and Tool Support</a> for other editor-related configurations.</p>
<h3><a class="header" href="#how-friendly-helpful-responsive-inspiring-determined-and-collaborative-are-the-people-who-use-and-contribute-to-this-language-and-its-ecosystem" id="how-friendly-helpful-responsive-inspiring-determined-and-collaborative-are-the-people-who-use-and-contribute-to-this-language-and-its-ecosystem">How friendly, helpful, responsive, inspiring, determined, and collaborative are the people who use and contribute to this language and its ecosystem?</a></h3>
<p>People usually get help from some of the core contributors or other well-informed people via the <code>#purescript</code> and <code>#purescript-beginners</code>. No question is too stupid. For longer threads, some post on the <a href="https://discourse.purescript.org">PureScript Discorse Forum</a>.</p>
<p>The language's development is currently slow because each core contributor have full-time jobs and contribute in their spare time, not because they don't want to.</p>
<h3><a class="header" href="#what-problems-do-developer-teams-typically-encounter-when-migrating-from-language-x-to-purescript-and-how-hard-are-these-to-overcome" id="what-problems-do-developer-teams-typically-encounter-when-migrating-from-language-x-to-purescript-and-how-hard-are-these-to-overcome">What problems do developer teams typically encounter when migrating from Language X to PureScript and how hard are these to overcome?</a></h3>
<ul>
<li>See Phil Freeman's own blog post on the matter: <a href="https://medium.com/fuzzy-sharp/purescript-and-haskell-at-lumi-7e8e2b16fb13">PureScript and Haskell at Lumi</a></li>
<li>Thomas Honeyman's <a href="https://thomashoneyman.com/articles/replace-react-components-with-purescript/">How to Replace React Components with PureScript's React libraries</a></li>
<li><a href="https://www.youtube.com/watch?v=bt130Z7UNPE">(Video) JavaScript to PureScript - a Migration Story</a> &amp; <a href="https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/Curran-angular-purescript-halogen.pdf">Slides</a></li>
<li><a href="https://www.youtube.com/watch?v=SiGXTcFEvHo">(Video) Adopting Pure FP Incrementally - Engineering at Lumi</a></li>
<li>Likewise, see <a href="https://alasconnect.github.io/blog/posts/2018-10-02-introducing-haskell-to-a-company.html">Introducing Haskell to a Company</a>, which can equally apply to Purescript</li>
<li>See <a href="https://www.youtube.com/watch?v=3USNLflRRUA">Robert Kluin - Introducing A Functional Language At Work - C 2018</a>/<a href="https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/A%20Developer%E2%80%99s%20Guide%20to%20Introducing%20A%20Functional%20Language%20At%20Work.pdf">slides</a> for a cautionary tale of &quot;what can go wrong and why&quot; when he attempted to introduce Scala at work.</li>
</ul>
<h1><a class="header" href="#install-guide" id="install-guide">Install Guide</a></h1>
<h2><a class="header" href="#getting-additional-help" id="getting-additional-help">Getting Additional Help</a></h2>
<p>Throughout your learning process, it will be helpful to ask others for help. The two places this is often done is on the ML forum and the Slack group chat. If you encounter problems when installing anything below, ask for help on the Slack group's <code>#purescript-beginner</code> channel and you should receive help.</p>
<ul>
<li>Register for an account on the Functional Programming Slack group <a href="https://fpchat-invite.herokuapp.com/">here</a> and add yourself to these two channels:<code>#purescript-beginner</code>, <code>#purescript</code>. You may also be interested in these channels: <code>#categoryTheory</code>, <code>#haskell</code>, and <code>#haskell-beginner</code> .</li>
<li>Register for the Purescript ML forum <a href="https://discourse.purescript.org/">here</a></li>
</ul>
<h2><a class="header" href="#setting-up-purescript-for-the-first-time" id="setting-up-purescript-for-the-first-time">Setting up Purescript for the First Time</a></h2>
<h3><a class="header" href="#overview" id="overview">Overview</a></h3>
<p>We'll show how to install the following programs:</p>
<ul>
<li><code>purescript</code> - the PureScript language &amp; compiler</li>
<li><code>spago</code> - a dependency manager and build tool for PureScript</li>
<li><code>parcel</code> - a build tool for bundling a PureScript application into a multiple JS backends (node, browser, electron)</li>
</ul>
<h3><a class="header" href="#installation" id="installation">Installation</a></h3>
<h4><a class="header" href="#installing-npm" id="installing-npm">Installing NPM</a></h4>
<p>We can install everything using <code>npm</code>. However, getting <code>npm</code> is it's own problem. We can either install it manually by downloading <code>node</code> and installing that. Or we can use <code>nvm</code> (Node Version Manager) to install it for us and continue from there.</p>
<h5><a class="header" href="#manual-install" id="manual-install">Manual Install</a></h5>
<p>Justin Woo explains how to set up one's environment for the <code>0.12.x</code> release but has not been updated for two things. First, the PureScript release at the time was <code>0.12.0</code> but now <code>0.13.8</code> is out. Second, the instructions use <code>pulp</code> and <code>psc-package</code>, a different build tool workflow than the one we'll use here.</p>
<p>If you just want to get things set up ASAP, follow the below summary of his article's instructions (using <code>spago</code> instead of the other tools). If you want to understand why you should do these commands, read <a href="https://qiita.com/kimagure/items/570e6f2bbce5b4724564">his article here</a>:</p>
<ol>
<li>Install Node 10 or greater: https://nodejs.org/en/download/</li>
<li>Set your npm prefix: <code>npm set prefix ~/.npm</code>
<ul>
<li>Note: this prevents having to use <code>sudo</code> when using NPM to install things since it's default prefix is in a place that requires admin privileges</li>
</ul>
</li>
<li>Set your PATH: <code>export PATH=&quot;$HOME/.npm/bin:$PATH&quot;</code></li>
</ol>
<h5><a class="header" href="#nvm-install" id="nvm-install">NVM Install</a></h5>
<ol>
<li>Install <code>nvm</code> using their <a href="https://github.com/nvm-sh/nvm#installation-and-update">installation instructions</a></li>
<li><a href="https://github.com/nvm-sh/nvm#verify-installation">Verify that the installation was successful</a> via <code>command -v nvm</code></li>
<li><a href="https://github.com/nvm-sh/nvm#usage">Install <code>node</code> via <code>nvm</code></a>. To get the latest <code>node</code> version, use the command, <code>nvm install node</code>.</li>
</ol>
<p>Unlike the manual install, <code>nvm</code> properly handles the npm prefix for you. So, you don't need to set it yourself.</p>
<h4><a class="header" href="#installing-purescript-and-related-tooling" id="installing-purescript-and-related-tooling">Installing PureScript and Related Tooling</a></h4>
<p>Once you have installed <code>npm</code>, we can use it to install everything in one command:</p>
<pre><code class="language-bash">npm i -g purescript@0.14.2 spago@0.20.3 parcel
</code></pre>
<h3><a class="header" href="#versions-used-in-this-project" id="versions-used-in-this-project">Versions Used in this Project</a></h3>
<p>The following commands should now work (the versions beside them are the versions I used when writing this project):</p>
<pre><code class="language-bash">purs --version        # 0.14.2
spago version         # 0.20.3
parcel --version      # 1.12.4
</code></pre>
<h3><a class="header" href="#building-this-project" id="building-this-project">Building This Project</a></h3>
<p>Once the above has been verified, run the below script, which will download, install, and build every folder in this project. Open a shell in this project's parent folder and run this command:</p>
<pre><code class="language-bash">./for-each-folder--install-deps-and-compile.sh
</code></pre>
<p>Whenever I make a new release with breaking changes, this script will remove any outdated dependencies, reinstall the correct ones, and rebuild all of the folders' code.</p>
<h3><a class="header" href="#setting-up-your-editor" id="setting-up-your-editor">Setting up your editor</a></h3>
<p>The following are instructions for setting up the Atom editor. For Emacs, Vim, or Visual Studio, <a href="https://qiita.com/kimagure/items/570e6f2bbce5b4724564#install-some-editor-plugins">consult Justin Woo's post on the matter</a> and <a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#emacs">the respective page in the documentation repo</a></p>
<p>Atom setup instructions:</p>
<ol>
<li>Install Atom: <code>sudo apt-get install atom</code></li>
<li>Launch Atom and install the following packages:
<ul>
<li>ide-purescript</li>
<li>atom-ide-ui</li>
<li>language-purescript</li>
</ul>
</li>
<li>Configure <code>ide-purescript</code></li>
</ol>
<p>The Atom package, <code>ide-purescript</code>, is configured to <code>Bower</code>, but we'll be using <code>spago</code> as our dependency manager for this project. Follow these instructions</p>
<ol>
<li>Open Atom's settings dialog (<code>CTRL+,</code>)</li>
<li>Click on the <code>Packages</code> tab</li>
<li>Search for <code>ide-purescript</code></li>
<li>Click on the <code>Settings</code> button in the entry that appears</li>
<li>Check the <code>Add spago sources</code> checkbox</li>
<li>Change the <code>build command</code> to: <code>spago build -u --json-errors</code></li>
</ol>
<h3><a class="header" href="#getting-ide-support-autocomplete-documentation-on-hover-etc-in-atom" id="getting-ide-support-autocomplete-documentation-on-hover-etc-in-atom">Getting IDE support (autocomplete, documentation-on-hover, etc.) in Atom</a></h3>
<p>While this repository's contents are useful for learning various lessons, IDE support (autocomplete, documentation, etc.) will only work if you open this repository's contents in a specific way when using Atom. Follow the instructions below:</p>
<ol>
<li>Click &quot;File&quot; and click &quot;Open Folder...&quot; (shortcut: <code>CTRL+O</code>)</li>
<li>In the folder chooser, choose one of this repo's project folders (i.e. a folder with a <code>spago.dhall</code> file and <code>src</code> folder)</li>
<li>Click on &quot;Packages&quot; and click on &quot;PureScript&quot; and then on &quot;Build&quot;. The IDE server will start running and rebuild just that project.*
<ul>
<li>Autocomplete, importing, and documentation will now work.</li>
</ul>
</li>
</ol>
<ul>
<li>This is a command you will use frequently, so consider adding a keyboard shortcut for it.</li>
</ul>
<ol>
<li>Open the Atom settings dialog (<code>CTRL+,</code>)</li>
<li>Click on the &quot;KeyBindings&quot; tab</li>
<li>Click on the &quot;your keymap file&quot; hyperlink that appears before the bindings</li>
<li>Follow the instructions for adding your personal shortcut for the <code>ide-purescript:build</code> command.</li>
</ol>
<p>For mine, I did:</p>
<pre><code class="language-cson">'.platform-linux atom-workspace atom-text-editor:not([mini])':
  'ctrl-shift-b': 'ide-purescript:build'
</code></pre>
<h4><a class="header" href="#dealing-with-ide-server-issues-in-atom" id="dealing-with-ide-server-issues-in-atom">Dealing with IDE Server issues in Atom</a></h4>
<p>Sometimes when editing a file, the IDE server will go out-of-sync. For example, you might change the definition of a type and the IDE doesn't realize that occured, so it will tell you that you have used a type incorrectly. In such cases, rebuild the project using Step 3 (or your keyboard shortcut) above and things should correct themselves from there.</p>
<p>In situations where I have used the same names for things, the autocomplete might actually import a function or type with the same name as the one you want but from a different module. So, if you have weird compiler errors, check the imports to insure the IDE server didn't accidentally import something incorrect or from the wrong location.</p>
<h2><a class="header" href="#setting-up-module-linker" id="setting-up-module-linker">Setting up Module Linker</a></h2>
<p>When you're browsing through code on GitHub, the browser extenstion, Module Linker, can greatly help:
https://github.com/fiatjaf/module-linker</p>
<h1><a class="header" href="#the-repl" id="the-repl">The REPL</a></h1>
<p>REPL stands for Read, Evaluate, Print, Loop.</p>
<h2><a class="header" href="#starting-the-repl" id="starting-the-repl">Starting the REPL</a></h2>
<p>Use <code>spago repl</code>. The REPL should print something like the following:</p>
<pre><code>$ spago repl
PSCi, version 0.13.8
Type :? for help

import Prelude

&gt; |
</code></pre>
<p>Let's walk through each part:</p>
<ul>
<li><code>PSCi</code> means &quot;PureScript Compiler interactive&quot;. It's similar to GHCi, the Haskell language's REPL.</li>
<li><code>version</code> prints the PureScript version you are using.</li>
<li><code>:?</code> indicates how to print a list of commands with their description. These are described below in this file.</li>
</ul>
<p>After this, you may see zero or more <code>import &lt;ModuleName&gt;</code> lines. Spago will read the <code>.purs-repl</code> file to get this list and import the modules automatically. The <code>.purs-repl</code> file is covered at the end of this file.</p>
<p>Note: if you do not see <code>import Prelude</code> appear above, expressions like <code>5 + 5</code> will produce an error. To fix that, you should import the Prelude module by typing <code>import Prelude</code> followed by pressing Enter.</p>
<h2><a class="header" href="#using-the-repl" id="using-the-repl">Using the REPL</a></h2>
<p>In general, there are five things you can do in the REPL:</p>
<ol>
<li>See the result of an expression by typing it into the REPL (e.g. <code>3 + 3</code>) and hitting <code>Enter</code>.</li>
<li>Define a binding to some variable or function using the <code>binding = &lt;expression&gt;</code> syntax. For example...
<ul>
<li><code>x = 3</code></li>
<li><code>function = (\x -&gt; x + 1)</code></li>
</ul>
</li>
<li>Input multi-line expressions using the <code>:paste</code> command (followed by <code>CTRL+D</code>)</li>
<li>Use other commands to explore a module's functions, types, and kinds</li>
<li>Use other commands to interact with the REPL's current state (e.g. clearing out bindings and/or imported modules, showing which modules have been imported, etc.)</li>
</ol>
<h2><a class="header" href="#possible-outputted-repl-errors" id="possible-outputted-repl-errors">Possible Outputted REPL Errors</a></h2>
<p>Sometimes, the REPL will output errors. These errors may not be immediately understandable for new learners, so the table below will help you understand them and know what to do.</p>
<table><thead><tr><th>The Error</th><th>Its Meaning</th><th>What to do</th></tr></thead><tbody>
<tr><td>&quot;No type class instance was found for <code>Data.Show.Show [Type]</code>&quot;</td><td>An expression cannot be turned into a <code>String</code>. For example, a function's implementation (<code>(\x -&gt; x + 1)</code>) cannot be turned into a <code>String</code> whereas a value (<code>5</code>) or expression (<code>10 + 10</code>) can be (<code>5</code> and <code>20</code>, respectively).</td><td>If it's possible for you to define one, define an instance of the <code>Show</code> type class. If not, then ignore it and move on.</td></tr>
<tr><td>&quot;Multiple value declarations exist for [binding].&quot;</td><td>You defined the binding twice, which you cannot do</td><td>See <a href="content/01-Getting-Started/05-The-REPL.html#reload">the Reload command section</a> for what your options are</td></tr>
<tr><td>&quot;Unknown operator (+)&quot;</td><td>The <code>+</code> function was not imported because the <code>Prelude</code> module was imported</td><td>Import the Prelude module by typing <code>import Prelude</code> followed by pressing Enter.</td></tr>
</tbody></table>
<h2><a class="header" href="#a-quick-overview-of-some-of-the-repl-commands" id="a-quick-overview-of-some-of-the-repl-commands">A Quick Overview of Some of the REPL Commands</a></h2>
<p>The REPL offers a few commands. You can see the entire list by typing either <code>:help</code> or <code>:?</code> and pressing Enter.</p>
<p>These commands are listed in the same order as what the <code>:?</code> outputs.</p>
<p>Note: the commands can be shortened to their first unique letters. So, rather than entering <code>:type</code>, one can enter <code>:t</code>. Likewise, rather than entering <code>:paste</code> or <code>:print</code>, one can enter <code>:pa</code> or <code>:pr</code>, respectively.</p>
<h3><a class="header" href="#help" id="help">Help</a></h3>
<p>Displays the REPL commands via <code>:help</code>/<code>:?</code>.</p>
<h3><a class="header" href="#quit" id="quit">Quit</a></h3>
<p>Exits the REPL, returning control to your shell.</p>
<h3><a class="header" href="#reload" id="reload">Reload</a></h3>
<h4><a class="header" href="#the-problem" id="the-problem">The Problem</a></h4>
<p>You can only define a binding once. Defining it again with a different expression will output an error</p>
<pre><code class="language-haskell">x = 5 -- first time
x = 6 -- second time raises error
-- REPL's outputs error: &quot;Multiple value declarations exist for x.&quot;
</code></pre>
<p>You need to clear the <code>x</code> binding name to be able to reuse it for other bindings.</p>
<p>For example, let's say you wrote two functions and the second uses the first. However, you wrote the wrong implementation for the second and need to rewrite it:</p>
<pre><code class="language-haskell">add1 = (\x -&gt; x + 1)
times2 = (\x -&gt; x * 3) -- &quot;3&quot; should be &quot;2&quot;
</code></pre>
<h4><a class="header" href="#the-solutions" id="the-solutions">The Solutions</a></h4>
<p>Ideally, you could just clear the second function's binding and rewrite it. Unfortunately, you cannot do that. You can either:</p>
<ol>
<li>use the <code>:reload</code> command to clear out both functions' bindings, redefine the first one, and then define the second one with the correct implementation</li>
<li>define a new binding for the correct implementation:</li>
</ol>
<pre><code class="language-haskell">-- 1st option
add1 = (\x -&gt; x + 1)
times2 = (\x -&gt; x * 3) -- Whoops! &quot;3&quot; should be &quot;2&quot;
:reload
add1 = (\x -&gt; x + 1) -- define the &quot;add1&quot; binding again
times2 = (\x -&gt; x * 2) -- define &quot;times2&quot; again but with correct implmentation.

-- 2nd option
add1 = (\x -&gt; x + 1)
times2 = (\x -&gt; x * 3) -- Whoops! &quot;3&quot; should be &quot;2&quot;
times2_fix = (\x -&gt; x * 2) -- define new function with correct implementation
</code></pre>
<ol start="3">
<li>define your code in a file (as a module) and import that module into your REPL session. Any edits made to this file are picked-up upon a REPL reload.</li>
</ol>
<p>Create a file containing your REPL script:</p>
<pre><code class="language-haskell">-- MyModule.file
module MyModule where

import Prelude

add1 = (\x -&gt; x + 1)
times2 = (\x -&gt; x * 3) -- This typo will be fixed later
</code></pre>
<p>Load script into the REPL:</p>
<pre><code>&gt; import MyModule
&gt; times2 4
12
</code></pre>
<p>Make any edits to this file. For example, change to <code>times2 = (\x -&gt; x * 2)</code>. Save file, then reload in existing REPL session. The <code>MyModule</code> import will be remembered.</p>
<pre><code>&gt; :reload
&gt; times2 4
8
</code></pre>
<h3><a class="header" href="#clear" id="clear">Clear</a></h3>
<p>Use <code>:cl</code> rather than <code>:c</code> to distinguish between this command and <code>:complete</code>. This works the same as <code>:reload</code> except that all imported modules are also removed. If you do this, you will need to reimport any modules you wish to use. For example, you will likely need to reimport Prelude (<code>import Prelude</code>), so that you can use number operations (i.e. <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>) and the <code>==</code> function again.</p>
<h3><a class="header" href="#browse" id="browse">Browse</a></h3>
<p>See all the functions, types, and type classes that a module exports and which you can use</p>
<h3><a class="header" href="#type" id="type">Type</a></h3>
<p>This displays the type signature of a value, a function or a type-class. One should be able to determine what the body of the function does based on the type signature, so that body is not shown:</p>
<pre><code>&gt; :type x + 1
Int
&gt; :type (\x -&gt; x + 1)
Int -&gt; Int
</code></pre>
<h3><a class="header" href="#kind" id="kind">Kind</a></h3>
<p>Displays the kind of a type. Kinds will be explained more in the Syntax folder:</p>
<pre><code>&gt; :kind Int
Type
&gt; :kind (Int -&gt; Int)
Type
&gt; :kind Array
Type -&gt; Type
</code></pre>
<h3><a class="header" href="#show" id="show">Show</a></h3>
<p>There are two commands in this one:</p>
<ul>
<li><code>show loaded</code>/<code>:s loaded</code> - Shows all modules that the REPL session knows about. Some may or may not have been imported. (Before the REPL session starts, the PureScript compiler will compile all PureScript files based on the source globs given to it. All modules in those globs are then known to the REPL session, but you might not want to use them all in a given session.)</li>
<li><code>show import</code>/<code>:s import</code> - Shows which modules you currently have imported into the REPL session</li>
</ul>
<h3><a class="header" href="#print" id="print">Print</a></h3>
<p>Changes how a value is printed to the console after an expression is evaluated. By default, it uses <a href="https://github.com/purescript/purescript-psci-support/blob/master/src/PSCI/Support.purs"><code>PSCI.Support.eval</code></a>.</p>
<p>New learners can ignore this command for now. Those who are familiar with the language can change it to a different one by calling <code>:print Path.To.Module.functionName</code>.</p>
<p>Regardless, to reset it to the default, one can call <code>:print PSCI.Support.eval</code>.</p>
<h3><a class="header" href="#paste" id="paste">Paste</a></h3>
<p>The REPL only accepts single-line Purescript code. If anything requires you to write multi-line expressions, you must use the <code>:paste</code> command.</p>
<p>The workflow goes something like this:</p>
<ol>
<li>Type in the paste command: <code>:paste</code></li>
<li>Do one of the following
<ul>
<li>input multi-line expressions (e.g. a type class and its function, a data type and its values, a function's type signature and its implementation, etc.).</li>
<li>paste some external code into the REPL</li>
</ul>
</li>
<li>Type <code>CTRL+D</code>/<code>CMD+D</code> to indicate that you are finished.</li>
</ol>
<p>The REPL will then parse and all of the code, enabling you to use it from that point forward.</p>
<h3><a class="header" href="#complete" id="complete">Complete</a></h3>
<p>The REPL already supports tab-completion. So, this command isn't meant to be used by humans. Rather, it's for tools that need a way to get tab-completion. For context, see <a href="https://github.com/purescript/purescript/issues/3746#issuecomment-550512591">Harry's comment</a>.</p>
<h2><a class="header" href="#the-purs-repl-file" id="the-purs-repl-file">The <code>.purs-repl</code> File</a></h2>
<p>If you ever want to automatically import a list of modules, modify the <code>.purs-repl</code> file. By default, it will only display the following content:</p>
<pre><code>import Prelude
</code></pre>
<p>You can add more modules there so you don't have to type them in later:</p>
<pre><code>import Prelude
import Data.Maybe
import Data.Either
</code></pre>
<p>Unfortunately, defining variables in the file will not automatically create them before the REPL starts. Let's say you update <code>.purs-repl</code> to the below content</p>
<pre><code>import Prelude

x = 5
</code></pre>
<p>When you run <code>spago repl</code>, it will produce the following error:</p>
<pre><code>$ spago repl
PSCi, version 0.13.8
Type :? for help

Unexpected or mismatched indentation at line 3, column 1
</code></pre>
<h1><a class="header" href="#other-important-info" id="other-important-info">Other Important Info</a></h1>
<ul>
<li><a href="https://book.purescript.org/">Purescript By Example</a> is the official up-to-date book that teaches Purescript.</li>
<li><a href="https://github.com/JordanMartinez/purescript-cookbook">PureScript Cookbook</a> is an unofficial cookbook that shows &quot;How to do X&quot; in PureScript.</li>
<li><a href="https://github.com/milesfrain/not-yet-awesome-purescript">&quot;Not Yet Awesome&quot; PureScript</a> is a list of things that are not <em>yet</em> awesome in PureScript</li>
<li><a href="https://discourse.purescript.org/t/tip-configure-web-browser-for-convenient-pursuit-lookup/1561">Configure Web Browser for Convenient Pursuit Lookup</a> shows how to make it easy to search all documentation.
<ul>
<li>Consider using this same approach to setup a search using <strong>Starsuit</strong>, a Pursuit copy that works only packages in the latest package-set (a concept described more in the Build Tools folder of this repo). Use &quot;https://spacchetti.github.io/starsuit/#search:&quot; as your search.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#functional-programming-jargon" id="functional-programming-jargon">Functional Programming Jargon</a></h2>
<p>While reading through this repo, the <a href="https://github.com/hemanth/functional-programming-jargon">Functional Programming Jargon</a> might be a helpful reference whenever you come across a term that isn't covered in this project.</p>
<h2><a class="header" href="#writing-algorithms-in-an-fp-language" id="writing-algorithms-in-an-fp-language">Writing Algorithms in an FP Language</a></h2>
<p>This repo will not explain how to write algorithms in a performant way using an FP language. Consider reading <a href="https://www.amazon.com/Algorithm-Design-Haskell-Richard-Bird/dp/1108491618">Algorithm Design with Haskell</a> which does teach algorithms using an FP language.</p>
<h2><a class="header" href="#differences-from-haskell" id="differences-from-haskell">Differences From Haskell</a></h2>
<p>If you're coming to PureScript with a Haskell background, be sure to consult the following resources:</p>
<ul>
<li><a href="http://code.adriansieber.com/adrian/adriansieber-com/src/branch/master/posts/_2018-11-01_introduction_to_purescript_for_haskell_developers/main_light.pdf">Introduction to Purescript for Haskell Developers</a> (pdf)</li>
<li><a href="https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md">The Purescript Documentation Repo's &quot;Differences from Haskell&quot; page</a></li>
</ul>
<h2><a class="header" href="#use-github-search-to-find-things-search-engines-ie-google-dont" id="use-github-search-to-find-things-search-engines-ie-google-dont">Use GitHub Search to Find Things Search Engines (i.e. Google) Don't</a></h2>
<p>At various times, you may try to use something like Google to find documentation / examples and little will appear in the search results.</p>
<p>A better solution is to use GitHub's search. To learn its syntax, read <a href="https://help.github.com/en/articles/searching-code">searching code</a>.</p>
<p>Then, you use a search query like the following:</p>
<table><thead><tr><th>Goal</th><th>Search Query</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Find examples of projects that use a dependency (e.g. <code>purescript-prelude</code>)</td><td><a href="https://github.com/search?q=path%3A%2F+in%3Afile+purescript-prelude"><code>path:/ in:file purescript-prelude</code></a></td><td>Search a project's top-level files (e.g. <code>bower.json</code>/<code>spago.dhall</code>/<code>psc-package.json</code>) for the text <code>purescript-prelude</code></td></tr>
<tr><td>Find real-world examples of code that uses libraries (e.g. <code>aff-bus</code>)</td><td><a href="https://github.com/search?q=language%3Apurescript+path%3Asrc%2F+in%3Afile+Bus"><code>language:purescript path:src/ in:file &quot;Effect.Aff.Bus&quot;</code></a></td><td>Search a project's <code>src</code> directory for files whose content mentions the <code>Effect.Aff.Bus</code> module at some point. (Note: the full module name must be surrounded by quotes)</td></tr>
<tr><td>Find real-world examples of code that uses testing libraries (e.g. <code>aff-bus</code>)</td><td><a href="https://github.com/search?q=language%3Apurescript+path%3Atest%2F+in%3Afile+QuickCheck"><code>language:purescript path:test/ in:file &quot;Test.QuickCheck&quot;</code></a></td><td>Search a project's <code>test</code> directory for files whose content mentions the <code>Test.QuickCheck</code> module at some point. (Note: the full module name must be surrounded by quotes)</td></tr>
</tbody></table>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<ul>
<li>Anytime you need to look up the documentation for a package, you have two options:
<ul>
<li>use <a href="http://pursuit.purescript.org/">Pursuit</a>.
<ul>
<li>Pros: One can navigate through a library's version and dependencies</li>
<li>Cons: Some of the deprecated packages mentioned above are still posted there. (e.g. <code>purescript-dom-*</code> packages, which are deprecated in favor of <code>purescript-web-*</code> packages)</li>
</ul>
</li>
<li>use <a href="https://spacchetti.github.io/starsuit/index.html">Starsuit</a>
<ul>
<li>Pros: Only provides documentation for packages in the latest package set</li>
<li>Cons: One does not immediately know which version of a library is displayed, nor what its dependencies are.</li>
</ul>
</li>
</ul>
</li>
<li>Read <a href="https://pursuit.purescript.org/help/users#searching">Pursuit's Search Help page</a></li>
<li>Some libraries have not been updated to <code>0.13.8</code> and are still on the <code>0.11.7</code> release. Some still work; others won't. In this work, we will insure that you do not use any such libraries, but be aware of that if you browse the docs on your own.</li>
<li>Lastly, some libraries have not uploaded their latest versions' documentation. In these cases, we will forewarn you. Fortunately, <code>spago docs</code> will produce a local version of the source code's documentation that looks similar to Pursuit. It does not support all the features of Pursuit, but it's better than nothing. To do that, follow these commands:
<ul>
<li><code>spago docs --open</code> will generate the documentation and then use your default web browser to open the file, <code>generated-docs/html/index.html</code>.</li>
</ul>
</li>
</ul>
<p><strong>Undocumented Pursuit Tip</strong></p>
<p>To get the latest version of the Pursuit docs of a package's function, package's type, or the package itself, simply remove the version in the url. Pursuit will load the latest version of that package:
https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Eq</p>
<h1><a class="header" href="#composition-everywhere" id="composition-everywhere">Composition Everywhere</a></h1>
<p><strong>TL;DR</strong></p>
<p>Watch <a href="https://youtu.be/vDe-4o8Uwl8?t=8">The Power of Composition</a></p>
<hr>
<p>By &quot;composition,&quot; we mean, &quot;Assemble a few low-level reusable pieces into a higher-level piece.&quot; Here are some examples:</p>
<ul>
<li>(Classic example) <a href="https://www.wikiwand.com/en/Lego">Legos</a>. Using small blocks of plastic, people can create all sorts of interesting things.</li>
<li>Furniture. Using wood, metal, fabric, glass, and nails, people can create tables, chairs, desks, cabinets, etc.</li>
</ul>
<p>Composition makes FP code easy to refactor because we can always reassemble the smaller pieces into something new or different.</p>
<p>But what kinds of things do we compose? In Functional Programming, we compose types (called <code>algebraic data types</code>) and functions.</p>
<h2><a class="header" href="#composing-types-algebraically" id="composing-types-algebraically">Composing Types Algebraically</a></h2>
<p>Algebraic Data Types (ADTs) use Algebra to define the total number of values a given type (i.e. named Set) can have.</p>
<p>There are two videos worth watching in this regard. The table and visualizations that follow merely summarize their points, except for the ideas behind the <code>List</code> and <code>Tree</code> types in the second video.</p>
<ul>
<li><a href="https://youtu.be/Up7LcbGZFuo?t=1155">'Algebraic Data Types' as &quot;Composable Data Types&quot; (stop at 29:26)</a>
<ul>
<li>Same ideas already explained in the above &quot;Power of Composition&quot; video:</li>
<li>It uses a different syntax than <code>PureScript</code> but the ideas still apply.</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=YScIPA8RbVE">The Algebra of Algebraic Data Types</a>
<ul>
<li>Warning: video has terrible sound quality!</li>
<li>explains the &quot;algebraic laws&quot; behind ADTs</li>
<li>covers <code>List</code>s and <code>Tree</code>s (unlike first video)</li>
</ul>
</li>
</ul>
<table><thead><tr><th>Name</th><th>Math Operator</th><th>Logic Operator</th><th>PureScript Type</th><th>Idea</th></tr></thead><tbody>
<tr><td>Product Type</td><td><code>x * y</code></td><td>AND</td><td><code>Tuple</code></td><td>&quot;One value from type <code>x</code> <strong>AND</strong> one value from type <code>y</code>&quot;</td></tr>
<tr><td>Sum Type</td><td><code>x + y</code></td><td>OR</td><td><code>Either</code></td><td>&quot;One value from type <code>x</code> <strong>OR</strong> one value from type <code>y</code>&quot;</td></tr>
<tr><td>Exponential Type</td><td><code>y^x</code></td><td>???</td><td><code>InputType -&gt; OutputType</code></td><td>???</td></tr>
</tbody></table>
<p><img src="content/02-FP-Philosophical-Foundations/./assets/Composing-Types.svg" alt="Composing Types" /></p>
<h2><a class="header" href="#composing-functions" id="composing-functions">Composing Functions</a></h2>
<p>Similar to types, functions also compose but in a slightly different way. Look over the below image and then watch the video at the end (if you haven't seen it already).</p>
<p><img src="content/02-FP-Philosophical-Foundations/./assets/Composing-Functions.svg" alt="Composing Functions" /></p>
<p>Video link: <a href="https://www.youtube.com/embed/i9CU4CuHADQ?start=540">Logging a function's name each time it is called: migrating an &quot;object-oriented paradigm&quot; solution to an &quot;functional paradigm&quot; solution</a></p>
<h1><a class="header" href="#pure-vs-impure-functions" id="pure-vs-impure-functions">Pure vs Impure Functions</a></h1>
<h2><a class="header" href="#visual-overview" id="visual-overview">Visual Overview</a></h2>
<p><img src="content/02-FP-Philosophical-Foundations/./assets/Pure-and-Impure-Functions.svg" alt="Pure and Impure Functions" /></p>
<p>Functional Programming utilizes functions to create programs and focuses on separating pure functions from impure functions.</p>
<h2><a class="header" href="#general-overview" id="general-overview">General Overview</a></h2>
<h3><a class="header" href="#properties" id="properties">Properties</a></h3>
<hr>
The following table that shows a comparison of pure and impure functions is licensed under CC BY-SA 4.0:
<ul>
<li>Original Credit: Sam Halliday - <a href="https://leanpub.com/fpmortals">&quot;Functional Programming for Mortals with Scalaz&quot;</a></li>
<li>License: <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">legal code</a> &amp; <a href="https://creativecommons.org/licenses/by-sa/4.0/">legal deed</a></li>
<li>Changes made
<ul>
<li>Converted idea into a table that compares pure functions with impure functions</li>
<li>Further expand on &quot;does it interact with the real world&quot; idea with more examples from the original work</li>
</ul>
</li>
</ul>
<p>Pure functions have 3 properties, but the third (marked with <code>*</code>) is expanded to show its full weight:</p>
<table><thead><tr><th></th><th>Pure</th><th>Pure Example</th><th>Impure</th><th>Impure Example</th></tr></thead><tbody>
<tr><td>Given an input, will it always return some output?</td><td>Always <br> (Total Functions)</td><td><code>n + m</code></td><td>Sometimes <br> (Partial Functions)</td><td><code>4 / 0 == undefined</code></td></tr>
<tr><td>Given the same input, will it always return the same output?</td><td>Always <br> (Deterministic Functions)</td><td><code>1 + 1</code> always equals <code>2</code></td><td>Sometimes <br> (Non-Deterministic Functions)</td><td><code>random.nextInt()</code></td></tr>
<tr><td>*Does it interact with the real world?</td><td>Never</td><td></td><td>Sometimes</td><td><code>file.getText()</code></td></tr>
<tr><td>*Does it access or modify program state</td><td>Never</td><td><code>newList = oldList.removeElemAt(0)</code><br>Original list is copied but never modified</td><td>Sometimes</td><td><code>x++</code><br>variable <code>x</code> is incremented by one.</td></tr>
<tr><td>*Does it throw exceptions?</td><td>Never</td><td></td><td>Sometimes</td><td><code>function (e) { throw Exception(&quot;error&quot;) }</code></td></tr>
</tbody></table>
<hr>
<p>In many OO languages, pure and impure code are mixed everywhere, making it hard to understand what a function does without examining its body. In FP languages, pure and impure code are separated cleanly, making it easier to understand what the code does without looking at its implementation.</p>
<p>Programs written in an FP language usually have just one entry point via the <code>main</code> function. <code>Main</code> is an impure function that calls pure code.</p>
<p>Sometimes, FP programmers will still write impure code, but they will restrict the impure code to a small local scope to prevent any of its impurity from leaking. For example, sorting an array's contents by reusing the original array rather than copying its contents into a new array. Again, impure code is not being completely thrown out; rather, it is being clearly distinguished from pure code, so that one can understand the code faster and more easily.</p>
<h1><a class="header" href="#data-types" id="data-types">Data Types</a></h1>
<h2><a class="header" href="#principles-1" id="principles-1">Principles</a></h2>
<p>In order to abide by the principle of pure functions, FP Data Types tend to adhere to two principles:</p>
<ol>
<li>Immutable - the data does not change once created. To modify the data, one must create a copy of the original that includes the update.</li>
<li>Persistent - Rather than creating the entire structure again when updating, an update should create a new 'version' of a data structure that includes the update</li>
</ol>
<p>For example...</p>
<pre><code class="language-haskell">{-
Given a linked-list type where
  &quot;Nil&quot; is a placeholder representing the end of the list
  &quot;&quot; in &quot;left  right&quot; is a pointer that points from the
      right element to the left element
  &quot;=&quot; in &quot;list = x&quot; binds the 'x' name to the 'list' value          -}
Nil  1  2  3 = x
                                                                    {-
To change x's `2` to `4`, we would create a new 'version' of 'x'
  that includes the unchanged tail (Nil  1)
  followed by the new update ( 4) and
  a copy of the rest of the list ( 3).                            -}
Nil  1  2  3 = x
      
      4  3 = y
</code></pre>
<p>Using a more visual diagram:</p>
<p><img src="content/02-FP-Philosophical-Foundations/./assets/Immutable-Persistent-via-List.svg" alt="Immutable-Persistent-Via-List" /></p>
<pre><code class="language-haskell">-- At the end of the computation, these are true:
x == x
x /= y

-- x =  [3, 2, 1]
-- y =  [3, 4, 1]
-- index 0  1  2
(indexAt 2 x) isTheSameObjectAs (indexAt 2 y)
</code></pre>
<h2><a class="header" href="#big-o-notation" id="big-o-notation">Big O Notation</a></h2>
<p>FP data types have <code>amortized</code> costs. In other words, most of the time, using a function on a data structure will be quick, but every now and then that function will take longer. Amortized cost is the overall &quot;average&quot; cost of using some function.</p>
<p>These costs can be minimized by making data structures <code>lazy</code> or by writing impure code in a way that doesn't &quot;leak&quot; its impurity into the surrounding context.</p>
<h1><a class="header" href="#lazy-vs-strict" id="lazy-vs-strict">Lazy vs Strict</a></h1>
<p>A computation can either be lazy or strict. Before giving the below table, let's give a real-life example.</p>
<p>This is &quot;Strict evaluation.&quot; Your parent tells you to <em>immediately</em> do some chore (e.g. wash dishes, etc.). You go and do so. Sometimes, you learn that this was necessary. Other times, you learn that the dishes were already washed by someone else. Despite telling your parent that they don't need to be washed, your parent insists and overrules you. This especially annoys you on days where &quot;washing the dishes&quot; will take a long time.</p>
<p>This is &quot;Lazy evaluation.&quot; Your parent tells you to <em>remember</em> to do some chore but not to start until they tell you. On some days, they never tell you to start because the task wasn't needed after all. You love those days. On other days, they tell you to start in the morning, the afternoon, or the evening.</p>
<table><thead><tr><th>Term</th><th>Definition</th><th>Pros</th><th>Cons</th></tr></thead><tbody>
<tr><td>Strict</td><td>computes its results immediately</td><td>Expensive computations can be run at the most optimum time</td><td>Wastes CPU cycles and memory for storing/evaluating expensive computations that are unneeded/unused</td></tr>
<tr><td>Lazy</td><td>defers computation until its needed</td><td>Saves CPU cycles and memory: unneeded/unused computations are never computed</td><td>When computations will occur every time, this adds unneeded overhead</td></tr>
</tbody></table>
<p>To make something lazy, we turn it into a function. This function takes one argument (<code>Unit</code>) and returns the value we desire. This is called a <code>thunk</code>: a computation that we know how to do but have not executed yet. To run the code stored in the <code>thunk</code>, we use the phrase <code>forcing the thunk</code>.</p>
<pre><code class="language-haskell">-- Given an Int, I can return another Int
strictlyCompute :: Int -&gt; Int
strictlyCompute x = x + 4

-- otherwise known as 'thunking'
-- Given an Int, I can return a 'thunk.' When
-- this thunk is evaluated, it will return an Int.
lazilyCompute :: Int -&gt; (Unit -&gt; Int)
lazilyCompute x = (\unitValue__neverUsed -&gt; x + 4)

forceThunk :: (Unit -&gt; Int) -&gt; Int
forceThunk thunk = thunk unit

-- somewhere in our code
thunk = lazilyCompute 5

-- somewhere else in our code, when we finally need it
result = forceThunk thunk
</code></pre>
<h2><a class="header" href="#other-resources" id="other-resources">Other Resources</a></h2>
<ul>
<li>This resource is not necessary for you to read it to understand and use PureScript. However, it might satisfy those who are curious. It uses the Lisp language in its examples, so the code might be difficult to understand. Regardless, the book <strong>Structure and Interpretation of Computer Programs (SICP)</strong> (see <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">this</a> or <a href="https://sarabander.github.io/sicp/">that</a>) has <a href="https://sarabander.github.io/sicp/html/4_002e2.xhtml">a chapter on lazy evaluation and thunks</a>.</li>
</ul>
<h1><a class="header" href="#looping-via-recursion" id="looping-via-recursion">Looping via Recursion</a></h1>
<p>In most OO languages, one writes loops using <code>while</code> and <code>for</code>. Looping in that matter makes it very easy to introduce impure code. So, in FP languages, one writes loops using recursion, pattern-matching, and tail-call optimization. The rest of this file will compare OO code to its FP counterpart</p>
<h2><a class="header" href="#for-i-until-condition-do-computation-and-then-increment-i" id="for-i-until-condition-do-computation-and-then-increment-i">For <code>i</code> until <code>condition</code> do <code>computation</code> and then increment <code>i</code></a></h2>
<pre><code class="language-javascript">// factorial
var count = 5;
var result = 1;
for (var i = 2; i &lt; count; i++) {
    result = result * i
}
</code></pre>
<pre><code class="language-haskell">-- This is a stack-unsafe function (explained and improved next)
factorial :: Int -&gt; Int
factorial 1 = 1                       -- base case
factorial x = x * (factorial (x - 1)) -- recursive case

factorial 3
-- reduces via a graph reduction...
3 * (factorial (3 - 1))
3 * (factorial 2)
3 * 2 * (factorial (2 - 1))
3 * 2 * (factorial 1)
3 * 2 * 1
6 * 1
6
</code></pre>
<h3><a class="header" href="#stack-safe" id="stack-safe">Stack-Safe</a></h3>
<p>The above Purescript example illustrates a problem that comes with writing loops this way: stack overflows. Thus, when one says &quot;this function is <code>stack-safe</code>&quot;, they mean that calling the function will not risk the possibility of a stack overflow runtime error being produced. One usually prevents this risk via tail-call optimization (which usually converts the recursive loop back into an OO loop) or trampolining (when tail-call optimization isn't possible)</p>
<p>Thus, one will usually write recursive functions in this manner. Rather than using recursion to calculate the value by creating a 'stack' of <code>*</code> operations (as done above), one will pass into the function an additional argument that acts as the accumulated value. The necessary state change / calculation is done and its result is passed in as the new accumulated value in the next iteration of the recursive function call:</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n = factorial' n 1

factorial' :: StartingInt -&gt; AccumulatedInt -&gt; AccumulatedInt
factorial' 1 finalResult = finalResult
factorial' amountRemaining accumulatedSoFar =                             {-
  -- This is the general idea being done in the single line of code
  -- after this comment
  let
    oneLess = amountRemaining - 1
    nextAccumulatedValue = accumulatedSoFar * amountRemaining
  in
    factorial' oneLess nextAccumulatedValue                               -}
  factorial' (amountRemaining - 1) (amountRemaining * accumulatedSoFar)

factorial 4
-- reduces via a graph reduction...
factorial' 4 1
factorial' 3 4
factorial' 2 12
factorial' 1 24
24
</code></pre>
<h2><a class="header" href="#for--break-if" id="for--break-if">For ... Break If</a></h2>
<pre><code class="language-javascript">// findFirst
var findFirst = (array, condition) =&gt; {
  var length = list.length();
  for (var i = 0; i &lt; length; i++) {
      var value = list[i]
      if (condition(value)) {
        return value;
      }
  }
  return null;
}
findFirst([0, 1, 2], (i) =&gt; i == 1);
</code></pre>
<pre><code class="language-haskell">-- linked list
data List a
  = Nil             -- end of the list
  | Cons a (List a) -- head of a linked list &amp; rest of list

data Maybe a
  = Nothing   -- could not find a value of type A
  | Just a    -- found a value of type A

findFirst :: forall a. List a -&gt; (a -&gt; Boolean) -&gt; Maybe a
findFirst list condition = findFirst' list condition Nothing

findFirst' :: forall a. List a -&gt; (a -&gt; Boolean) -&gt; Maybe a -&gt; Maybe a
findFirst' Nil condition notFound = notFound
findFirst' (Cons head tail) condition theA@(Just alreadyFound) =
  findFirst' tail condition theA
findFirst' (Cons head tail) condition Nothing =
  let foundOrNot = if (condition head) then (Just head) else Nothing
  in findFirst' tail condition foundOrNot

findFirst (Cons 0 (Cons 1 (Cons 2 Nil))) (\el -&gt; el == 1)
-- reduces via a graph reduction...
findFirst' (Cons 0 (Cons 1 (Cons 2 Nil))) (\el -&gt; el == 1) Nothing
findFirst'         (Cons 1 (Cons 2 Nil))  (\el -&gt; el == 1) Nothing
findFirst'                 (Cons 2 Nil)   (\el -&gt; el == 1) (Just 1)
findFirst'                         Nil    (\el -&gt; el == 1) (Just 1)
Just 1
</code></pre>
<h3><a class="header" href="#short-circuiting" id="short-circuiting">Short-Circuiting</a></h3>
<p>The above Purescript example illustrates another problem with writing loops this way: <code>short-circuiting</code>. There are times when we wish to break out of a recursion-based loop early, such as when we have found the first element of a collection. In the above example, the function does not short-circuit, so it continues to iterate through the list even after it has found the element, leading to wasted CPU time and work.</p>
<p>To make the function above short-circuit, we would rewrite the function to this:</p>
<pre><code class="language-haskell">-- linked list
data List a
  = Nil             -- end of the list
  | Cons a (List a) -- head of a linked list &amp; rest of list

data Maybe a
  = Nothing   -- could not find a value of type A
  | Just a    -- found a value of type A

findFirst :: forall a. List a -&gt; (a -&gt; Boolean) -&gt; Maybe a
findFirst Nil condition = Nothing
findFirst (Cons head tail) condition =
  if (condition head)
  then Just head
  else findFirst' tail condition

findFirst (Cons 0 (Cons 1 (Cons 2 Nil))) (\el -&gt; el == 1)
-- reduces via a graph reduction...
findFirst         (Cons 1 (Cons 2 Nil))  (\el -&gt; el == 1)
Just 1
</code></pre>
<h2><a class="header" href="#other-loops" id="other-loops">Other Loops</a></h2>
<p>The following Purescript examples are very <em>crude</em> ways of mimicking the following loops. More appropriate examples would require explaining and using type classes like <code>Foldable</code> and <code>Monad</code> (intermediate FP concepts). Thus, take these examples with a grain of salt.</p>
<h3><a class="header" href="#while" id="while">While</a></h3>
<pre><code class="language-javascript">while (condition == true) {
  if (shouldStop()) {
    condition = false
  } else {
    doSomething();
  }
}
</code></pre>
<pre><code class="language-haskell">data Unit = Unit

whileLoop :: Boolean -&gt; (Unit -&gt; Boolean) -&gt; (Unit -&gt; Unit) -&gt; Unit
whileLoop false _ _ = -- body
whileLoop true shouldStop doSomething =
  -- `doSomething unit` is called in here somewhere
  -- at the end of the function's body, it will call
  whileLoop (shouldStop unit) shouldStop doSomething
</code></pre>
<h3><a class="header" href="#for-value-in-collection" id="for-value-in-collection">For <code>value</code> in <code>collection</code></a></h3>
<pre><code class="language-javascript">// length
var count = 0;
for (value in list) {
  count += 1;
}
</code></pre>
<pre><code class="language-haskell">data List a
  = Nil
  | Cons a (List a)

length :: forall a. List a -&gt; Int -&gt; Int
length Nil totalCount = totalCount
length (Cons head tail) currentCount =
  length tail (currentCount  + 1)
</code></pre>
<h1><a class="header" href="#type-classes" id="type-classes">Type Classes</a></h1>
<h2><a class="header" href="#what-problem-do-type-classes-solve" id="what-problem-do-type-classes-solve">What Problem Do Type Classes Solve?</a></h2>
<p>Their primary use is to make writing some code more convenient / less boilerplatey. Rather than writing the same code 25 different times where it differs in only one way each time, we can write code once and &quot;parameterize it&quot; in 25+ different ways.</p>
<p>To see a bottom-up explanation of this idea, read through the bullet points below and then watch the video.</p>
<ul>
<li>This video is a recording of a presentation given by Nathan Faubion, a core contributor to PureScript.</li>
<li>This video finishes explaining what type classes are around 22:54.</li>
<li>The parts that follow are more advanced concepts. They explain how to make &quot;real world code&quot; easily testable via type classes and interpreters. You might not understand those explanations until you are more familiar with PureScript syntax.</li>
<li>The presentation ends at 1:03:58. Nate starts answering people's questions after that.</li>
<li>Nate's answers to various questions ends at 1:13:12 and the rest of the video are people talking about various PureScript things.</li>
<li>While Nate explains that type classe enable &quot;code reuse,&quot; one could use an approach called &quot;scrap your type classes&quot; (SYTC) to accomplish that goal. SYTC will be covered later in this file.</li>
</ul>
<p>Video: <a href="https://youtu.be/GlUcCPmH8wI?t=24">Code Reuse in PureScript: Functions, Type Classes, and Interpreters</a> (actual video title on YouTube: &quot;PS Unscripted - Code Reuse in PS: Fns, Classes, and Interpreters&quot;)</p>
<h2><a class="header" href="#where-do-type-classes-come-from" id="where-do-type-classes-come-from">Where Do Type Classes Come From?</a></h2>
<p>Type classes are usually &quot;encodings&quot; of various concepts from mathematics.</p>
<p>Type classes make developers productive. They enable programmers...
- to write 1 line of code that is the equivalent of writing 100s of lines of code.
- to define complicated control flows that highlight the important parts and minimize the irrelevant boilerplatey parts (e.g. nested &quot;if then else&quot; statements)
- to use (in general) 5 <a href="https://www.youtube.com/embed/hIZxTQP1ifo?start=1225&amp;end=1334">&quot;dumb reusable data types&quot;</a> to solve most of our problems:
- Maybe - a box that is either empty or has a value.
- Either - a sum type: either has a Left value or a Right value
- Tuple - a product type: has both an A value and a B value
- List - self-explanatory
- Tree - self-explanatory</p>
<h2><a class="header" href="#type-classes-as-encodings-of-mathematical-concepts" id="type-classes-as-encodings-of-mathematical-concepts">Type Classes as Encodings of Mathematical Concepts</a></h2>
<p>Type classes often encode ideas that are true regardless of what we call them (i.e. &quot;necessary&quot; concepts), but functional programmers will refer to them via jargon (i.e &quot;arbitrary&quot; names like <code>Functor</code>). (For more context on the usage of &quot;necessary&quot; and &quot;arbitrary&quot; as terms, see <a href="https://flm-journal.org/Articles/2D02A71022192F96A5A92F55B04AB0.pdf">Arbitrary and Necessary Part 1: a Way of Viewing the Mathematics Curriculum</a>).</p>
<p>Putting it differently, if <code>Some type</code> can implement some <code>function(s)/value(s) with a specified type signature</code> in such a way that the implementation adheres to <code>specific laws</code>, one can say it <strong>has</strong> an instance of the given type class. Some types cannot satisfy a given type class' conditions; others can satisfy them in only one way; and still others can satisfy them in multiple ways. Thus, one does not say &quot;<code>Type X</code> <strong>is</strong> an instance of &lt;some type class&gt;.&quot; Rather, one says &quot;<code>Type X</code> <strong>has</strong> an instance of &lt;some type class&gt;.&quot; To see this concept in a clearer way and using pictures, see https://www.youtube.com/watch?v=iJ7V1KXJpsE</p>
<p>Thus, type classes abstract general concepts into an &quot;interface&quot; that can be implemented by various data types. They are usually an encapsulation of 2-3 things:</p>
<ol>
<li>(Always) The definition of type signatures for one or more functions/values.
<ul>
<li>Functions may be put into infix notation using symbolic aliases (e.g. <code>&lt;$&gt;</code>) to make it easier to write them.</li>
</ul>
</li>
<li>(Almost Always) The laws by which implementations of a type class must abide.
<ul>
<li>These laws guarantee certain properties, increasing developers' confidence that their code works as expected.</li>
<li>They also help one to know how to refactor code. Given <code>left-hand-side == right-hand-side</code>, evaluating code on the left may be more expensive (memory, time, IO, etc.) than the code on the right.</li>
<li><strong>Laws cannot be enforced by the compiler.</strong> For example, one could define a type class' instance for some type which satisfies the type signature. However, the implementation of that instance might not satisfy the type class' law(s). The compiler can verify that the type signature is correct, but not the implementation. Thus, one will need to insure an instance's lawfulness via tests, (usually by using a testing library called <code>quickcheck-laws</code>, which is covered later in this repo)</li>
</ul>
</li>
<li>(Frequently) The additional functions/values that can be derived once one implements the type class.
<ul>
<li>Most of the power/flexibility of type classes come from the combination of the main functions/values implemented in a type class' definition and these derived functions. When a type class extends another, the type class' power increases, its flexibility decreases, and its costs increase.</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Here are some examples that demonstrate the combination of the 2-3 elements from above:</p>
<ul>
<li>The <code>Eq</code> type class specifies a type signature for a function called <code>eq</code>/<code>==</code> and <code>notEq</code>/<code>/=</code>, and laws for the two (e.g. if <code>a == b</code> and <code>b == c</code>, then <code>a == c</code>), but there are not any derived functions.</li>
<li>The <code>Ord</code> type class is similar to <code>Eq</code>, but it does have derived functions.</li>
<li>The <code>Functor</code> type class (explained in more detail later) has all three.</li>
</ul>
<h2><a class="header" href="#similarities-and-dual-relationships-among-type-classes" id="similarities-and-dual-relationships-among-type-classes">Similarities and Dual Relationships Among Type Classes</a></h2>
<p>Some type classes have a corresponding &quot;dual.&quot; While there are better ways to explain duals, the basic idea is that the &quot;direction&quot; of the function's arrow gets flipped. When this happens, we usually prefix them with &quot;Co&quot;. For example, if we have a type class called <code>Monad</code>, the dual of it is called <code>Comonad</code>. If <code>Monad</code> has laws <code>A</code> and <code>B</code>, then it's likely that <code>Comonad</code> will have laws <code>A'</code> and <code>B'</code>, which are &quot;flipped&quot; version of <code>A</code> and <code>B</code>.</p>
<p>For example, a function like <code>toB</code> would have its arrow flipped to produce <code>toA</code>::</p>
<pre><code class="language-haskell">-- original
toB :: a -&gt; b
toB = -- function's implementation
                                                                              {-
-- 1. Drop the implementation
toB :: a &lt;- b
toB =

-- 2. Flip the arrow
toB :: a &lt;- b
toB =

-- 3. Reorder the arguments so that arrow is pointing to the right:
toB :: b -&gt; a
toB =

-- 4. Rename the function
toA :: b -&gt; a
toA =                                                                         -}

-- Dual version
toA :: b -&gt; a
toA = -- function's implementation
</code></pre>
<h1><a class="header" href="#equational-reasoning" id="equational-reasoning">Equational Reasoning</a></h1>
<p>Functions in FP languages often work like equations: the left-hand side can be replaced by the right-hand side. We'll cover this idea more in the graph reduction section. This idea enables a developer to solve a problem using a simple but not performant solution that can be easily refactored to a much more performant version of the solution. We'll cover this in the &quot;Optimizing Functions&quot; section.</p>
<h2><a class="header" href="#graph-reduction-running-a-function" id="graph-reduction-running-a-function">Graph Reduction: Running a Function</a></h2>
<p>In source code, we can describe the various parts of a function based on which side of the <code>=</code> character the content appears:</p>
<ul>
<li>Left-Hand Side (LHS): the function name and all of its arguments</li>
<li>Right-Hand Side (RHS): the body or implementation of the function</li>
</ul>
<pre><code class="language-haskell">|         LHS         |    |     RHS     |
functionName int1 int2   =   int1 + int2
</code></pre>
<p>When using pure functions, one can replace the LHS with the RHS, and the program will still work the same. This concept is known as <strong>referential transparency</strong>:</p>
<pre><code class="language-haskell">functionName 4 3
-- replace LHS with RHS
4 + 3
-- reduce into final form
7
-- Calling `function 4 3` could be removed and replaced
-- with `7` and the program would work the same

-- Similarly, the below function (a longer form syntactically) and its arguments
-- could be replaced with `6` and the program would work fine.
(\arg1 arg2 arg3 -&gt; arg1 + arg2 + arg3) 1 2 3
-- replace LHS with RHS
(\     arg2 arg3 -&gt;    1 + arg2 + arg3)   2 3
(\          arg3 -&gt;    1 +    2 + arg3)     3
(\               -&gt;    1 +    2 +    3)
                       1 +    2 +    3
                       1 +    5
                       6
</code></pre>
<p>Although the above examples are very simple functions, imagine if one's entire program was one function that exhibited this behavior. If so, it would be very easy to understand and reason one's way through such a program.</p>
<h2><a class="header" href="#optimizing-functions-from-simplicity-to-performant" id="optimizing-functions-from-simplicity-to-performant">Optimizing Functions: From Simplicity to Performant</a></h2>
<p>This section summarizes the main ideas explained in <strong>Algorithm Design with Haskell</strong> (<a href="https://www.cambridge.org/us/academic/subjects/computer-science/algorithmics-complexity-computer-algebra-and-computational-g/algorithm-design-haskell?format=HB">Cambridge</a>, <a href="https://www.amazon.com/Algorithm-Design-Haskell-Richard-Bird/dp/1108491618">Amazon</a>).</p>
<p>Above, we showed that functions are &quot;run&quot; by using graph reduction: the left-hand side is replaced with the right-hand side. However, this idea also applies when we refactor code, enabling the following developer workflow:</p>
<ol>
<li>Solve a programming problem by composing multiple high-level functions together. Initially, this version of the solution will not be performant.</li>
<li>&quot;Decompose&quot; the high-level functions by replacing their call site (i.e. left-hand side) with their implementations (i.e. right-hand side)</li>
<li>Use laws to refactor how those implementations compose to reduce unneeded work.</li>
</ol>
<p>Typically, the 'laws' above are from type classes. When we see that a function &quot;decomposes&quot; to <code>map function1 (map function 2)</code>, which iterates through some collection twice, we can rewrite it to <code>map (\arg -&gt; function1 (function2 arg))</code>, which iterates through some collection once but still produces the same output.</p>
<p>Following this workflow makes it easier to solve all programming problems. In particular, this workflow helps when writing a greedy algorithm or a dynamic programming algorithm.</p>
<p>Let's provide two other examples of this idea. To keep things simple for those who don't understand PureScript's syntax, we'll not use laws to guide refactoring.</p>
<h3><a class="header" href="#example-1" id="example-1">Example 1</a></h3>
<p>As a very simple example, consider the following programming problem:</p>
<blockquote>
<p>Given an array of integers, <code>arr</code>, that will have 0 - 20 elements, define a function, <code>countTwoFourSum</code>, that calculates how often a 2 or 4 appears in the array (i.e. its count) and sums the resulting counts together. For example</p>
<blockquote>
<p>countTwoFourSum([1, 2, 3, 4]) == 2
countTwoFourSum([1, 3, 5, 7]) == 0
countTwoFourSum([2, 2, 3, 6]) == 2
countTwoFourSum([2, 2, 3, 4]) == 3</p>
</blockquote>
</blockquote>
<p>Using Step 1 above, the simplest solution would be to write something like this:</p>
<pre><code class="language-javascript">var countTwoFourSum = function(arr) {
  return count(arr, 2) + count(arr, 4);
};
var count = function (arr, value) {
  var accumulatedValue = 0;
  for (var i = 0; i &lt; arr.length; i++) {
    var nextElem = arr[i];
    if (nextElem == value) {
      accumulatedValue = accumulatedValue + 1;
    }
  }
  return accumulatedValue;
};
</code></pre>
<p>Translating that to PureScript, we would write:</p>
<pre><code class="language-purescript">countTwoFourSum :: Array Int -&gt; Int
countTwoFourSum arr =
  (count arr 2) + (count arr 4)

count :: Array Int -&gt; Int -&gt; Int
count arr value = foldl countIfValue initialAccumulatedValue arr
  where
  initialAccumulatedValue = 0

  countIfValue accumulatedValue nextElem =
    if nextElem == value then accumulatedValue + 1 else accumulatedValue
</code></pre>
<p>While it is easy to think of the solution to this code by writing it in this way, it's not performant because we loop through the array twice.</p>
<p>In step 2, we can replace the original function, <code>count</code>, with its implementation.</p>
<pre><code class="language-purescript">countTwoFourSum :: Array Int -&gt; Int
countTwoFourSum arr =
  (foldl countIfTwo initialAccumulatedValue arr) +
  (foldl countIfFour initialAccumulatedValue arr)
  where
  initialAccumulatedValue = 0

  countIfTwo accumulatedValue nextElem =
    if nextElem == 2 then accumulatedValue + 1 else accumulatedValue

  countIfFour accumulatedValue nextElem =
    if nextElem == 4 then accumulatedValue + 1 else accumulatedValue
</code></pre>
<p>In step 3, we refactor the resulting computation to be more performant. Below, we iterate through the array once rather than twice by using only one <code>foldl</code>.</p>
<pre><code class="language-purescript">countTwoFourSum :: Array Int -&gt; Int
countTwoFourSum arr =
  let finalCount = foldl countIfValues initialAccumulatedValue arr
  in finalCount.twoCount + finalCount.fourCount
  where
  initialAccumulatedValue = {twoCount: 0, fourCount: 0}

  countIfValues {twoCount, fourCount} nextElem =
    { twoCount: if nextElem == 2 then twoCount + 1 else twoCount
    , fourCount: if nextElem == 4 then fourCount + 1 else fourCount
    }
</code></pre>
<h3><a class="header" href="#example-2" id="example-2">Example 2</a></h3>
<p>The above example illustrates this workflow but isn't the most impressive example. Here's a slightly more complex example. Let's say a programmer is reading through a description of a problem and its desired output. Piece by piece, she types out the below code as a solution to each part of the problem:</p>
<pre><code class="language-purescript">map fromString stringArray -- 1. convert each string element into
                           --       an integer (if possible)
 # catMaybes               -- 2. remove elements where the string wasn't an integer
 # map (_ + 1)             -- 3. add one to each integer
 # sum                     -- 4. sum all the resulting integers into a value
</code></pre>
<p>While the above code solves the problem, it is not performant. It iterates through an array multiple times and creates multiple intermediate arrays. By using equational reasoning (not shown below), we can speed this up to a single iteration:</p>
<pre><code class="language-purescript">foldl f init stringArray
where
  init = 0
  f acc next =
    case fromString next of
      Nothing -&gt; acc
      Just i -&gt; acc + i + 1
</code></pre>
<p>Crucially, our first focus was on writing a correct solution and then on making it performant.</p>
<h1><a class="header" href="#fp---the-big-picture" id="fp---the-big-picture">FP - The Big Picture</a></h1>
<p>Here's a sneak peek as to what the design process for writing FP programs looks like. <strong>Note: I assume you're already familiar with pure and impure functions.</strong> If not, see <code>FP Philosophical Foundations/Pure-vs-Impure-Functions.md</code>:</p>
<p><img src="content/02-FP-Philosophical-Foundations/./assets/FP--Big-Picture.svg" alt="FP--Big Picture" /></p>
<h1><a class="header" href="#build-tools" id="build-tools">Build Tools</a></h1>
<p>This folder accomplishes the following:</p>
<ul>
<li>Explain the various tools used throughout the ecosystem and their usages/differences:
<ul>
<li>Document the differences between <code>Bower</code> and <code>Spago</code> dependency managers</li>
<li>Document the difference between <code>Pulp</code> and <code>Spago</code> build tools</li>
</ul>
</li>
<li>Document the CLI options for the most popular tools (e.g. purs, pulp, spago, etc.)</li>
<li>Document a typical workflow from project start to finish (creation, fast-feedback development, initial publishing, 'bump' publishing)</li>
</ul>
<h2><a class="header" href="#history-how-we-got-here" id="history-how-we-got-here">History: How We Got Here</a></h2>
<p>The following explanation does not cover all the tools used in PureScript's ecosystem. However it provides context for later files. In short, <code>spago</code> is both the official dependency manager and build tool. <code>bower</code> can be thought of as a deprecated dependency manager; the community is in the process of building a registry that will replace the Bower registry since it no longer accepts uploads. <code>pulp</code> is a build tool that uses <code>bower</code>; its usage will become more common again once the registry is built.</p>
<h3><a class="header" href="#phase-1-initial-tooling" id="phase-1-initial-tooling">Phase 1: Initial Tooling</a></h3>
<p>PureScript's compiler was originally called <code>psc</code> (<strong>P</strong>ure<strong>S</strong>cript <strong>C</strong>ompiler) before later being renamed to <code>purs</code>. (We'll see this <code>psc</code> name reappear elsewhere in a related project).</p>
<p>PureScript did not use <code>npm</code> as a dependency manager because of an issue related to transitive dependencies. Thus, they used <code>bower</code> because it fit their goals/requirements better. (All of this is covered more in the <code>Dependency Managers/Bower Explained.md</code> file).</p>
<p>Bodil Stokke (with later contributions from Harry Garrood) later wrote a tool called <code>pulp</code> that worked with <code>bower</code> and <code>purs</code> to provide a user-friendly developer workflow:</p>
<ul>
<li>download your dependencies</li>
<li>compile, build, and test your project</li>
<li>publish libraries and their docs</li>
<li>easily bump the project's version</li>
</ul>
<h3><a class="header" href="#phase-2-the-psc-package-experiment" id="phase-2-the-psc-package-experiment">Phase 2: The <code>psc-package</code> Experiment</a></h3>
<p><code>Bower</code> worked fine, but there were a few user-interface issues that made it difficult to use, especially when a new PureScript release was made that included breaking changes.</p>
<p>As a result, <code>psc-package</code> was developed as an experimental dependency manager. It solved some of the problems that <code>bower</code> faced. <code>pulp</code> later supported <code>psc-package</code>, so that one could benefit from the simple developer workflow.</p>
<p>However, <code>psc-package</code> encountered its own problems, too. People could not easily create and modify something called a &quot;local package set&quot; (a term that is explained later in the <code>Spago-Explained.md</code> file).</p>
<p>To resolve these problems, Justin Woo started a project called <code>spacchetti</code> (he likes to name his projects via food puns), which made it much easier to create and modify a &quot;local package set.&quot;</p>
<p>See the below image to visualize this:</p>
<p><img src="content/03-Build-Tools/./assets/Build-Tool-Relationships--no-Spago.svg" alt="Build Tool Relationships - No Spago &quot;Build Tool Relationships&quot;" /></p>
<h3><a class="header" href="#phase-3-improving-the-psc-package-developer-workflow-via-spago" id="phase-3-improving-the-psc-package-developer-workflow-via-spago">Phase 3: Improving the <code>psc-package</code> Developer Workflow via <code>Spago</code></a></h3>
<p>From the above image, one should infer that using <code>pulp</code> and <code>bower</code> was overall easier to use and explain. Thus, Justin Woo and Fabrizo Ferrai started a project called <code>spago</code>. <code>spago</code> evolved out of <code>spacchetti</code> and reimplemented parts of <code>psc-package</code> into one program with a seamless developer workflow. While <code>psc-package</code> can still be used, it's better to use <code>spago</code>.</p>
<p>The below image summarizes the current state:</p>
<p><img src="content/03-Build-Tools/./assets/Build-Tool-Relationships--With-Spago.svg" alt="Build Tool Relationships &quot;Build Tool Relationships&quot;" /></p>
<h3><a class="header" href="#phase-4-spago-becomes-mainstream-while-psc-package-is-less-used" id="phase-4-spago-becomes-mainstream-while-psc-package-is-less-used">Phase 4: <code>Spago</code> becomes mainstream while <code>psc-package</code> is less used</a></h3>
<p>Spago dropped support for <code>psc-package</code> commands in the <code>v0.11.0</code> release. <code>psc-package</code> is still usable and is more or less feature-complete. However, no further work on it will be done. Rather, Spago has become the main dependency manager when utilizing package-sets.</p>
<p>The community is now split between <code>pulp</code> + <code>bower</code> workflows and <code>spago</code> workflows. One must still use <code>pulp</code> + <code>bower</code> if they want to do the following:</p>
<ul>
<li>publish their library's docs to Pursuit</li>
<li>include their library in a package set, so <code>spago</code> users can use it</li>
</ul>
<h3><a class="header" href="#phase-5-the-need-for-a-purescript-registry-bower-registry-no-longer-accepts-new-uploads" id="phase-5-the-need-for-a-purescript-registry-bower-registry-no-longer-accepts-new-uploads">Phase 5: The need for a PureScript registry (Bower registry no longer accepts new uploads)</a></h3>
<p>The Bower registry stopped accepting new uploads. The community quickly updated their tooling to workaround how libraries are published and installed. However, it was clear that PureScript now needed to create a registry.</p>
<p>Fabrizio Ferrai led the effort to build this registry with significant input from Harry Garrood. The registry is not yet complete, so the community is in this in-between stage.</p>
<p>Regardless, the following is still true:</p>
<ul>
<li>most people are now using <code>spago</code></li>
<li>the <code>pulp</code> + <code>bower</code> workflow is still needed to publish a library, but it works differently now.
<ul>
<li>See <a href="https://discourse.purescript.org/t/up-to-date-instructions-for-publishing-new-packages/1953">these instructions for how to use <code>bower</code> to publish a library in this in-between context</a></li>
<li>See the <code>Dependency Managers/Bower Explained</code> file for clarification on how to install packages as dependencies if one is using <code>bower</code></li>
</ul>
</li>
<li>Thomas has written a <a href="https://discourse.purescript.org/t/recommended-tooling-for-purescript-applications-in-2019/948">Recommended Tooling for PureScript Applications</a> post.</li>
</ul>
<p>See <a href="https://discourse.purescript.org/t/the-bower-registry-is-no-longer-accepting-package-submissions/1103/">The <code>bower</code> registry is no longer accepting package submissions</a> for more context.</p>
<h2><a class="header" href="#overview-of-tools" id="overview-of-tools">Overview of Tools</a></h2>
<table><thead><tr><th>Name</th><th>Type/Usage</th><th>Comments</th><th>URL</th></tr></thead><tbody>
<tr><td>purs</td><td>PureScript Compiler</td><td>Used to be called <code>psc</code></td><td>--</td></tr>
<tr><td>spago</td><td>Build Tool</td><td>Front-end to <code>purs</code> and <code>package-set</code>-based projects</td><td>https://github.com/purescript/spago</td></tr>
<tr><td>pulp</td><td>Build Tool</td><td>Front-end to <code>purs</code>. Builds &amp; publishes projects</td><td>https://github.com/purescript-contrib/pulp</td></tr>
<tr><td>bower</td><td>Dependency Manager (being deprecated)</td><td>--</td><td>https://bower.io/</td></tr>
<tr><td>psa</td><td>Pretty, flexible error/warning frontend for <code>purs</code></td><td>--</td><td>https://github.com/natefaubion/purescript-psa</td></tr>
<tr><td>pscid</td><td><code>pulp --watch build</code> on steroids</td><td>Seems to be a more recent version of <code>psc-pane</code> (see below) and uses <code>psa</code></td><td>https://github.com/kRITZCREEK/pscid</td></tr>
<tr><td>psvm-js</td><td>PureScript Version Manager</td><td>--</td><td>https://github.com/ThomasCrevoisier/psvm-js</td></tr>
</tbody></table>
<p>The following seem to be deprecated or no longer used:</p>
<table><thead><tr><th>Name</th><th>Type/Usage</th><th>Comments</th><th>URL</th></tr></thead><tbody>
<tr><td>psc-package</td><td>Dependency Manager</td><td>--</td><td>https://github.com/purescript/psc-package</td></tr>
<tr><td>psc-pane</td><td>Simplistic auto-reloading REPL-based IDE</td><td>No longer used? Last updated 1 year ago...</td><td>https://github.com/anttih/psc-pane</td></tr>
<tr><td>gulp-purescript</td><td>Gulp-based Build Tool</td><td>No longer used? Last updated 1 year ago...</td><td>https://github.com/purescript-contrib/gulp-purescript</td></tr>
<tr><td>Purify</td><td>--</td><td>Deprecated in light of psc-package</td><td>--</td></tr>
</tbody></table>
<p>For this repo, we will be using <code>spago</code> for our build tool and dependency manager.</p>
<h1><a class="header" href="#dependency-managers" id="dependency-managers">Dependency Managers</a></h1>
<p>There are two solutions to dependency management where each has a different 'target audience' per say:</p>
<ol>
<li>Bower (library developers)</li>
<li>Spago (application developers)</li>
</ol>
<p>The community needs both solutions for reasons that will be explained later.</p>
<p>Each one will be further explained in its own file. However, one can refer to each with a &quot;crude name&quot; that summarizes them:</p>
<ul>
<li>Typical package manager (Bower)</li>
<li>Glorified <code>git clone</code> tool (Spago)</li>
</ul>
<h2><a class="header" href="#dependency-managers-compared" id="dependency-managers-compared">Dependency Managers Compared</a></h2>
<p>This side-by-side comparison should be thought of as an &quot;apples to oranges&quot; comparison.</p>
<table><thead><tr><th></th><th>Bower</th><th>Spago</th></tr></thead><tbody>
<tr><td>Ideal User</td><td><ul><li>Library Developers</li><li>People exploring the language/ecosystem</li></ol></td><td><ul><li>Application Developers</li><li>People learning the language via a CI-proven learning material</li></ul></td></tr>
<tr><td>Official/Unofficial</td><td>Official<br>(parts of the PureScript compiler depend on it)</td><td>Unofficial</td></tr>
<tr><td>Trajectory</td><td>Moving away?</td><td>Moving towards?</td></tr>
<tr><td>Design Goals</td><td>?</td><td><a href="https://github.com/purescript/psc-package#design-goals">See this summary of a project that later &quot;evolved&quot; into Spago</a></td></tr>
<tr><td>Pros</td><td><ul><li><strong>Bower is required for one to publish a library's docs to <a href="https://pursuit.purescript.org/">Pursuit</a></strong></li><li>Bower caches its dependencies, so you can download a version of a package only once and use it everywhere on your system</li><li>It's the &quot;official&quot; dependency manager for Purescript</li></ul></td><td><ul><li><strong>One never experiences the aforementioned &quot;transitive dependency conflicts&quot;</strong></li><li>Uses Git to work, which is usually already installed on all systems</li><li>Reliably produces reproducible Purescript dependencies</li><li>Reduces verbosity somewhat by omitting the <code>purescript-</code> prefix on PureScript packages</li></ul></td></tr>
<tr><td>Cons</td><td><ul><li><strong>When a recent compiler release has been made, one will encounter the 'transitive dependency' issue above quite frequently until all the libraries in the ecosystem are updated to the new release. Figuring out which version of a package works with another wastes a lot of time.</strong></li><li>Uses node to work, which may not be installed on all systems</li><li>Doesn't always produce reproducible dependencies due to its caching feature.</li></ul></td><td><ul><li><strong>One cannot publish a library's docs to Pursuit.</strong></li><li>Uses more storage space due to duplicating code when one has multiple projects across their system.</li></ul></td></tr>
</tbody></table>
<h1><a class="header" href="#bower-explained" id="bower-explained">Bower Explained</a></h1>
<p><strong>Note:</strong> The <code>Bower</code> registry has been deprecated. The PureScript community is in the process of creating a registry. When that is done, we will stop using <code>bower</code> entirely. In the meantime, you must still use <code>bower</code> + <code>pulp</code> to publish libraries' docs to Pursuit. One can still use <code>bower</code> as a dependency manager, however, one will need to depend on other libraries using the full repo url in the <code>bower.json</code> file:</p>
<pre><code class="language-diff">&quot;dependencies&quot;: {
-    &quot;purescript-some-library&quot;: &quot;^0.1.0&quot;
+    &quot;purescript-some-library&quot;:&quot;https://github.com/githubUser/purescript-some-library#my-branch&quot;
}
</code></pre>
<h2><a class="header" href="#what-is-it" id="what-is-it">What is it?</a></h2>
<p>A typical dependency manager that downloads dependencies from a centralized repository (i.e. Bower Registry) or GitHub.</p>
<p><img src="content/03-Build-Tools/01-Dependency-Managers/./assets/bower-flowchart.svg" alt="Bower-flowchart" /></p>
<h2><a class="header" href="#why-use-it" id="why-use-it">Why Use It?</a></h2>
<p>When developing a library, one needs to refer to specific versions of dependencies that do not change over time.</p>
<p>If one uses <code>spago</code>, they can modify the &quot;binary&quot; of the dependency without changing the version to which it refers. For application developers, this can be desirable. Not so for library developers.</p>
<p>Some people prefer <code>bower</code> over <code>spago</code> while others do not. Learn about both and make your decision.</p>
<h3><a class="header" href="#why-doesnt-purescript-use-npm" id="why-doesnt-purescript-use-npm">Why doesn't Purescript use <code>npm</code>?</a></h3>
<p>The following provides a much shorter explanation of <a href="https://harry.garrood.me/blog/purescript-why-bower/">Why the PureScript Community Uses Bower</a></p>
<p>Short answer:</p>
<ul>
<li>Because NPM doesn't produce an error when multiple versions of the same transitive dependency are used.</li>
</ul>
<p>Long answer:</p>
<ul>
<li>When package <code>child1</code> requires <code>parent v1.0.0</code> and package <code>child2</code> requires <code>parent v2.0.0</code>, NPM, will &quot;nest&quot; the packages, so that the code will compile.</li>
<li>Should one or both packages export something that exposes <code>parent</code> and our code uses it, this will produce a runtime error, either because some API doesn't exist (e.g. one version changed/removed some API) or because a pattern match didn't work (e.g. an <code>instanceOf</code> check failed due to seeing different types defined in the <code>parent</code> package)</li>
<li>Bower uses &quot;flat&quot; dependencies, so it will notify you that such an issue exists by asking you to choose the library version you want to use to resolve the issue.</li>
</ul>
<h2><a class="header" href="#problem-points" id="problem-points">Problem Points?</a></h2>
<p>Besides those stated below, you must use <code>npm</code> to install any JavaScript libraries for bindings. This is true for <code>bower</code> and <code>spago</code> alike.</p>
<h3><a class="header" href="#solution-to-most-common-bower-problem-the-cache-mechanism" id="solution-to-most-common-bower-problem-the-cache-mechanism">Solution to Most Common Bower Problem: The Cache Mechanism</a></h3>
<p>When in doubt, run the following command, reinstall things, and see if that fixes your issue:</p>
<pre><code class="language-bash"># Deletes the 'bower_components' and 'output' directories,
# ensuring that the cache mechanism is not corrupting your build
# and that the next build will be completely fresh.
rm -rf bower_components/ output/
</code></pre>
<h3><a class="header" href="#horrible-user-experience-occurs-after-a-breaking-change-release" id="horrible-user-experience-occurs-after-a-breaking-change-release">Horrible User Experience Occurs After a Breaking Change Release</a></h3>
<p>The following issue is happening less and less frequently due to the PureScript language stabilizing, but it still needs to be stated.</p>
<h4><a class="header" href="#annoyance-defined" id="annoyance-defined">Annoyance Defined</a></h4>
<p>If a compiler release that includes breaking changes was released recently, it will take some time for libraries in the ecosystem to become compatible with that release. If you are using Bower as your dependency manager, it may try to install libraries that are not compatible with the new release, creating problems.</p>
<h4><a class="header" href="#recommended-guidelines" id="recommended-guidelines">Recommended Guidelines</a></h4>
<p>In such circumstances, follow these guidelines to help find the correct version of a library:</p>
<ul>
<li>Go to Pursuit and look at the library's package page. Choose one of the library's versions and compare that version's publish date with the date of the compiler release. Those that occur after the compiler release are likely compatible with the new release.</li>
<li>Since <code>purescript-prelude</code> is a dependency for most libraries, see which version of <code>purescript-prelude</code> the library uses. That should indicate whether it's compatible with a new compiler release or not.</li>
<li>If all else fails, check the library's last few commit messages in its repository for any messages about updating to the new compiler release.</li>
</ul>
<h1><a class="header" href="#spago-explained" id="spago-explained">Spago Explained</a></h1>
<h2><a class="header" href="#what-is-it-1" id="what-is-it-1">What is it?</a></h2>
<p>A way to use specific versions of libraries that are known to compile together without problems, as verified by CI.</p>
<h2><a class="header" href="#why-use-it-1" id="why-use-it-1">Why Use It?</a></h2>
<p><code>spago</code> only allows you to use dependencies that compile together on a specific PureScript release. You do not have to track down which version of a <code>DependencyA</code> to use to ensure it compiles when you also use <code>DependencyB</code>. Moreover, you don't have to verify that <code>DependencyA</code> at <code>v1.0.0</code> works on PureScript release <code>0.13.8</code> instead of <code>0.11.7</code>.</p>
<p>When a new PureScript release with breaking changes occurs, using <code>bower</code> is painful until the ecosystem &quot;catches up.&quot; Since a new release draws in a lot of people, their initial exploration of PureScript when using <code>bower</code> can be horrible.</p>
<p><code>spago</code> also allows you to</p>
<ul>
<li>'patch' a dependency with your own version
<ul>
<li>fix a bug in its implementation</li>
<li>update a library to a newer PS release if it hasn't been done yet</li>
<li>update a library's transitive dependency to a newer release without needing to submit a PR</li>
</ul>
</li>
<li>add local or cloud-based dependencies not found in the official package set
<ul>
<li>a project you use frequently, like a custom <code>Prelude</code> library.</li>
<li>a project with your preferred aliases to functions/values (i.e. using <code>&lt;!&gt;</code> for <code>map</code> instead of <code>&lt;$&gt;</code>)</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#how-does-it-work" id="how-does-it-work">How does it work?</a></h2>
<h3><a class="header" href="#spago-terms" id="spago-terms">Spago Terms</a></h3>
<p>A <strong>package</strong> in this context is 4 things:</p>
<ol>
<li>a Git repo</li>
<li>a tag in that repo</li>
<li>a set of its dependencies (which are also packages).</li>
<li>a name to refer to the combination of the above three things</li>
</ol>
<p>Thus, a package is a unique named <code>repo-tag-dependencies</code> combination (e.g. <code>prelude</code> could indicate the <a href="https://github.com/purescript/purescript-prelude/tree/v4.1.1">Prelude repo at the 'v4.1.1' tag</a>).</p>
<p>A <strong>package set</strong> consists of a set of packages. It's a JSON-like file that maps a package name to its corresponding <code>repo-tag-dependencies</code> combination. A package set gets <strong>verified</strong> to ensure that its set of packages compiles together on a given PureScript compiler release. Once verified, they are considered &quot;immutable.&quot;</p>
<p>A package set includes all dependencies: direct ones and their transitive dependencies. For example, if the set includes the package, <code>PackA</code>, which depends on the package, <code>PackB</code>, the package set must include both packages:</p>
<ul>
<li><code>PackA</code>
<ul>
<li>Version: <code>v1.0.0</code></li>
<li>Repo: <code>https://exampleRepo.com/PackA.git</code></li>
<li>Dependencies: <code>[&quot;PackB&quot;]</code> (spago will look up &quot;PackB&quot; in the package set to resolve it)</li>
</ul>
</li>
<li><code>PackB</code>
<ul>
<li>Version: <code>v1.0.0</code></li>
<li>Repo: <code>https://exampleRepo.com/PackB.git</code></li>
<li>Dependencies: <code>[]</code> (no dependencies)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#the-process-it-uses" id="the-process-it-uses">The Process It Uses</a></h3>
<p>Here's a &quot;big picture&quot; flowchart for what a person does and how it fits into their developer workflow:</p>
<p><img src="content/03-Build-Tools/01-Dependency-Managers/./assets/spago-flowchart.svg" alt="spago-flowchart" /></p>
<h2><a class="header" href="#problem-points-1" id="problem-points-1">Problem Points?</a></h2>
<ul>
<li>Major
<ul>
<li>You cannot use this workflow to develop libraries. Use <code>pulp</code> and <code>bower</code> for that.</li>
</ul>
</li>
<li>Minor / has workarounds
<ul>
<li>There is no built-in <code>browserify</code> command (like <code>pulp</code>). So, you need to execute that command (or <code>parcel</code>) yourself.</li>
<li>Just like <code>bower</code>, you still need to use <code>npm</code> to install JavaScript libraries for any PureScript bindings. To understand why, see https://github.com/purescript/spago#why-cant-spago-also-install-my-npm-dependencies</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#why-we-need-both" id="why-we-need-both">Why We Need Both</a></h1>
<p>See <code>@hdgarrood</code>'s <a href="https://harry.garrood.me/blog/purescript-package-management-in-2019/">Thoughts on PureScript package management in 2019</a>.</p>
<p>Below are my thoughts on why we need both. I'm not sure whether this is entirely correct.</p>
<p>Think about what happens when a PureScript release is made that includes breaking changes.</p>
<p>Updating each library in the ecosystem to account for those breaking changes is similar to putting a plant inside a vase with colored water. The colored water will first enter its roots, then go up its branches, and finally appear in every leaf (<a href="http://www.teaching-tiny-tots.com/toddler-science-celery-experiment.html">Kids' experiment explained with photos</a>)</p>
<p>In our above analogy, the <code>purescript-prelude</code> library and other libraries with no dependencies are the &quot;roots&quot; of the ecosystem. As they get updated, the libraries that depend on them (i.e. the &quot;branches&quot;) can now be updated. A &quot;leaf&quot; corresponds to a library which has no dependents.</p>
<p>A package set is immutable. Thus, one cannot add to the package set a package that has been updated to the new release unless all of the packages in the package set can also be updated.</p>
<p>During that transitional time, <code>spago</code> cannot help. Rather, we must depend on <code>Bower</code> to slowly update each library to its new version that depends on transitive libraries that have been updated to new versions.</p>
<p>Again, <code>spago</code> is more suited for application developers and <code>bower</code> is more suited for library developers.</p>
<h1><a class="header" href="#spago-from-start-to-finish" id="spago-from-start-to-finish">Spago: From Start to Finish</a></h1>
<p>The below example uses <code>spago</code> as the build tool and dependency manager.</p>
<h2><a class="header" href="#create-the-project" id="create-the-project">Create the project</a></h2>
<pre><code class="language-bash"># 1. Sets up the initial files and structure of the project
spago init
</code></pre>
<p>If you need to override/add packages to the standard package set, proceed to <code>Configure the Package Set</code>. Otherwise, continue to <code>Install Dependencies</code></p>
<h3><a class="header" href="#configure-the-package-set" id="configure-the-package-set">Configure the Package Set</a></h3>
<pre><code class="language-bash"># 2a) Open the below file, read its top-level comment,
#       and follow its instructions to override/add packages
nano packages.dhall

# 2b) When finished, either verify that a single patched/added package
#       works with the rest of the set...
spago verify singlePackageName
#       or re-verify the entire package set
spago verify-set
</code></pre>
<h3><a class="header" href="#freeze-the-package-set" id="freeze-the-package-set">Freeze the Package Set</a></h3>
<p>Note: Spago does this automatically now. So, one likely does not need to do this anymore. It is provided for context / historical purposes.</p>
<pre><code class="language-bash"># 3) Freeze the package set to prevent security issues.
#     For a deeper explanation on what happens here,
#     see Dhall's safety guarantees wiki page:
#     https://github.com/dhall-lang/dhall-lang/wiki/Safety-guarantees
spago freeze
</code></pre>
<h2><a class="header" href="#install-dependencies" id="install-dependencies">Install Dependencies</a></h2>
<p>One of two ways</p>
<pre><code class="language-bash"># Install a package from the package set to your project
spago install packageName1 packageName2 # ...
</code></pre>
<h2><a class="header" href="#write-the-code" id="write-the-code">Write the Code</a></h2>
<pre><code class="language-bash"># Open the REPL to play with a few ideas or run simple tests
spago repl

# Build the docs
spago docs --open

# Automatically re-build project whenever a source/test file is changed/saved
# and clear the screen before rebuilding
spago build --watch --clear-screen
</code></pre>
<h2><a class="header" href="#build-the-code" id="build-the-code">Build the Code</a></h2>
<pre><code class="language-bash"># Install all dependencies (if not done so already) and
# compile the code
spago build

# Build a developer-level executable file
spago bundle-app --main Module.Path.To.Main --to dist/index.js
node dist/index.js

# Build a production-level Node-backend file via Parcel
spago bundle-app --main Module.Path.To.Main --to dist/bundle-output.js
parcel build dist/bundle-output.js --target &quot;node&quot; -o app.js
</code></pre>
<p>To build a production-level browser-backend file...</p>
<pre><code class="language-bash"># Build a production-level browser-backend file
spago bundle-app --main Module.Path.To.Main --to dist/app.js
</code></pre>
<p>Create an HTML file (dist/example.html) that references the 'app.js' file</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;!-- Insert your title here --&gt;
    &lt;title&gt;Some Title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Reference the outputted bundle here --&gt;
    &lt;script src=&quot;/app.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Then use parcel to do minification and open the resulting web page</p>
<pre><code class="language-bash">parcel build dist/example.html --target &quot;browser&quot; -o index.html --open
# it'll create a few files in the `dist/` folder and open the resulting
# &quot;dist/index.html&quot; file via your default web browser
</code></pre>
<h1><a class="header" href="#bower-from-start-to-finish" id="bower-from-start-to-finish">Bower: From Start to Finish</a></h1>
<p><strong>Warning:</strong> This code hasn't been checked. Most of it should be correct, but some parts might be wrong.</p>
<h2><a class="header" href="#create-the-project-1" id="create-the-project-1">Create the project</a></h2>
<p>One of two ways</p>
<pre><code class="language-bash">pulp init
</code></pre>
<h2><a class="header" href="#install-dependencies-1" id="install-dependencies-1">Install dependencies</a></h2>
<pre><code class="language-bash"># Need to install NPM packages and initialize them
npm install npm-package1 npm-package2
npm install
bower install package1 package2 --save
bower install
</code></pre>
<p>Due to the Bower registry being deprecated, there are some packages that will have to be installed using a longer name format because the library couldn't be uploaded into the Bower registry. While the registry is deprecated, <code>bower</code> can still download the files from GitHub if one uses this longer name format. Harry described how one could do that here and also mentions <code>bower link</code> as another possible option:</p>
<blockquote>
<p>in <code>bower.json</code>, instead of writing...</p>
<blockquote>
<pre><code class="language-json">&quot;dependencies&quot;:{
   &quot;purescript-some-library&quot;:&quot;^0.1.0&quot;
}
</code></pre>
</blockquote>
<p>... you can write</p>
<blockquote>
<pre><code class="language-json">&quot;dependencies&quot;: {
   &quot;purescript-some-library&quot;:&quot;https://github.com/githubUser/purescript-some-library#my-branch&quot;
}
</code></pre>
</blockquote>
<p>you can also use <code>bower link</code> which is similar but gives you a bit more flexibility</p>
</blockquote>
<h3><a class="header" href="#write-the-code-1" id="write-the-code-1">Write the Code</a></h3>
<pre><code class="language-bash"># Open the REPL to play with a few ideas or run simple tests
pulp repl

# Automatically re-build project whenever a source file is changed/saved
pulp --watch --before 'clear' build

# Automatically re-test project whenever a source/test file is changed/saved
pulp --watch --before 'clear' test

# Build a developer version
pulp browserify --to dist/fileName.js # if program
pulp browserify --no-main-check --to dist/fileName.js # if library

# Run the program and pass args to the underlying program
pulp run -- arg1PassedToProgram arg2PassedToProgram
</code></pre>
<h3><a class="header" href="#publish-the-package-for-the-first-time" id="publish-the-package-for-the-first-time">Publish the Package for the First Time</a></h3>
<p>See this <a href="https://pursuit.purescript.org/help/authors">help page for authors</a> on Pursuit. Its instructions are more authoritative than what follows.</p>
<pre><code class="language-bash"># Build the docs
pulp docs -- --format html
# Then read over them to insure there aren't any formatting issues or typos

# Make a production build via Browserify
#   If building a program...
pulp browserify --optimise --to dist/fileName.js
#   If building a library
pulp browserify --no-main-check --optimise --to dist/fileName.js

# Set the initial version
pulp version v0.1.0

# Publish the version
pulp publish
</code></pre>
<h3><a class="header" href="#publish-a-new-version-of-an-already-published-package" id="publish-a-new-version-of-an-already-published-package">Publish a New Version of an Already-Published Package</a></h3>
<pre><code class="language-bash"># Build and check the docs
pulp docs -- --format html

# Make a production build
#   If building a program...
pulp browserify --optimise --to dist/fileName.js
#   If building a library
pulp browserify --no-main-check --optimise --to dist/fileName.js

# bump project version
pulp version major
pulp version minor
pulp version patch
# or specify a version
pulp version v1.5.0

# publish it
pulp publish
</code></pre>
<h1><a class="header" href="#continuous-integration" id="continuous-integration">Continuous Integration</a></h1>
<h2><a class="header" href="#github-actions---bower-based" id="github-actions---bower-based">GitHub Actions - <code>Bower</code>-based</a></h2>
<pre><code class="language-yml">name: CI

on:
  push:
    branches: [master]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - uses: purescript-contrib/setup-purescript@main

      - uses: actions/setup-node@v1
        with:
          node-version: &quot;12&quot;

      - name: Install dependencies
        run: |
          npm install -g bower
          npm install
          bower install --production
      - name: Build source
        run: npm run-script build

      - name: Run tests
        run: |
          bower install
          npm run-script test --if-present
</code></pre>
<h2><a class="header" href="#github-actions---spago-based" id="github-actions---spago-based">GitHub Actions - <code>Spago</code>-based</a></h2>
<pre><code class="language-yml">name: CI

on:
  push:
    branches: [master]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Set up PureScript toolchain
        uses: purescript-contrib/setup-purescript@main

      - name: Cache PureScript dependencies
        uses: actions/cache@v2
        with:
          key: ${{ runner.os }}-spago-${{ hashFiles('**/*.dhall') }}
          path: |
            .spago
            output

      - name: Set up Node toolchain
        uses: actions/setup-node@v1
        with:
          node-version: &quot;12.x&quot;

      - name: Cache NPM dependencies
        uses: actions/cache@v2
        env:
          cache-name: cache-node-modules
        with:
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      - name: Install NPM dependencies
        run: npm install

      - name: Build the project
        run: npm run build

      - name: Run tests
        run: npm run test
</code></pre>
<h1><a class="header" href="#syntax" id="syntax">Syntax</a></h1>
<p>This folder contains compileable Purescript syntax using meta-language (a language that describes the syntax). Thus, rather than saying something like</p>
<pre><code class="language-haskell">f :: String -&gt; Int
</code></pre>
<p>which doesn't tell you anything, it'll say:</p>
<pre><code class="language-haskell">functionName :: ParameterType -&gt; ReturnType
</code></pre>
<p>Since the syntax can be compiled, it can be verified as valid and correct syntax.</p>
<p>As a result, most files will appear like so:</p>
<pre><code class="language-haskell">-- The module will be declared at the top of the file
--   It can be ignored.
module Syntax.ModuleName where

-- The Prelude module might be imported
--   It, too, can be ignored.
import Prelude

-- The thing that the file is documenting usually goes here.
--    Don't ignore this stuff.
data Box a = Box a

-- Sometimes the comment &quot;necessary to compile&quot; will appear.
-- It makes the meta-language compileable. Ignore everything underneath it
--   as you read through the files.

-- necessary to compile
type SomeTypeName = String
</code></pre>
<p>If you want to play around with the syntax, follow these instructions:</p>
<ol>
<li>Go to a directory that has a <code>spago.dhall</code> file (otherwise, the rest of these commands won't work)</li>
<li>Install the dependencies: <code>spago install</code></li>
<li>Start a REPL or build the files with watching (refer to the table below)</li>
</ol>
<table><thead><tr><th>Command</th><th>Ideal Usage</th><th>Other Comments</th></tr></thead><tbody>
<tr><td><code>spago repl</code></td><td>Play with &lt;10 lines of syntax</td><td>Edit <code>.purs-repl</code> and add <code>import ModuleName</code> to automatically import that module whenver you run this command</td></tr>
<tr><td><code>spago build --watch</code></td><td>Test out 10+ lines of syntax</td><td>Saving a file after running this command will re-compile the project</td></tr>
</tbody></table>
<h1><a class="header" href="#basic-syntax" id="basic-syntax">Basic Syntax</a></h1>
<p>Read through these files in their order. To further grasp the concept, write your own version of the code and see if it still compiles by running:</p>
<pre><code class="language-bash">spago build
</code></pre>
<p>To see what the documentation looks like, run this command:</p>
<pre><code class="language-bash">spago docs --open
</code></pre>
<p>The above command will generate the docs, and then open the file, <code>./generated-docs/index.html</code>.</p>
<h1><a class="header" href="#00-commentspurs" id="00-commentspurs">00-Comments.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Comments where

-- This is a single-line comment
-- Anything past the &quot;--&quot; syntax on a line is regarded as a comment

{-
This is a multi-line comment
Anything between the bracket-dash syntax is regarded as a multi-line comment
-}

{- It can also be used to add a comment in-between stuff -}
</code></pre>
<h1><a class="header" href="#01-value-function-data-syntaxpurs" id="01-value-function-data-syntaxpurs">01-Value-Function-Data-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Meta where

-- This file simply shows enough syntax so that the
-- explanation on Kinds (next) makes sense.
--
-- entity_name :: Type Signature
-- entity_name = definition

integer_value :: Int
integer_value = 5

string_value :: String
string_value = &quot;this is text&quot;

-- | In other words...
-- | ```
-- | var one_arg_function = function (argument) {
-- |   return bodyThatReturnsType;
-- | };
-- | ```
one_arg_function :: ParameterType -&gt; ReturnType
one_arg_function argument = bodyThatReturnsType

-- Below is an Algebraic Data Type. We'll explain these more later.
--
-- Here, we declare a type called `Type_Used_In_Functions_Type_Signatures`,
-- which has two implementations. The type is used in an entity's
-- Type Signatures while the implementations are used in an entity's
-- definition
data Type_Used_In_Functions_Type_Signatures
  = Type_Implementation1
  | Type_Implementation2

example1 :: Type_Used_In_Functions_Type_Signatures
example1 = Type_Implementation1

example2 :: Type_Used_In_Functions_Type_Signatures
example2 = Type_Implementation2

-- A &quot;box&quot; that can store only Ints
data Box_That_Stores_Ints = Box Int

example3 :: Box_That_Stores_Ints
example3 = Box 4

example4 :: Int -&gt; Box_That_Stores_Ints
example4 x = Box x

-- A &quot;box&quot; type that can store values of another type.
data Box_That_Stores anotherType = Box_Storing anotherType

example5 :: Box_That_Stores Int
example5 = Box_Storing 4

example6 :: Int -&gt; Box_That_Stores Int
example6 x = Box_Storing x

-- Look! An outer Box that stores an inner Box, that stores an Int
example7 :: Box_That_Stores (Box_That_Stores Int)
example7 = Box_Storing (Box_Storing 4)

-- The &quot;forall someType.&quot; syntax will be explained later. It's needed here
-- to make this code compile. You can read example8's type signature as
-- &quot;If you give me a value that has a given type, which I'll refer to as
-- `someType`, then I can give you back a Box that stores a value of
-- `someType`.&quot;
example8 :: forall someType. someType -&gt; Box_That_Stores someType
example8 valueWhoseTypeIs_'someType' = Box_Storing valueWhoseTypeIs_'someType'

-- necessary to make this file compile

type ValueType = String
type ParameterType = String
type ParameterType1 = String
type ParameterType2 = String
type ReturnType = String

bodyThatReturnsType :: ReturnType
bodyThatReturnsType = &quot;return value&quot;

bodyOfFunction :: ReturnType
bodyOfFunction = &quot;body of inline function&quot;
</code></pre>
<h1><a class="header" href="#explaining-kinds" id="explaining-kinds">Explaining Kinds</a></h1>
<p>This code...</p>
<pre><code class="language-haskell">function :: Int -&gt; String
function x = &quot;an integer value!&quot;
</code></pre>
<p>... translates to, &quot;I cannot give you a concrete value (i.e. <code>String</code>) until you give me an <code>Int</code> value.&quot;</p>
<p>Similarly, this code...</p>
<pre><code class="language-haskell">data Box a = Box a
</code></pre>
<p>... translates to, &quot;I cannot give you a concrete type (e.g. <code>Box Int</code>, a box that stores an <code>Int</code> value (rather than a <code>String</code> value or some other value)) until you tell me what <code>a</code> is.&quot;</p>
<p>Let's rewrite the above <code>Box</code> type. Things on the left of the <code>=</code> indicate type information. Things on the right of the <code>=</code> indicate value information.</p>
<pre><code class="language-haskell">{-
| Type information | Value information |                                     -}
data BoxType a     = BoxValue a
</code></pre>
<p>The above code now says, &quot;I cannot give you a concrete type (e.g. <code>BoxType Int</code>) until you tell me what <code>a</code> is.&quot; Let's assume that <code>a</code> is <code>Int</code>. We would say that <code>BoxValue 4</code> is a value whose type is <code>BoxType Int</code>.</p>
<h2><a class="header" href="#what-are-kinds-and-kind-signatures" id="what-are-kinds-and-kind-signatures">What are Kinds and Kind Signatures?</a></h2>
<blockquote>
<p>Kinds = &quot;How many more types do I need defined before I have a 'concrete' type?&quot;^^</p>
</blockquote>
<p>^^ This is a &quot;working definition.&quot; There's more to it than that when one considers type-level programming, but for now, this will suffice.&quot;</p>
<p>We saw earlier that we annotate functions with type signatures via <code>-&gt;</code>:</p>
<pre><code class="language-haskell">--              ||
--              \/
function :: Int -&gt; String
function x = &quot;an integer value!&quot;
</code></pre>
<p>The <code>-&gt;</code> indicates that the thing to the right (i.e. <code>String</code>) cannot be produced until it is given the thing to the left of it (i.e. <code>Int</code>).</p>
<p>Type signatures annotate value-level entities like values (i.e. <code>4</code> or <code>BoxValue</code>) and functions.
Kind signatures annotate type-level entities like <code>BoxType</code>. They are basically type signatures for types, not values.</p>
<table><thead><tr><th># of types that still need to be defined</th><th>Special Name</th><th align="right">Their &quot;kind signature&quot; (Purescript)^^</th><th align="right">Their &quot;kind signature&quot; (Haskell)^^</th></tr></thead><tbody>
<tr><td>0</td><td>Concrete Type</td><td align="right"><code>                Type</code></td><td align="right"><code>          *</code></td></tr>
<tr><td>1</td><td>Higher-Kinded Type (by 1)</td><td align="right"><code>        Type -&gt; Type</code></td><td align="right"><code>     * -&gt; *</code></td></tr>
<tr><td>2</td><td>Higher-Kinded Type (by 2)</td><td align="right"><code>Type -&gt; Type -&gt; Type</code></td><td align="right"><code>* -&gt; * -&gt; *</code></td></tr>
<tr><td>n</td><td>Higher-Kinded Type (by n)</td><td align="right"><code>... Type ... -&gt; Type</code></td><td align="right"><code>... * ... -&gt; *</code></td></tr>
</tbody></table>
<p>^^ These columns are right-aligned to show that the right-most <code>Type</code>/<code>*</code> is the &quot;concrete&quot; type. Also, the <code>... Type ... -&gt; Type</code> (and its Haskell equivalent) syntax is not real syntax but merely conveys the recursive idea in an n-kinded type. The other three (0 - 2) are real syntax.</p>
<h2><a class="header" href="#concrete-types" id="concrete-types">Concrete Types</a></h2>
<p>Concrete types can usually be written with literal values:</p>
<pre><code class="language-haskell">integerValue :: Int
integerValue = 1

(1 :: Int) -- this is notation for saying that `1` is a value of type, `Int`.

stringValue :: String
stringValue = &quot;a literal string&quot;

(&quot;a literal string&quot; :: String)

data BoxType a = BoxValue a

boxWithOneIntValue :: BoxType Int
boxWithOneIntValue = BoxValue 4

((BoxValue 4) :: BoxType Int)

arrayOfIntsValue :: Array Int
arrayOfIntsValue = [1, 2, 3]

([1, 2, 3] :: Array Int)
</code></pre>
<h2><a class="header" href="#higher-kinded-types" id="higher-kinded-types">Higher-Kinded Types</a></h2>
<p>Higher-kinded types are those that still need one or more types to be defined.</p>
<pre><code class="language-haskell">-- Kind Signature: Type -&gt; Type
-- Reason: the `a` type needs to be defined
data Box a = Box a

-- This is the same definition as above.
-- However, the kind signature of the above `Box` definition is implicit.
-- The below definition has an explicit kind signature.
data BoxType :: Type -&gt; Type
data BoxType a = BoxValue a

-- As we can see, there can be many different concrete 'Box' types
-- depending on what 'a' is:
boxedInt :: Box Int
boxedInt = Box 4

boxedString :: Box String
boxedString = Box &quot;string&quot;

boxedBoxedInt :: Box (Box Int)
boxedBoxedInt = Box boxedInt
</code></pre>
<p>We can make the type's kind higher by adding more types that need to be specified. For example:</p>
<pre><code class="language-haskell">-- A box that holds two values of same or different types!
-- Kind Signature: `Type -&gt; Type -&gt; Type`
data BoxOfTwo a b = BoxOfTwo a b

data BoxOfTwo_ExplicitKindSignature :: Type -&gt; Type -&gt; Type
data BoxOfTwo_ExplicitKindSignature a b = BoxOfTwoValue a b

-- The below syntax is not valid because it is missing `forall a b.`,
--   but it gets the idea across. The &quot;forall&quot; syntax will be covered later.
higherKindedBy2 :: a -&gt; b -&gt; BoxOfTwo a b
higherKindedBy2 a b = BoxOfTwo a b

-- We can lower the kind by specifying one of the data types:
higherKindedBy1L :: b -&gt; BoxOfTwo Int b
higherKindedBy1L b = BoxOfTwo 3 b

higherKindedBy1R :: a -&gt; BoxOfTwo a String
higherKindedBy1R a = BoxOfTwo a &quot;a string value&quot;

concreteType :: BoxOfTwo Int String
concreteType = BoxOfTwo 3 &quot;a string value&quot;
</code></pre>
<p>Generic types can also be split across the values of a type:</p>
<pre><code class="language-haskell">-- It's either an A or it's a B, but not both!
-- Kind signature is implicit: `Type -&gt; Type -&gt; Type`
data Either a b
  = Left a
  | Right b

data Either_ExplicitKindSignature :: Type -&gt; Type -&gt; Type
data Either_ExplicitKindSignature a b
  = Left a
  | Right b

higherKindedBy2L :: a -&gt; b -&gt; Either a b
higherKindedBy2L a b = Left a

higherKindedBy2R :: a -&gt; b -&gt; Either a b
higherKindedBy2R a b = Right b

higherKindedBy1L_ignoreB :: b -&gt; Either Int b
higherKindedBy1L_ignoreB b = Left 3

higherKindedBy1L_useB :: b -&gt; Either Int b
higherKindedBy1L_useB b = Right b

higherKindedBy1L_ignoreBoth :: a -&gt; b -&gt; Either Int b
higherKindedBy1L_ignoreBoth a b = Left 3
</code></pre>
<p><code>Either</code> (where the <code>a</code> and <code>b</code> are not yet specified) has kind <code>Type -&gt; Type -&gt; Type</code> because it cannot become a concrete type until both <code>a</code> and <code>b</code> types are defined, even if only constructing one of its values whose generic type is known.</p>
<p>In other words</p>
<pre><code class="language-haskell">allSpecified :: Either Int String
allSpecified = Right &quot;foo&quot;

{-
(value)                                                                       -}
(Right &quot;foo&quot;)                                                                 {-

(value       :: Type             )                                            -}
(Right &quot;foo&quot; :: Either Int String)                                            {-

((value       :: Type             ) :: Kind)                                  -}
((Right &quot;foo&quot; :: Either Int String) :: Type)                                  {-

((value       :: Type           ) :: Kind        )                            -}
((Right &quot;foo&quot; :: Either a String) :: Type -&gt; Type)
</code></pre>
<h2><a class="header" href="#table-of-inferred-types" id="table-of-inferred-types">Table of Inferred Types</a></h2>
<table><thead><tr><th></th><th align="right">Inferred kind</th></tr></thead><tbody>
<tr><td><code>Unit</code></td><td align="right"><code>Type</code></td></tr>
<tr><td><code>Array Boolean</code></td><td align="right"><code>Type</code></td></tr>
<tr><td><code>Array</code></td><td align="right"><code>Type -&gt; Type</code></td></tr>
<tr><td><code>Either Int String</code></td><td align="right"><code>Type</code></td></tr>
<tr><td><code>Either Int b</code></td><td align="right"><code>Type -&gt; Type</code></td></tr>
<tr><td><code>Either a String</code></td><td align="right"><code>Type -&gt; Type</code></td></tr>
<tr><td><code>Either</code></td><td align="right"><code>Type -&gt; Type -&gt; Type</code></td></tr>
<tr><td>...</td><td align="right">...</td></tr>
</tbody></table>
<h1><a class="header" href="#03-the-prim-modulepurs" id="03-the-prim-modulepurs">03-The-Prim-Module.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.PrimitiveTypesAndKinds where

import Prelude

{-
The following file documents the Prim module. This module is imported
by default into every PureScript file (unless one hides it using Module aliases,
which are described in the Module Syntax folder) and is embedded in the
compiler itself to provide value literals for certain types and syntax sugar.

See the full documenation here:
https://pursuit.purescript.org/builtins/docs/Prim

This file will document all the types whose kind signature is `Type`.
Their kind signatures aren't that important at this level in your understanding.

Note: To prevent conflicts between the real code and this compileable file,
we're appending underscores to the types. Remove the underscore to get the
real thing in Purescript.

In other words
Purescript:        DataType  :: Kind
This example: data DataType_ -- Kind
-}
data Number_ -- Type -- double-precision float number

exampleNumber :: Number
exampleNumber = 1.0

data Int_ -- Type

exampleInt1 :: Int
exampleInt1 = 1

exampleInt2 :: Int
exampleInt2 = 0x01 -- alternative way to write them

exampleInt3 :: Int
exampleInt3 = 1_000_000 -- use underscores for thousands character

data Boolean_ -- Type

exampleTrue :: Boolean
exampleTrue = true

exampleFalse :: Boolean
exampleFalse = false
{-
Note: The Boolean data type is used via true/false literal values instead of
True/False constructors as one might expect, especially those coming from Haskell
where such a simple data type would be defined as:

data Boolean = True | False

In Purescript, having Javascript as the main compilation target, the decision was
made to use true/false literal values for the Boolean data type instead of
having it be defined as a simple Algebric Data Type (ADT) as is the case in Haskell.
-}

data Char_ -- Type -- doesn't support astral plane characters (code points &gt; 0xFFFF)

exampleChar :: Char
exampleChar = 'c'

unicodeA :: Char
unicodeA = '\x0061'

-- Astral plane characters (i.e. those with code point values greater than
-- `0xFFFF`) cannot be represented as `Char` values.
unicodeChar :: Char
unicodeChar = '\xFFFF'

unicodeChar2 :: Char
unicodeChar2 = '\xffff'

data String_ -- Type

literal_string_syntax :: String
literal_string_syntax = &quot;literal string value&quot;

-- Follows this regex pattern: \x[0-9a-fA-F]{1,6}
unicode_hex_escape_syntax :: String
unicode_hex_escape_syntax = &quot;\xa4&quot;

-- Syntax sugar for Strings
slashy_string_syntax :: String
slashy_string_syntax =
  &quot;Enables multi-line strings that \
  \use slashes \
            \regardless of indentation \

    \and regardless of vertical space between them \

    \(though you can't put comments in that blank vertical space)&quot;
    {-
    &quot;This will fail \
    -- oh look a comment that breaks this!
    \to compile.&quot;
    -}

triple_quote_string_syntax :: String
triple_quote_string_syntax = &quot;&quot;&quot;
  Multi-line string syntax that also ignores escaped characters, such as
  * . $ []
  It's useful for regular expressions
  &quot;&quot;&quot;

-- Higher-Kinded Types
data Array_ -- Type -&gt; Type

arrayOfStrings :: Array String
arrayOfStrings = [&quot;string1&quot;, &quot;string2&quot;]

arrayOfInts :: Array Int
arrayOfInts = [0, 1, 2, 3]

-- The &quot;forall a.&quot; syntax will be explained later. It's needed here
-- to make this code compile
array_of_one_A :: forall a. a -&gt; Array a
array_of_one_A a = [a]

data Function_ -- Type (parameter type) -&gt; Type (return type)  -&gt; Type
-- In other words, give me the parameter type and the return type,
--   and I'll have a concrete type

function_no_syntax_sugar :: Function Int Int
function_no_syntax_sugar = (\x -&gt; x + 4)

function_with_syntax_sugar1 :: (Int -&gt; Int)
function_with_syntax_sugar1 = (\x -&gt; x + 4)

function_with_syntax_sugar2 :: Int -&gt; Int
function_with_syntax_sugar2 = (\x -&gt; x + 4)

function_with_syntax_sugar3 :: Int -&gt; Int
function_with_syntax_sugar3 x = x + 4
</code></pre>
<h1><a class="header" href="#01-defining-values-and-functionspurs" id="01-defining-values-and-functionspurs">01-Defining-Values-and-Functions.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.ValuesAndFunctions where

import Prelude

-- This file simply shows the syntax for how to define
-- values and types

-- A zero-arg function cannot exist in FP programming*
-- Thus, it counts as a static value
literal_value :: ValueType
literal_value = &quot;literal value&quot;

-- * function :: Unit -&gt; ReturnType is as close as one can get to a
-- zero-arg function in functional programming. Unit will be explained later
-- in the &quot;Hello World&quot; folder.

result_of_function :: Int
result_of_function = 4 + 5 -- 9

one_arg_function :: ParameterType -&gt; ReturnType
one_arg_function argument = bodyThatReturnsType

two_arg_function :: ParameterType1 -&gt; ParameterType2 -&gt; ReturnType
two_arg_function argument1 argument2 = bodyThatReturnsType

n_arg_function :: ParameterType1 -&gt; {- ... ParameterTypeN -&gt; ... -} ReturnType
n_arg_function arg1 {- arg2 arg3 ... argN -} = bodyThatReturnsType

function_using_inline_syntax :: (Int -&gt; Int)
function_using_inline_syntax = (\x -&gt; x + 4)

                                         {- function  -}
function_that_takes_a_function :: Int -&gt; (Int -&gt; String) -&gt; String
function_that_takes_a_function i f = f i

                                           {- function -}
function_that_returns_a_function :: Int -&gt; (Int -&gt; Int)
function_that_returns_a_function x = (\y -&gt; y + x)

-- Note: a &quot;higher order function&quot; either takes a function as an argument
-- or returns a function

-- examples
takes_a_function :: String
takes_a_function =
  function_that_takes_a_function 3 (\x -&gt; show x)
  -- show: converts `Int` to `String`
  -- outputs: &quot;3&quot;

returns_a_function :: Int
returns_a_function =
  (function_that_returns_a_function 4) 10
  -- outputs: 14
  -- reason: (\10 -&gt; 10 + 4)

-- necessary to make this file compile

type ValueType = String
type ParameterType = String
type ParameterType1 = String
type ParameterType2 = String
type ReturnType = String

bodyThatReturnsType :: ReturnType
bodyThatReturnsType = &quot;return value&quot;

bodyOfFunction :: ReturnType
bodyOfFunction = &quot;body of inline function&quot;
</code></pre>
<h1><a class="header" href="#02-function-curryingpurs" id="02-function-curryingpurs">02-Function-Currying.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Function.Currying where

-- Remember this function?
one_arg_function_syntax_sugar :: ParameterType -&gt; ReturnType
one_arg_function_syntax_sugar argument = bodyThatReturnsType

-- it's syntax sugar for
one_arg_function_no_syntax_sugar :: Function ParameterType ReturnType
one_arg_function_no_syntax_sugar argument = bodyThatReturnsType

-- Which means this function...
two_arg_function0 :: ParameterType1 -&gt; ParameterType2 -&gt; ReturnType
two_arg_function0 argument1 argument2 = bodyThatReturnsType

-- is in a &quot;curried&quot; form. In reality, it's
two_arg_function1 :: ParameterType1 -&gt; (ParameterType2 -&gt; ReturnType)
two_arg_function1 argument1 argument2 = bodyThatReturnsType
-- or without syntax sugar
two_arg_function2 :: Function ParameterType1 (ParameterType2 -&gt; ReturnType)
two_arg_function2 argument1 argument2 = bodyThatReturnsType
-- and removing the last one
two_arg_function3 :: Function ParameterType1 (Function ParameterType2 ReturnType)
two_arg_function3 argument1 argument2 = bodyThatReturnsType

{-
In other words, give me an argument (ParameterType1) and I'll return a
  function (ParameterType2 -&gt; ReturnType). If you give that function
  a parameter (ParameterType2), then it'll give you the ReturnType.
Since this happens in the background, we don't usually need to think about
  it, but it is an important distinction to make as it creates the following
  Javascript code:

two_arg_function = function (ParameterType1) -&gt; {
  return function (ParameterType2) -&gt; {
    return bodyThatReturnsType;
  }
}
-}

-- necessary to compile

type ParameterType = String
type ParameterType1 = String
type ParameterType2 = String
type ReturnType = String

bodyThatReturnsType :: String
bodyThatReturnsType = &quot;body&quot;
</code></pre>
<h1><a class="header" href="#03-abbreviated-function-bodypurs" id="03-abbreviated-function-bodypurs">03-Abbreviated-Function-Body.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Function.BodyAbbreviation where

import Prelude

-- if the body of a function is another function that expects an argument,
-- one can omit the argument entirely.
--    Note: 'show' converts a value of most types into a `String` value.

function_normal      :: Int -&gt; String
function_normal         x    = show    x
--    is the same as ...
function_abbreviated :: Int -&gt; String
function_abbreviated {- x -} = show {- x -}
--    which is better written as ...
function_abbreviated2 :: Int -&gt; String
function_abbreviated2 = show

-- example
exampleAbbreviation2 :: Boolean
exampleAbbreviation2 = (function_abbreviated2 4) == &quot;4&quot;

-- Going from &quot;function_normal&quot; to &quot;function_abbreviated2&quot; is called
-- &quot;eta-reduction&quot;.
-- Goind from &quot;function_abbreviated2&quot; to &quot;function_normal&quot; is called
-- &quot;eta-expansion&quot; or &quot;eta-abstraction&quot;

warning :: String
warning = &quot;&quot;&quot;

Sometimes, using an abbreviated function / eta-reduction will cause problems.
See this issue for more details:
https://github.com/purescript/purescript/issues/950

To fix it, just un-abbreviate the function body by eta-expanding it
(i.e. include the argument):
-- change this:
f :: Int -&gt; String
f = show

-- to
f' :: Int -&gt; String
f' x = show x
&quot;&quot;&quot;
</code></pre>
<h1><a class="header" href="#04-keyword--datapurs" id="04-keyword--datapurs">04-Keyword--Data.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Keyword.Data where

-- Basic syntax for the `data` keyword
-- For most of these examples, we will not need to use explicit kind signatures.

data Singleton_no_Args = SingletonConstructor

data Singleton_with_Args = SingletonConstructor2 Arg1 Arg2 ArgN

data Singleton_with_Function_Arg
  = SingletonConstructor3 (ParameterType -&gt; ReturnType)

data Type_with_Many_Implmementations
  = Implementation1
  | Implementation2
  | ImplementationN

data Type_with_Generic_Types aType bType
  = Stores_A aType
  | Stores_B bType
  | Stores_A_and_B aType bType

-- We can refer to various parts in these definitions by the following names.
-- Wherever a name appears, that's what you would call it if you were talking
-- to someone else about it. In this example, we will need a kind signature
-- because `typeParameter` isn't used in the data constructor.
data TypeConstructor :: Type -&gt; Type
data TypeConstructor typeParameter = DataConstructor

---------------------------------

-- This syntax enables Algebraic Data Types (ADTs)
-- For an explanation on how 'data types' can be 'algebraic,' see this video:
-- https://youtu.be/Up7LcbGZFuo?t=19m8s

-- 2 basic version of ADTs: sum type and product type

-- the sum type
data SumType
  = SumConstructor1
  | SumConstructor2
  | SumConstructorN

-- example
data Fruit
  = Apple
  | Banana
  | Orange

-- the product type
data ProductType a b = ProductConstructor a b

-- example
data IntAndString = IAndS Int String

--------------------------------------------

-- Intermediate/Advance syntax

-- given this code
data Box a = Box a
-- then...
data Type_with_Nested_Types
  = SingleBox Int
  | NestedBox1 (Box Int)
  | NestedBox2 (Box (Box Int)) -- outer Box's &quot;a&quot; is &quot;(Box Int)&quot;

data Type_with_Higher_Kinded_Type f = TypeValue (f Int)

typeWithHigherKindedTypeExample :: Type_with_Higher_Kinded_Type Box
typeWithHigherKindedTypeExample = TypeValue (Box 4)

data Type_with_Higher_Kinded_Generic_Type higherKindedBy1 a
  = MyConstructor (higherKindedBy1 a)
  | OtherC (higherKindedBy1 Int)

data Type_with_Higher_Kinded_Generic_Type2 higherKindedBy2 a b
  = MyConstructor2 (higherKindedBy2 a b)
  | OtherCInt (higherKindedBy2 Int b)
  | OtherCIntString (higherKindedBy2 Int String)

-- In the next two examples, we need an explicit kind signature.
-- The reason will become more evident in later files, but you will
-- understand it in full when you read through the Type-Level Syntax folder
-- ============================================================================
-- Since `a` and `b` aren't defined here, we need an explicit kind signature
data Type_With_HigherKindedByTwo_Generic
  :: (Type -&gt; Type -&gt; Type) -- higherKindedBy2
  -&gt; Type                   -- a
  -&gt; Type                   -- b
  -&gt; Type                   -- the &quot;concrete&quot; type
data Type_With_HigherKindedByTwo_Generic higherKindedBy2 a b
  = Example (higherKindedBy2 a b)


-- Since `ignoredType` isn't used in one of the data constructors
-- we need an explicit kind signature.
data Type_whose_implementations_ignore_generic_type :: Type -&gt; Type
data Type_whose_implementations_ignore_generic_type ignoredType
  = Constructor_without_generic_type
  | Other_Constructor_no_generic_type Int String
-- ============================================================================

data Type_with_no_implementation -- no equals sign followed by right-hand-side


data Recursive_Type
  = No_Recursion_Here
  | Recursion_Here Recursive_Type
-- Recursion_Here (Recursion_Here (No_Recursion_Here))

data Recursive_type_with_generic_type a
  = End_Recursion_Here
  | Recursion_Here__Store_A a (Recursive_type_with_generic_type a)
{-
Recursion_Here__Store_A &quot;first&quot;
  (Recursion_Here__Store_A &quot;second&quot;
    End_Recursion_Here)
-}
------------------------------------------

-- Full Syntax
-- Here we need a kind signature because `ignored` does not appear
-- in any of the below data constructors.
data DataType :: Type -&gt; Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
data DataType aType bType hktBy1 ignored
  = NoArgs
  | Args Type1 Type2 Type3
  | FunctionArg (Type1 -&gt; Type2)
  | NestedArg (Box Int)
  | DoubleNestedArg (Box (Box Int))
  | HigherKindedGenericType1 (hktBy1 Int)
  | HigherKindedGenericType2 (hktBy1 aType)
  | Recursive (DataType aType bType hktBy1 ignored)
  | ArgMix Type_ (A -&gt; B) bType (DataType aType bType hktBy1 ignored)

-- Necessary for this to compile
type Type1 = Int
type Type2 = Int
type Type3 = Int
type Type_ = Int
type A = Int
type B = Int
type Arg1 = Int
type Arg2 = Int
type ArgN = Int
type ParameterType = Int
type ReturnType = Int
</code></pre>
<h1><a class="header" href="#05-pattern-matching-in-functionspurs" id="05-pattern-matching-in-functionspurs">05-Pattern-Matching-in-Functions.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.PatternMatching where

import Prelude

-- Given a data type like this:
data Fruit
  = Apple
  | Orange
  | Banana
  | Cherry
  | Tomato -- because why not!?

-- Pattern Matching: Basic idea and order of matching
mkString :: Fruit -&gt; String {-
         if the arg is _ = then return _ -}
mkString Apple           = &quot;apple&quot;

{-  else if the arg is _ = then return _ -}
mkString Orange          = &quot;orange&quot;

{-  else if the arg is _ = then return _ -}
mkString Banana          = &quot;banana&quot;

{-  else if the arg is _ = then return _ -}
mkString Cherry          = &quot;cherry&quot;

{-  else if the arg is _ = then return _ -}
mkString Tomato          = &quot;tomato&quot;

-- The above pattern match is &quot;exhaustive&quot; because there are no other
-- Fruit values against which one could match.

-- Pattern Matching: Literal values and catching all values

literalValue :: String -&gt; String
literalValue &quot;a&quot; = &quot;Return this string if arg is 'a'&quot;
literalValue &quot;b&quot; = &quot;Return this string if arg is 'b'&quot;
literalValue &quot;c&quot; = &quot;Return this string if arg is 'c'&quot;
literalValue _   = &quot;ignore input and return this default value&quot;

-- syntax sugar for pattern-matching literal arrays
array :: Array Int -&gt; String
array []           = &quot;an empty array&quot;
array [0]          = &quot;an array with one value that is 0&quot;
array [0, 1]       = &quot;an array with two values, 0 and 1&quot;
array [0, 1, a, b] = &quot;an array with four values, starting with 0 and 1 \
                       \ and binding the third and fouth to names 'a' and 'b'&quot;
array [-1, _ ]     = &quot;an array of two values, '-1' and another value that \
                       \ will not be used in the body of this function.&quot;
array _            = &quot;catchall for arrays. This is needed to make this \
                       \ example compile&quot;


-- Pattern Matching: Unwrapping Data Constructors
data A_Type
  = AnInt Int
  | Outer A_Type -- recursive type!
  | Inner Int

f :: A_Type -&gt; String {-
-- Syntax
f patternMatch = bodyToRunIfPatternWasMatched

  where 'patternMatch' is:
    - literal value
    - DataConstructorWithNoArgs
    - (DataConstructor withArgBoundToThisBinding)
    - (DataConstructor &quot;with arg whose value is this literal value&quot;)
    - bindingForEntireValue@(literalValue)
    - bindingForEntireValue@(DataConstructorWithNoArgs)
    - bindingForEntireValue@(DataConstructor withArgBoundToThisBinding)
    - bindingForEntireValue@(DataConstructor &quot;with arg whose value is this literal value&quot;)

-- Example

f the pattern match     = description of what was matched -}
f (Inner 0)             = &quot;a value of type Inner whose value is 0&quot;
f (Inner int)           = &quot;a value of type Inner, binding its value to 'int' \
                          \name for usage in function body&quot;
f (Outer (Inner int))   = &quot;a value of type Outer, whose Inner value is bound \
                          \to `int` name for usage in function body&quot;
f object@(AnInt 4)      = &quot;a value of type AnInt whose value is '4', \
                          \binding the entire object to the `object` name for \
                          \usage in function body&quot;
f _                     = &quot;ignores input and matches everything; \
                          \acts as a default / catch all case&quot;

-- Pattern Matching: Regular Guards
g :: Int -&gt; Int -&gt; String {-
g x y | condition1  = return this if condition1 is true
      | condition2  = return this if condition2 is true
      | ...         = ...
      | conditionN  = return this if conditionN is true
      | otherwise   = default case-}
g x y | x + y == 0 = &quot;x == -y&quot;
      | x - y == 0 = &quot;x == y&quot;
      | x * y == 0 = &quot;x == 0 || y == 0&quot;
      | otherwise = &quot;some other value&quot;

-- Pattern Matching: Single and Multiple Guards
h :: Int -&gt; Int -&gt; String
h x y | x == 4 &amp;&amp; y == 5 = &quot;body&quot;

   -- | condition1, condition2 = body
      | x == 4, y == 6   = &quot;body&quot;

  {-  ... or when using syntax sugar...
      | condition1
      , condition2 = body -}
      | x == 3
      , y == 2           = &quot;body&quot;

-- It's wise to separate mulitple guards with a blank line for readability.
      | otherwise        = &quot;default&quot;

-- Pattern Matching: Single Pattern Guard
j :: Int -&gt; String {-
j x | returnedValue &lt;- function arg1 arg2 argN = body if match occurs -}
j x | (Box 2) &lt;- toBox x = &quot;Calling toBox x returned a Box with 2 inside of it&quot;
    | (Box y) &lt;- toBox x = concat &quot;The 'y' value was: &quot; (toString y)

-- Pattern Matching: Multiple Pattern Guards
p :: Int -&gt; Int -&gt; String {-
p x y | returnedValue1 &lt;- functionCall1, returnedValue2 &lt;- functionCall2 = body -}
p x y | (Box 2) &lt;- toBox x, (Box 3) &lt;- toBox (x - 1) = &quot;without syntax sugar&quot;

 {-   ... or for easier reading, there is sugar syntax:
p x y | returnedValue1 &lt;- functionCall1
      , returnedValue2 &lt;- functionCall2 = body -}
      | (Box a) &lt;- toBox x
      , (Box b) &lt;- toBox (x * 2) = &quot;with syntax sugar&quot;

      | otherwise = &quot;some other value&quot;

-- Different guards can be mixed:
q :: Int -&gt; Int -&gt; String
q x y | x == 3                   = &quot;3&quot;
      | x == 5, y == 5           = &quot;5&quot;
      | (Box 2) &lt;- toBox x       = &quot;2?&quot;

      | (Box 2) &lt;- toBox x
      , y == 4                   = &quot;curious, no?&quot;

      | (Box a) &lt;- toBox x
      , (Box b) &lt;- toBox (y * 2) = &quot;something?&quot;

      | otherwise                = &quot;catch-all&quot;

-- necessary for this to compile
data Box a = Box a

toBox :: Int -&gt; Box Int
toBox 1 = Box 2
toBox _ = Box 0

concat :: String -&gt; String -&gt; String
concat left right = left &lt;&gt; right

toString :: forall a. Show a =&gt; a -&gt; String
toString = show
</code></pre>
<h1><a class="header" href="#01-typed-holespurs" id="01-typed-holespurs">01-Typed-Holes.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.SpecialCompilerFeatures.Holes where

{-

Original credit: @paf31 / @kritzcreek

Link: https://github.com/paf31/24-days-of-purescript-2016/blob/master/23.markdown

Changes made:
- use meta-language to explain syntax and give a few very simple examples

Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US

----------------------------------

Sometimes, when writing code, we're not always sure which function/value
we should use. In such cases, we can use a feature called
&quot;Typed Holes&quot; / &quot;Type Directed Search&quot; to ask the compiler to tell us
what it thinks should go there.

This feature can often be very helpful when debugging a compiler error
or when exploring a new library for the first time.

Syntax:
`?placeholderName`

Replace the function/value you want the compiler to suggest for you with
the above syntax.
-}

-- Note to self: don't delete this as functions from Prelude will be suggested below
import Prelude

warning :: String
warning =
  &quot;&quot;&quot;
  When we compile our code and it includes a hole,
  the compiler will output a compiler error.

  The error message will include the compiler's guess as to what should
  be put there.

  Since this outputs a compiler error, we have to comment out the following code
  to make this project build on Travis CI and on local computers

  Uncomment the following examples, one at a time, and then build the folder to
  see how it works
  &quot;&quot;&quot;

-- This example will show what the type signature for &quot;?placeholder_name&quot;
-- should be.

-- example1 :: Int -&gt; String
-- example1 i = ?placeholder_name i

-- Caveats: While this file has 2 &quot;holes,&quot; the second one will not be reported
-- by the compiler because it produces an error at the first hole. Thus,
-- this feature can only be used once in a project per compilation.

-- notice the infix notation used here via the backticks
-- example2 :: String
-- example2 = &quot;hello&quot; `?I_Don't_know` &quot; world&quot;

-- example3 :: Int
-- example3 = 1 + ?what_could_this_be
</code></pre>
<h1><a class="header" href="#02-typed-wildcardspurs" id="02-typed-wildcardspurs">02-Typed-Wildcards.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.SpecialCompilerFeatures.TypedWildcards where

{-
Sometimes, when writing code, we're not always sure what type something
should be in a type signature.

In such cases, we can use a feature called &quot;typed wildcards&quot;
to ask the compiler to tell us which type it thinks should go there.

This feature can often be very helpful when debugging a compiler error
or when exploring a new library for the first time.

Typed Wildcards can be either unnamed (&quot;_&quot;) or named &quot;?name&quot;.

Named typed wildcards will emit a compiler error whereas
unnamed typed wildcards will emit a compiler warning.
-}

someValue :: _ -- unnamed typed wildcard
someValue =
  &quot;&quot;&quot;
  The '_' character above is an unnamed typed wildcard
  It will produce a compiler warning whose message will include
  the compiler's guess as to what goes there.
  &quot;&quot;&quot;

-- Uncomment the below code and then rebuild the folder to see what happens

-- someValue2 :: ?TellMeTheType
-- someValue2 =
--   &quot;&quot;&quot;
--   The &quot;?name&quot; syntax above is a named typed wildcard.
--   It will produce a compiler error whose message will include
--   the compiler's guess as to which type goes there.
--   &quot;&quot;&quot;
</code></pre>
<h1><a class="header" href="#01-keyword--forallpurs" id="01-keyword--forallpurs">01-Keyword--Forall.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Keyword.Forall where

import Prelude

{-
When using generic data types in functions, such as the one below...
genericFunction0 :: a -&gt; a
  Read:
    Given a value of any type,
  this function will return a value of the same type. -}

-- ... we need to explicitly say the function works for all types.
-- We do so by adding the &quot;forall a.&quot; syntax to the front of our
-- type signature. Note: the &quot;forall&quot; syntax is still a part of our type
-- signature, but it always appears first before anything else.
genericFunction1 :: forall aType {- bType ... nType -}. aType -&gt; aType
genericFunction1 x = x
{- Read:
    For any type,
      which we'll refer to as, 'a',
  when given a value of type 'a',
then I will return a value of type 'a'
-}

genericFunction2 :: forall a b c. a -&gt; b -&gt; c -&gt; a
genericFunction2 a b c = a
{- Read:
    For any three types,
      which we'll refer to as, 'a', 'b', and 'c',
  when given
    a value of type 'a', and
    a value of type 'b', and
    a value of type 'c',
then I will return a value of type 'a'
-}

-- Sometimes, we'll see multiple 'forall' in the same type signature.
--
--    f :: forall a b. a -&gt; b -&gt; (forall c. c -&gt; String) -&gt; String
--
-- These are called &quot;Rank-N Types.&quot;
-- This means that the third argument, the function with `forall c`,
-- can be used on different types. Thus, we can write something like this:

ignoreArg_returnString :: forall a. a -&gt; String
ignoreArg_returnString _ = &quot;some string&quot;

example :: forall a b. a -&gt; b -&gt; (forall c. c -&gt; String) -&gt; String
example a b function = concat (function a) (function b)

testExample :: String
testExample = example true 5 ignoreArg_returnString

-- needed to compile

concat :: String -&gt; String -&gt; String
concat = append
</code></pre>
<h1><a class="header" href="#02-keyword--typepurs" id="02-keyword--typepurs">02-Keyword--Type.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Keyword.Type where

-- Syntax
type TypeAliasForCompileTime = RunTimeType

-- Example
type ComplexFunction = Int -&gt; (forall a b. a -&gt; (forall c. c-&gt; b) -&gt; b)

-- and then use it here:
-- someFunction :: String -&gt; ComplexFunction -&gt; ReturnType

-- One could also do this...
----------------------
type Age = Int

{-
functionName :: ParamType1 -&gt; ReturnType -}
functionName :: Age        -&gt; String
            -- 'Age' is a more descriptive type name than 'Int'
functionName age = &quot;body&quot;

----------------------
-- ... but to do the above, one should use `newtype` instead,
--   which is explained later.

-- a type alias can also take a type parameter
type ConvertAToString a = (a -&gt; String)

example :: forall a. a -&gt; ConvertAToString a -&gt; String
example a convertAToString = convertAToString a

-- Type aliases also have kind signatures. The above examples have
-- implicit kind signatures. The below example has an explicit one:
data Pair a b = Pair a b

-- kind signature (implicit): Type -&gt; Type
-- reason: the `a` needs to be defined before we have a &quot;concrete&quot; type alias
type IntAnd a = Pair Int a

type IntAnd_ExplicitKindSignature :: Type -&gt; Type
type IntAnd_ExplicitKindSignature a = Pair Int a

type SomeTypeAndInt :: Type -&gt; Type
type SomeTypeAndInt a = Pair a Int

-- required to get this to compile correctly
data RunTimeType
</code></pre>
<h1><a class="header" href="#03-keywords--case-expression-ofpurs" id="03-keywords--case-expression-ofpurs">03-Keywords--Case-expression-of.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Keyword.CaseOf where

import Prelude

-- Returning to our previous basic pattern match example:
data Fruit
  = Apple
  | Orange
  | Banana
  | Cherry
  | Tomato

-- The following is tedious to write due to rewriting 'mkString' on every line:
mkString :: Fruit -&gt; String
mkString Apple = &quot;apple&quot;
mkString Orange = &quot;orange&quot;
mkString Banana = &quot;banana&quot;
mkString Cherry = &quot;cherry&quot;
mkString Tomato = &quot;tomato&quot;

-- Fortunately, there is an easier way using 'case _ of' syntax:
function1 :: String -&gt; String
function1 expression =
  -- syntax
  case expression of
    -- pattern match -&gt; bodyOfFunctionIfMatched

    -- These show a few examples from pattern matching
    &quot;patternMatch1&quot; -&gt; bodyOfFunction
    &quot;patternMatch2&quot; -&gt; bodyOfFunction
    x | length x == 4 -&gt; bodyOfFunction    -- guards are also allowed here
      | length x == 5 -&gt; bodyOfFunction
    _ -&gt; bodyOfFunction -- catch all

-- If 'expression' is the next argument in a function, we could decide
-- to not bind to name (e.g. 'a') and instead use function abbreviation
-- using the underscore syntax:

data Data = Constructor1 | Constructor2 | Constructor3 | ConstructorN

function2 :: Data -&gt; String
function2 = case _ of
  Constructor1 -&gt; bodyOfFunction
  Constructor2 -&gt; bodyOfFunction
  Constructor3 -&gt; bodyOfFunction
  _ -&gt; bodyOfFunction -- catch all


-- Returning to our example
mkString2 :: Fruit -&gt; String
mkString2 = case _ of
  Apple -&gt; &quot;apple&quot;
  Orange -&gt; &quot;orange&quot;
  Banana -&gt; &quot;banana&quot;
  Cherry -&gt; &quot;cherry&quot;
  Tomato -&gt; &quot;tomato&quot;

-- We can also match multiple expressions by adding commas between them:
-- Syntax:
function3 :: String -&gt; String -&gt; String
function3 firstExpression secondExpression =
  case firstExpression, secondExpression {-, nExpression -} of
    &quot;firstResultPatternMatch&quot;, &quot;secondResultPM&quot; {-, nResult -} -&gt; bodyOfFunction
    &quot;firstResultPatternMatch&quot;, &quot;secondResultPM&quot; {-, nResult -} -&gt; bodyOfFunction
    _, _ -&gt; bodyOfFunction -- catchall

-- example
mkString3 :: Fruit -&gt; Fruit -&gt; String
mkString3 a b = case a, b of
  Apple, Apple -&gt; &quot;Two apples&quot;
  Apple, Cherry -&gt; &quot;An apple and a cherry&quot;
  _, _ -&gt; &quot;You didn't really think I would type out all of them, did you?!?&quot;

-- This compiles: Pattern Matching -&gt; Case -&gt; Pattern guard
test :: Int -&gt; Boolean
test a
  | false =
      case false of
        true | a &gt; 12 -&gt; true
        _ -&gt; false
  | otherwise = true

-- Necessary to get this file to compile
length :: String -&gt; Int
length _ = 4

bodyOfFunction :: String
bodyOfFunction = &quot;body of function&quot;
</code></pre>
<h1><a class="header" href="#04-keywords--where-and-let-inpurs" id="04-keywords--where-and-let-inpurs">04-Keywords--Where-and-Let-In.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Keyword.WhereAndLetIn where

import Prelude

data Box a = Box a
{-
The 'let..in' keywords and the `where` keyword enables us to break large
  functions down into smaller functions (or values) that compose.             -}

{-
The 'let...in' syntax lets us define &quot;bindings&quot; before we use them
in the block that follows the `in` keyword: -}
letInFunction1 :: String -&gt; String
letInFunction1 expression =
  let
    -- Start of the &quot;let&quot; block
    binding = expression
    -- End of the &quot;let&quot; block
  in
    -- Start of the &quot;in&quot; block
    somethingThatUses binding -- wherever `binding` is used, we mean `expression`
    -- End of the &quot;in&quot; block

{-
We can define multiple bindings. Earlier bindings cannot refer to later
bindings, but later ones can refer to earlier ones. -}
letInFunction2 :: String -&gt; String -&gt; String
letInFunction2 expression1 expression2 =
  let
    -- Start of the &quot;let&quot; block
    binding1 = expression1
    binding2 = expression2
    binding3 = binding1
    -- End of the &quot;let&quot; block
  in
    -- Start of the &quot;in&quot; block
    somethingThatUses (binding1 &lt;&gt; binding2 &lt;&gt; binding3)
    -- End of the &quot;in&quot; block

letInFunction2_WithTypeSignatures :: String -&gt; String -&gt; String
letInFunction2_WithTypeSignatures expression1 expression2 =
  let
    -- we can also add type signatures above the bindings to help with
    -- readability or type inference.
    binding1 :: String
    binding1 = expression1

    binding2 :: String
    binding2 = expression2
  in
    somethingThatUses (binding1 &lt;&gt; binding2)

-- One can also define functions as a let binding
letInFunction3 :: String -&gt; String
letInFunction3 value =
  let
    function &quot;firstMatch&quot;  = bodyOfPatternMatch
    function &quot;secondMatch&quot; = bodyOfPatternMatch
    function catchAll      = bodyOfPatternMatch
  in
    function value

letInFunction3_WithTypeSignatures :: String -&gt; String
letInFunction3_WithTypeSignatures value =
  let
    function :: String -&gt; String
    function &quot;firstMatch&quot;  = bodyOfPatternMatch
    function &quot;secondMatch&quot; = bodyOfPatternMatch
    function catchAll      = bodyOfPatternMatch
  in
    function value

-- One can also use guards with let
letWithGuards :: Int -&gt; String
letWithGuards x =
  let result
        | x == 0 = &quot;zero&quot;
        | x == 1 = &quot;one&quot;
        | otherwise = &quot;something else&quot;
  in computeSomethingWithString result

-- Let bindings can also have type signatures. We'll see in the next file
-- why this can be very important.
letWithGuards_WithTypeSignatures :: Int -&gt; String
letWithGuards_WithTypeSignatures x =
  let
    result :: String
    result
          | x == 0 = &quot;zero&quot;
          | x == 1 = &quot;one&quot;
          | otherwise = &quot;something else&quot;
  in computeSomethingWithString result

{-
The `where` clause is &quot;syntax sugar&quot; for let bindings.
Using the `where` clause, we could rewrite the below function using the
`where` clause
    whereFunction0 = let x = 4 in x        -}
whereFunction0 :: Int
whereFunction0 = x
  where
  x = 4

-- Here is a more typical example where multiple bindings are defined
-- in a single &quot;where block&quot;
whereFunction1 :: String -&gt; String -&gt; Int
whereFunction1 arg1 arg2 =
  returnFour (madeUpFunction arg1 arg2) 9

  where
  -- functions defined below the 'where' keyword can be used in the main
  -- function and any other made-up functions defined in this block
  madeUpFunction :: String -&gt; String -&gt; Int
  madeUpFunction s1 s2 =
    returnFour (createComplexDataTypeUsing s1)
      (mutuallyRecursiveFunction1 s2)

  createComplexDataTypeUsing :: String -&gt; Box String
  createComplexDataTypeUsing s = Box s

  -- Note: If 'whereFunction1' had used 'forall' syntax above to specify
  -- generic types, we would not need to respecify them in any made-up functions
  -- that appear in this where block. However, since we want `returnFour` to work
  -- for multiple types, we'll need to specify that here.
  returnFour :: forall a b. a -&gt; b -&gt; Int
  returnFour _ _ = 4

  -- Mutually recursive functions are allowed
  mutuallyRecursiveFunction1 :: String -&gt; String
  mutuallyRecursiveFunction1 &quot;a&quot; = &quot;a&quot;
  mutuallyRecursiveFunction1 x = mutuallyRecursiveFunction2 (x &lt;&gt; &quot;b&quot;) -- &quot;&lt;&gt;&quot; means concat

  mutuallyRecursiveFunction2 :: String -&gt; String
  mutuallyRecursiveFunction2 &quot;b&quot; = mutuallyRecursiveFunction1 &quot;b&quot;
  mutuallyRecursiveFunction2 x = mutuallyRecursiveFunction1 &quot;a&quot;

{-
See the indentation rules to correctly indent your `where` clause
  and the expressions that define a given binding.
-}

-- necessary to make this file compile:

somethingThatUses :: String -&gt; String
somethingThatUses x = x

bodyOfPatternMatch :: String
bodyOfPatternMatch = &quot;body of pattern match&quot;

computeSomethingWithString :: String -&gt; String
computeSomethingWithString _ = &quot;string value&quot;
</code></pre>
<h1><a class="header" href="#05-indentation-rulespurs" id="05-indentation-rulespurs">05-Indentation-Rules.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.IndentationRules where

import Prelude

-- Indentation Rules:

function_normal :: String -&gt; String
function_normal a = bodyOfFunction

function_body_indented :: String -&gt; String
function_body_indented a = {- this shows valid and invalid indentation:
wrongIndentation -}
  validAndConventional &lt;&gt;
    validButNotConventional {-
      and so forth... -}

whereFunction1 :: String -&gt; String
whereFunction1 a = validFunctionPosition1 &lt;&gt; validFunctionPosition2 &lt;&gt; validValuePosition
  where
  validFunctionPosition1 :: TypeSignature
  validFunctionPosition1 = &quot;a&quot;

  validFunctionPosition2 :: TypeSignature
  validFunctionPosition2 = &quot;b&quot;

  validValuePosition :: TypeSignature
  validValuePosition = &quot;c&quot;

whereFunction2 :: String -&gt; String
whereFunction2 a = validFunctionPosition1 &lt;&gt; validFunctionPosition2 &lt;&gt; validValuePosition
  where
    validFunctionPosition1 :: TypeSignature
    validFunctionPosition1 = &quot;a&quot;

    validFunctionPosition2 :: TypeSignature
    validFunctionPosition2 = &quot;b&quot;

    validValuePosition :: TypeSignature
    validValuePosition = &quot;c&quot;

letInFunction1 :: String -&gt; String
letInFunction1 expression =
  -- this format makes it harder to add a new binding if more are needed
  let binding = expression
  in bodyOfFunctionThatUses binding

letInFunction2 :: String -&gt; String
letInFunction2 expression =
  -- this format makes it easy to add a new binding
  let
    binding = expression                                                    {-
    binding2 = some other expression                                        -}
  in
    bodyOfFunctionThatUses binding

-- See the `do` notation syntax for how to use `let` properly there

-- Necessary to make this file compile
type TypeSignature = String

bodyOfFunctionThatUses :: String -&gt; String
bodyOfFunctionThatUses x = x

bodyOfFunction :: String
bodyOfFunction = &quot;&quot;

validAndConventional :: String
validAndConventional = &quot;&quot;

validButNotConventional :: String
validButNotConventional = &quot;&quot;
</code></pre>
<h1><a class="header" href="#06-let-lacks-generalizationpurs" id="06-let-lacks-generalizationpurs">06-Let-Lacks-Generalization.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.LetLacksGeneralization where

import Prelude

{-
We saw previously that we can define functions inside a `let` binding
and use it later after the `in`. The below example does NOT have a type
signature annotating it.                                                      -}
letBindingExample :: Int
letBindingExample =
  let
    add4 x = x + 4
  in add4 6 -- outputs 10

{-
We also saw that we can add type signatures to the `let` binding
to make it easier to read:                                                    -}
letBindingExampleWithTypeSignature :: Int
letBindingExampleWithTypeSignature =
  let
    add4 :: Int -&gt; Int
    add4 x = x + 4
  in add4 6

{-
All of the above examples use monomorphism (i.e. each function only works
on 1 type / there IS NOT a &quot;forall&quot; anywhere), not polymorphism
(i.e. each function works on multiple types / there IS a &quot;forall&quot; somewhere).
In some situations, we may want to use polymorphism/&quot;forall&quot; in our
`let` bindings:                                                             -}
letBindingWithPolymorphicTypeSignature :: Int
letBindingWithPolymorphicTypeSignature =
  let
    ignoreArgumentAndReturn4 :: forall a. a -&gt; Int
    ignoreArgumentAndReturn4 _ = 4
  in
    (ignoreArgumentAndReturn4 8) + (ignoreArgumentAndReturn4 &quot;foo&quot;)

{-
In the above example, when you remove the type signature above the let binding,
you will discover that &quot;`let` bindings lack generalization&quot;. The below example
will not compile. You can uncomment it and see for yourself:                  -}
-- failsToCompile :: Int
-- failsToCompile =
--   let
--     -- based on the usage below, it would appear that this function's
--     -- type signature is &quot;forall a. a -&gt; Int&quot;
--     polymorphicLetBindingWithNoTypeSignature _ = 4
--   in
--     (polymorphicLetBindingWithNoTypeSignature 8) +   -- argument is Int
--     (polymorphicLetBindingWithNoTypeSignature &quot;foo&quot;) -- argument is String

{-
Running `failsToCompile` will produce the following error:

  Error found:
  in module Syntax.Basic.LetLacksGeneralization
  at src/04-Various-Keywords/05-Let-Lacks-Generalization.purs:48:34 - 48:39 (line 48, column 34 - line 48, column 39)

    Could not match type

      String

    with type

      Int


  while checking that type String
    is at least as general as type Int
  while checking that expression &quot;foo&quot;
    has type Int
  in value declaration failsToCompile

  See https://github.com/purescript/documentation/blob/master/errors/TypesDoNotUnify.md for more information,
  or to contribute content related to this error.
-}

{-
When the compiler comes across the first usage of
`polymorphicLetBindingWithNoTypeSignature`, the type of the first argument, 8,
is Int. Rather than making this binding polymorphic, the compiler assumes
that the function is monomorphic and its type signature will be
&quot;Int -&gt; Int&quot;. Thus, when it encounters the second usage of the function,
`polymorphicLetBindingWithNoTypeSignature &quot;foo&quot;`, it fails because
`String` is not the same type as `Int`.

This missing feature is called &quot;`let` generalization.&quot; Its absence is
intentional. For more context, see the paper titled,
&quot;Let should not be generalized&quot;
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tldi10-vytiniotis.pdf
-}

{-
Since the `where` clause is syntax sugar for `let` bindings, this issue can
also arise when you use bindings in the `where` clauses that are polymorphic
and do not have a type signature.
-}

-- alsoFailsToCompile :: Int
-- alsoFailsToCompile =
--     (polymorphicFunctionWithNoTypeSignature 8) + -- argument is Int
--     (polymorphicFunctionWithNoTypeSignature &quot;foo&quot;)
--
--     where
--       polymorphicFunctionWithNoTypeSignature _ = 4

-- This version will compile because the type signature
-- has been specified.
polymorphicWhereClauseWithTypeSignature :: Int
polymorphicWhereClauseWithTypeSignature =
    (polymorphicFunctionWithTypeSignature 8) + -- argument is Int
    (polymorphicFunctionWithTypeSignature &quot;foo&quot;)

    where
      polymorphicFunctionWithTypeSignature :: forall a. a -&gt; Int
      polymorphicFunctionWithTypeSignature _ = 4
</code></pre>
<h1><a class="header" href="#07-keywords--if-then-elsepurs" id="07-keywords--if-then-elsepurs">07-Keywords--If-Then-Else.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Keyword.IfThenElse where

-- There's support for if-then-else statements
test1 :: Boolean -&gt; String
test1 condition = if condition then &quot;true path&quot; else &quot;false path&quot;

-- Or write it like this
test2 :: Boolean -&gt; String
test2 condition =
  if condition
  then &quot;true path&quot;
  else &quot;false path&quot;

-- Or this
test3 :: Boolean -&gt; String
test3 condition =
  if
    condition
  then
    &quot;true path&quot;
  else
    &quot;false path&quot;

-- One can also write nested if-then-else-if-then-else statements
test4 :: forall a. (a -&gt; Boolean) -&gt; (a -&gt; Boolean) -&gt; a -&gt; String
test4 condition1 condition2 a =
  if condition1 a then &quot;first path&quot;
  else if condition2 a then &quot;second path&quot;
  else &quot;default path&quot;
</code></pre>
<h1><a class="header" href="#01-basic-syntaxpurs" id="01-basic-syntaxpurs">01-Basic-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Record.Basic where

import Prelude

-- Records have a different kind than &quot;Type&quot;
-- Their kind signature is `Row Type -&gt; Type`.

-- `Row` kinds are 0 to N number of &quot;label-to-kind&quot; associations
-- that are known at compile time. `Row` kinds will be covered more fully
-- in the Type-Level Programming Syntax folder.
-- Most of the time, you will see the labels associated with the kind, `Type`.
-- In other words:
type Example_Row = (rowLabel :: ValueType)

-- Rows can have 1 or many label-Type associations...
type Example_of_a_Single_Row = (labelName :: ValueType)
type Example_of_a_Multiple_Rows = (first :: ValueType, second :: ValueType)

type PS_Keywords_Can_Be_Label_Names =
  (data :: ValueType, type :: ValueType, class :: ValueType)

-- Rows can also have kind signatures. The right-most entity/kind
-- will be `Row Type`:
type SingleRow_KindSignature :: Row Type
type SingleRow_KindSignature = (labelName :: ValueType)

type MultipleRows_KindSignature :: Row Type
type MultipleRows_KindSignature = (first :: ValueType, second :: ValueType)

-- Rows can also be empty.
type Example_of_an_Empty_Row :: Row Type
type Example_of_an_Empty_Row = ()

-- Rows can take type parameters just like data, type, and newtype:
type Takes_A_Type_Parameter :: Type -&gt; Row Type
type Takes_A_Type_Parameter a = (someLabel :: Box a)

-- That's enough about rows for now.
-- Let's see why they are useful for Records.

data Record_ -- Row Type -&gt; Type

-- Think of records as a JavaScript object / HashMap / big product types.
-- There are keys (the labels) that refer to values of a given type.
type RecordType_Desugared = Record ( label1 :: String
                                -- , ...
                                   , labelN :: Int
                                   , function :: (String -&gt; String)
                                   )
-- However, there is syntax sugar for writing this:
-- &quot;Record ( rows )&quot; becomes &quot;{ rows }&quot;
type RecordType = { label1 :: String
               -- , ...
                  , labelN :: Int
                  , function :: String -&gt; String
                  }

-- ## Create Records

-- We can create a record using the &quot;{ label: value }&quot; syntax...
createRec_colonSyntax :: RecordType
createRec_colonSyntax = { label1: &quot;value&quot;, labelN: 1, function: (\x -&gt; x) }

-- We can also create it using the &quot;names exist in immediate context&quot; syntax

createRec_immediateContextSyntax :: RecordType
createRec_immediateContextSyntax = { label1, labelN, function }
  where
    label1 = &quot;value&quot;
    labelN = 1
    function = \x -&gt; x

-- We can also create it using the &quot;label names exist in external context&quot; syntax
-- Given the below record type...
type PersonRecord = { username :: String
                    , age :: Int
                    , isCool :: String -&gt; Boolean
                    }
-- ... and some values/functions with the same name as that record's labels...
username :: String
username = &quot;Bob&quot;

age :: Int
age = 4

isCool :: String -&gt; Boolean
isCool _ = true

-- ... the compiler will infer below that 'username' should be &quot;Bob&quot;
-- because `username` is a value that exists in this module.
-- Note: this syntax won't pick up things that exist in other files.
createRec_externalContextSyntax :: PersonRecord
createRec_externalContextSyntax = { username, age, isCool }

createRec_noUnderscore :: String -&gt; Int -&gt; (String -&gt; String) -&gt; RecordType
createRec_noUnderscore label1 labelN function = { label1, labelN, function }

createRec_withUnderscore :: String -&gt; Int -&gt; (String -&gt; String) -&gt; RecordType
createRec_withUnderscore = { label1: _, labelN: _, function: _ }

-- same type signature as 'createRec_withUnderscore'
type InlineWithUnderscoreType = String -&gt; Int -&gt; (String -&gt; String) -&gt; RecordType

inlineExample1 :: InlineWithUnderscoreType
inlineExample1 =
  \label1 labelN function -&gt; { label1: label1, labelN: labelN, function: function }

inlineExample2 :: InlineWithUnderscoreType
inlineExample2 =             { label1: _     , labelN: _     , function: _      }

-- ## Get the corresponding values in records

getLabel1 :: RecordType -&gt; String
getLabel1 obj = obj.label1

-- ## Overwrite Labels' Values in Records

-- We can update a record using syntax sugar:
overwriteLabelValue_equalsOperator :: RecordType -&gt; String -&gt; RecordType
overwriteLabelValue_equalsOperator rec string = rec { label1 = string }

-- or by using an underscore to indicate that the next argument is the
-- record type
setLabelValue_recordUnderscore :: String -&gt; RecordType -&gt; RecordType
setLabelValue_recordUnderscore string = _ { label1 = string }                      {-

setLabelValue_recordUnderscore &quot;bar&quot; { label1: &quot;foo&quot; } == { label1: &quot;bar&quot; }        -}

-- or by using an underscore for both args if they come in the correct order:
-- record first and then the argument to apply to that record's label
setLabelValue_recordAndArgUnderscore :: RecordType -&gt; String -&gt; RecordType
setLabelValue_recordAndArgUnderscore = _ { label1 = _ }                            {-

setLabelValue_recordAndArgUnderscore { label1: &quot;foo&quot; } &quot;bar&quot; == { label1: &quot;bar&quot; }  -}

syntaxReminder :: String
syntaxReminder = &quot;&quot;&quot;

Don't confuse the two operators that go in-between label and value!

&quot;label OPERATOR value&quot; where OPERATOR is
  &quot;=&quot; means &quot;update the label of a record that already exists&quot;:
          record { label = newValue }
  &quot;:&quot; means &quot;create a new record by specifying the label's value&quot;:
                 { label: initialValue }
&quot;&quot;&quot;

-- ## Nested Records

type NestedRecordType = { person :: { skills :: { name :: String } } }

nestedRecord_create :: String -&gt; NestedRecordType
nestedRecord_create newName = { person: { skills: { name: newName } } }

nestedRecord_get :: NestedRecordType -&gt; String
nestedRecord_get rec = rec.person.skills.name

nestedRecord_overwrite1 :: String -&gt; NestedRecordType -&gt; NestedRecordType
nestedRecord_overwrite1 newName p  = p { person { skills { name = newName } } }

nestedRecord_overwrite2 :: String -&gt; NestedRecordType -&gt; NestedRecordType
nestedRecord_overwrite2 newName    = _ { person { skills { name = newName } } }

-- -- This fails to compile!
-- nestedRecord_overwrite3 :: String -&gt; NestedRecordType -&gt; NestedRecordType
-- nestedRecord_overwrite3            = _ { person { skills { name = _       } } }

-- -- This fails to compile
-- nestedRecord_overwrite4 :: String -&gt; NestedRecordType -&gt; NestedRecordType
-- nestedRecord_overwrite4            = _ { _      { _      { name = _       } } }

-- ## Pattern Matching on Records

-- We can also pattern match on a record. The label names must match
-- the label names of the record
patternMatch_allLabels :: Int
patternMatch_allLabels =
  let { label1, label2 } = { label1: 3, label2: 5 }
  in label1 + label2

patternMatch_someLabels :: String
patternMatch_someLabels =
  -- notice how we don't include 'label2' here
  -- in the pattern match
  let { label1 } = { label1: &quot;a&quot;, label2: &quot;b&quot; }
  in label1

-- needed to compile
type ValueType = String
data Box a = Box a
</code></pre>
<h1><a class="header" href="#02-quoted-key-syntaxpurs" id="02-quoted-key-syntaxpurs">02-Quoted-Key-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Record.Quoted where

-- Credit goes to Justin Woo where I found out this documentation
-- was even possible:
-- https://github.com/justinwoo/quoted-record-property/blob/master/src/Main.purs

type QuotedKey = { &quot;key&quot; :: String }

creation :: QuotedKey
creation = { &quot;key&quot; : &quot;value&quot; }

getValue :: String
getValue = creation.&quot;key&quot;

emojiKey :: String
emojiKey = { &quot;&quot; : &quot;value&quot; }.&quot;&quot;

asianLanguageKey :: String
asianLanguageKey = { &quot;&quot; : &quot;Japanese&quot; }.&quot;&quot;
</code></pre>
<h1><a class="header" href="#03-row-polymorphismpurs" id="03-row-polymorphismpurs">03-Row-Polymorphism.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Record.RowPolymorphism where

import Prelude

-- We can also use literal records in our function type signatures:
getName1 :: { name :: String } -&gt; String
getName1 { name: nameValue } = nameValue

getName2 :: { name :: String } -&gt; String
getName2 person = person.name -- this syntax also works

-- example
test1 :: Boolean
test1 =
  (getName1 { name: &quot;hello&quot; }) == &quot;hello&quot;

{-
However, this definition does not allow additional fields.
The following code...

  getName1 { name: &quot;hello&quot;, age: 4 }

...will output a compiler error since no other fields are allowed!
-}

{-
Rows can either be &quot;closed&quot; or &quot;open.&quot; &quot;Closed&quot; rows means that we will
not be adding any other 'fields' to it at a later time. So far, we
have only shown examples of &quot;closed&quot; rows.
&quot;Open&quot; rows means that we might add more 'fields' to it at a later time.
We'll now show the syntax for that.
-}

-- open rows
type Example_of_Closed_Row              = (first :: ValueType)
type Example_of_Open_Row additionalRows = (first :: ValueType | additionalRows)

type Closed_Record1 = Record (first :: ValueType)
type Open_Record1 r = Record (first :: ValueType | r)

type Closed_Record2 = { first :: ValueType }
type Open_Record2 r = { first :: ValueType | r}

type OpenRecord1 rowsAreDefinedLater = Record ( | rowsAreDefinedLater)
type OpenRecord2 rowsAreDefinedLater = { | rowsAreDefinedLater}

{-
We can get rid of the compiler error by using open rows and row polymorphism

The below function can be read as
    &quot;Given a record that has the field, 'name',
     and zero or more other rows I don't care about,
  I can give you a String value.&quot;                                            -}
rowPolymorphism1 :: forall anyOtherFieldsThatMayExist
                  . { name :: String | anyOtherFieldsThatMayExist }
                 -&gt; String
rowPolymorphism1 { name: nameValue } = nameValue

-- Rather than the &quot;anyOtherFieldsThatMayExist&quot; type name, convention is to
-- use &quot;r&quot; for &quot;rows&quot;. Rewriting our above function to use 'r' convention:
getName4 :: forall r. { name :: String | r } -&gt; String
getName4 { name: nameValue } = nameValue

-- examples
test2 :: Boolean
test2 =
  (getName4 { name: &quot;a name&quot;, age: 4, stuff: &quot;?&quot; }) == &quot;a name&quot; -- now it works!

-- A compiler error will arise when the required field doesn't exist,
-- such as this example:
--
--    getName4 { age: 4, stuff: &quot;?&quot; }


-- needed to compile
type ValueType = String
</code></pre>
<h1><a class="header" href="#01-regularpurs" id="01-regularpurs">01-Regular.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.InfixNotation.Regular where

import Prelude

two_arg_function :: Int -&gt; Int -&gt; Int
two_arg_function x y | x &lt; 0 = (x + 1) * (y + 14)
                     | otherwise = y + x

infix_notation :: Int
infix_notation =
  -- infix notation available via backticks
  (1 `two_arg_function` 2)
  -- becomes two_arg_function 1 2

data List a = Nil | Cons a (List a)
data Box a = Box a

-- Some types given here to make things easier...
type TypeAlias = forall a b. List a -&gt; Box b
data DataType = Constructor Int Int

{-
Infix Syntax:
infix/infixl/infixr precedence function/constructor as symbolicAlias

... or for type aliases:
infix/infixl/infixr precedence type TypeName as symbolicAlias

... where 'precedence' is a number (0..9)
    and 'symbolicAlias' is a sequence of symbolic character(s)
      (i.e. cannot use alphanumeric characters, nor an underscore character)
-}

-- Example
infixl 4 two_arg_function as &gt;&gt;
infix  2 Constructor as ?-&gt;
infix  4 type TypeAlias as :$&gt;

mostCharactersForSymbolicAlias :: forall a. a -&gt; a
mostCharactersForSymbolicAlias x = x

-- Notes:
-- 1. '@', '\', and '.' cannot be used alone (see next comment)
-- 2. the below symbols are the ones you will typically see. However,
--      characters where Haskell's `isSymbol` returns true also work.
--      (https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#v:isSymbol)
infix 4 mostCharactersForSymbolicAlias as ~!@#$%^&amp;*-+=\|:&lt;&gt;./?

{-
These characters, when used individually as aliases, are illegal:
  infix 4 illegalAlias1 as \
                           ^ That's reserved for lambdas
  infix 4 illegalAlias2 as @
                           ^ That's reserved for pattern matching: a@(Foo 1)

  infix 4 illegalAlias3 as .
                           ^ That's reserved for record-related things: foo.bar
-}
-- When used with more characters than themselves, they're fine and compile.
whenMultipleExist_itsFine :: forall a. a -&gt; a
whenMultipleExist_itsFine x = x

infix 4 whenMultipleExist_itsFine as \\
infix 4 whenMultipleExist_itsFine as @@
infix 4 whenMultipleExist_itsFine as ..
infix 4 whenMultipleExist_itsFine as \.
infix 4 whenMultipleExist_itsFine as .@

-- Infix is all about where to put the parenthesis as indicated by precedence:
-- precedence is 0 = group first
--               n = group after first but before last
--               9 = group last
--
-- Each type of infix will be shown by reducing it to its final call

-- make depth small (like a tree)
-- infix 0 concatString as $$$$$

{-  &quot;a&quot; $$$$$ &quot;b&quot;  $$$$$  &quot;c&quot; $$$$$ &quot;d&quot;
== (&quot;a&quot; $$$$$ &quot;b&quot;) $$$$$ (&quot;c&quot; $$$$$ &quot;d&quot;))
== ($$$$$ &quot;a&quot; &quot;b&quot;) $$$$$ ($$$$$ &quot;c&quot; &quot;d&quot;))
== concatString (concatString &quot;a&quot; &quot;b&quot;) (concatString &quot;c&quot; &quot;d&quot;)  -- desugared
-}

-- infixl 9 concatString as |&gt;&gt;|

{-    &quot;a&quot; |&gt;&gt;| &quot;b&quot;  |&gt;&gt;| &quot;c&quot;  |&gt;&gt;| &quot;d&quot;
==   (&quot;a&quot; |&gt;&gt;| &quot;b&quot;) |&gt;&gt;| &quot;c&quot;  |&gt;&gt;| &quot;d&quot;
==  ((&quot;a&quot; |&gt;&gt;| &quot;b&quot;) |&gt;&gt;| &quot;c&quot;) |&gt;&gt;| &quot;d&quot;
== |&gt;&gt;| ((&quot;a&quot; |&gt;&gt;| &quot;b&quot;) |&gt;&gt;| &quot;c&quot;) &quot;d&quot;
== |&gt;&gt;| (|&gt;&gt;| (&quot;a&quot; |&gt;&gt;| &quot;b&quot;) &quot;c&quot;) &quot;d&quot;
== |&gt;&gt;| (|&gt;&gt;| (|&gt;&gt;| &quot;a&quot; &quot;b&quot;) &quot;c&quot;) &quot;d&quot;
== concatString (concatString (concatString &quot;a&quot; &quot;b&quot;) &quot;c&quot;) &quot;d&quot;
-}

-- infixr 7 concatString as |&lt;&lt;|

{- &quot;a&quot; |&lt;&lt;|  &quot;b&quot; |&lt;&lt;|  &quot;c&quot; |&lt;&lt;| &quot;d&quot;
== &quot;a&quot; |&lt;&lt;|  &quot;b&quot; |&lt;&lt;| (&quot;c&quot; |&lt;&lt;| &quot;d&quot;)
== &quot;a&quot; |&lt;&lt;| (&quot;b&quot; |&lt;&lt;| (&quot;c&quot; |&lt;&lt;| &quot;d&quot;))
== |&lt;&lt;| &quot;a&quot; (&quot;b&quot; |&lt;&lt;| (&quot;c&quot; |&lt;&lt;| &quot;d&quot;))
== |&lt;&lt;| &quot;a&quot; (|&lt;&lt;| &quot;b&quot; (&quot;c&quot; |&lt;&lt;| &quot;d&quot;))
== |&lt;&lt;| &quot;a&quot; (|&lt;&lt;| &quot;b&quot; (|&lt;&lt;| &quot;c&quot; &quot;d&quot;))
== concatString &quot;a&quot; (concatString &quot;b&quot; (concatString &quot;c&quot; &quot;d&quot;))
-}
</code></pre>
<h1><a class="header" href="#02-extendedpurs" id="02-extendedpurs">02-Extended.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.InfixNotation.Extended where

-- Original credit: @paf31
-- Link: https://github.com/paf31/24-days-of-purescript-2016/blob/master/1.markdown
-- Changes made: use meta-language to explain syntax of extended infix notation
--
-- Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
--   https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US

-- regular infix
-- function1 :: Type1 -&gt; Type2 -&gt; ReturnType
-- function1 a b = ...
--
-- a `function1` b

-- Given a function with this signature...
function2 :: String -&gt; String -&gt; String -&gt; String
function2 first second third = &quot;result&quot;

example :: String
example = &quot;second&quot; `function2 &quot;first&quot;` &quot;third&quot;

-- This can be useful for combining function if it reads well
--    list1 `combineUsing concat` list2
-- But it can also quickly lead to unreadable code
-- Be careful and selective when using it.
</code></pre>
<h1><a class="header" href="#07-functions-and-data-with-higher-kinded-typespurs" id="07-functions-and-data-with-higher-kinded-typespurs">07-Functions-and-Data-with-Higher-Kinded-Types.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Function.HigherKindedTypes where

import Prelude

-- == Review ==
data Box a = Box a
-- `Box a` is a higher-kinded type (HKT). In other words,
-- it has a kind of `Type -&gt; Type`, not `Type` like Int.
-- Its 'a' still needs to be specified before it is fully concrete.

-- we can define a function when the 'a' of Box is known (&quot;Int&quot; in this case)...
add1 :: Box Int -&gt; Box Int
add1 (Box x) = Box (x + 1)

-- we can also define a function when 'a' of Box is not known
modify :: forall a. Box a -&gt; (a -&gt; a) -&gt; Box a
modify (Box a) function = Box (function a)

-- However, how might one write a function that works on all of
-- the four types below? In other words, how would we define a function
-- when we know we will have a higher-kinded type like `Box`, but
-- we don't know the exact type of that Box-like type?

data Box1 a = Box1 a
data Box2 a = Box2 a
data Box3 a = Box3 a
data Box4 a = Box4 a

-- The following function shows the syntax to follow.
hktFunction0 :: forall f a. f a -&gt; f a
hktFunction0 boxN = boxN
{-
Read
  &quot;f a&quot;
as
  &quot;f is a higher-kinded type
    that needs one type, `a`, specified
    before it can be a concrete type&quot;

When using higher-kinded types, convention is to start with `f` and continue
down the alphabet for each higher-kinded type thereafter (e.g. `g`, `h`, etc.). -}

hktFunction1 :: forall f g h a. f a -&gt; g a -&gt; h a -&gt; h a
hktFunction1 _ _ hOfA = hOfA

-- I think the convention of using 'f' has something to do with a Type Class
-- called Functor (covered in the Hello-World folder).


-- If the higher-kinded type we want to include in our function takes more than
-- one type, we just add the extra types beyond it
data HigherKindedTypeWith4Types a b c d = Constructor a b c d

hktFunction2 :: forall f a b c d. f a b c d -&gt; f a b c d
hktFunction2 f_abcd = f_abcd
{-
Read the above
  &quot;f a b c d&quot;
as
  &quot;f is a higher-kinded type
     that takes 4 types, 'a', 'b', 'c', and 'd',
     all of which need to be specified
     before 'f' can be a concrete type&quot;
-}

-- We can also specify specific types in the function:
hktFunction3 :: forall f a b c. f a b c Int -&gt; f a b c Int
hktFunction3 f_abc_Int = f_abc_Int
{-
Read
  &quot;f a b c Int&quot;
as
  &quot;f is a higher-kinded type
    that takes 4 types, 'a', 'b', 'c', and 'd'.

  'd' has already been specified to 'Int',
    but
  the other types (a, b, and c) have yet to be specified.

  The compiler will complain
    if one passes in an 'f' type whose fourth type is not an Int.
-}


-- Returning to our previous question...
boxFunction :: forall f a. f a -&gt; (f a -&gt; a) -&gt; (a -&gt; a) -&gt; (a -&gt; f a) -&gt; f a
boxFunction boxN unwrap changeA rewrap =
  rewrap (changeA (unwrap boxN))
-- The unwrap and rewrap functions in the above function are only needed to make
-- this compile. In many functions, they won't be needed due to
-- typeclasses (explained later).

-- If we specified functions like below for each of the box type...
unwrapBox2 :: forall a. Box2 a -&gt; a
unwrapBox2 (Box2 a) = a

unwrapBox3 :: forall a. Box3 a -&gt; a
unwrapBox3 (Box3 a) = a

rewrapBox2 :: forall a. a -&gt; Box2 a
rewrapBox2 a = Box2 a

rewrapBox3 :: forall a. a -&gt; Box3 a
rewrapBox3 a = Box3 a

-- The following code will compile
box2Example :: Box2 Int
box2Example = boxFunction (Box2 2) unwrapBox2 (_ + 1) rewrapBox2 -- Box2 3

box3Example :: Box3 Int
box3Example = boxFunction (Box3 3) unwrapBox3 (_ + 1) rewrapBox3 -- Box3 4

-- Keep in mind that any type that follows a 'forall' keyword could be
-- a higher-kinded type

-- Higher kinded types can also occur in data declarations:
data Type_with_HKT :: (Type -&gt; Type) -&gt; Type -&gt; Type
data Type_with_HKT hkt a = Type_With_HKT_Constructor (hkt a)
{-
Thus we could have multiple values of this specific type, depending on what
type the `hkt` is:
  Type_With_HKT Array Int
  Type_With_HKT Box Int
-}

data Type_with_2_HKT :: (Type -&gt; Type) -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
data Type_with_2_HKT hkt1 hkt2 a = Type_With_2_HKT_Constructor (hkt1 a) (hkt2 a)
-- Type_with_2_HKT Array Array a
-- Type_with_2_HKT Array Box a
-- Type_with_2_HKT Box Array a
-- Type_with_2_HKT Box Box a
</code></pre>
<h1><a class="header" href="#01-single-paramterpurs" id="01-single-paramterpurs">01-Single-Paramter.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.SingleParameter where

import Prelude

-- Basic Type classes

-- a type class definition...
class TypeClassName parameterType where
  functionName :: parameterType -&gt; ReturnType

-- Or the parameter type could be the return type:
class TypeClassName_ parameterType where
  fromString :: String -&gt; parameterType

-- example
class ToInt a where
  toInt :: a -&gt; Int

-- ... and its implementation for SomeType
instance TypeClassName SomeType where
  functionName type_ = ReturnType

-- ## Type Class Instance Name Requirement
--
-- Previously, naming type class instances was required.
-- As of `v0.14.2`, this requirement has been dropped as the compiler
-- generates the instance name instead now.
--
-- Below is an example of a named type class instance. You
-- may continue to see these while the ecosystem catches up.
-- The name typically follows this naming convention:
--    `classNameType1NameType2Name...TypeNName`.
{-
instance typeClassNameSomeType :: TypeClassName SomeType where
  functionName type_ = ReturnType
-}

-- The rest of this repo will use unnamed type class instances.


instance ToInt Boolean where
  toInt true = 1
  toInt false = 0

test :: Boolean
test = (toInt true) == 0

-- Type classes can also specify values:

class TypeClassDefiningValue a where
  value :: a

instance TypeClassDefiningValue Int where
  value = 42

-- Type classes usually only specify one function, but sometimes
-- they specify multiple functions and/or values:

class ZeroAppender a where
  append :: a -&gt; a -&gt; a
  zeroValue :: a

instance ZeroAppender Int where
  append = (+)
  zeroValue = 0

warning_orphanInstance :: String
warning_orphanInstance = &quot;&quot;&quot;

Be aware of what an 'orphan instance' is.

See the following link for more info:
https://github.com/purescript/documentation/blob/master/errors/OrphanInstance.md
&quot;&quot;&quot;

{-
Note: Type class instances that use type aliases (i.e. the `type` keyword)
will fail to compile. The following code demonstrates this.
-}

-- Uncomment me and I'll become a compiler error
-- type Age = Int
-- instance TypeClassDefiningValue Age where
--   value = 2

-- Type classes are useful for constraining types, which will be covered next.

-- necessary to make file compile
data ReturnType = ReturnType
data SomeType
</code></pre>
<h1><a class="header" href="#02-constraining-types-using-typeclassespurs" id="02-constraining-types-using-typeclassespurs">02-Constraining-Types-Using-Typeclasses.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.Constraints where

import Prelude

-- Adding a Type Class constraint to a type signature
-- enables usage of the corresponding type class' function in that context:

-- Syntax: Adding constraints on Function's type signature
function :: TypeClass1 Type1 =&gt; TypeClass2 Type2 =&gt; {- and so on -} Type1 -&gt; ReturnType
function arg = &quot;return result&quot;

-- example

class ToInt a where
  toInt :: a -&gt; Int

data List a
  = Nil               -- end of list
  | Cons a (List a)   -- a head element and the rest of the list (tail)

                      -- 'a' must have an 'ToInt' instance for this to compile
stringList_to_intList :: forall a. ToInt a =&gt; List a -&gt; List Int
stringList_to_intList Nil = Nil
stringList_to_intList (Cons head tail) = Cons (toInt head) (stringList_to_intList tail)

-- Coupling this with the `forall` syntax:
function0 :: forall a b. TypeClass1 a =&gt; TypeClass2 b =&gt; a -&gt; b -&gt; String
function0 a b = &quot;return result&quot;



-- Syntax: Adding constraints on type class instances

-- This type class turns any type into a String so we can
-- print it to the console when needed
class Show_ a where -- this is the same signature for Show found in Prelude
  show_ :: a -&gt; String

-- Problem:
-- Say we have a data type called &quot;Box&quot; that just contains a value:
data Boxx a = Boxx a

-- If we want to implement the `Show` typeclass for it, we are limited to this:
instance Show (Boxx a) where
  show (Boxx _) = &quot;Box(&lt;unknown value&gt;)&quot;

{-
We would like to also show the 'a' value stored in Box. How do we do that?
  By constraining our types in the Box to also have a Show instance: -}

-- Syntax
instance (TypeClass1 a) =&gt; {-
                   (TypeClassN a) =&gt; -} TypeClass1 (IntanceType a) where
  function1 _ = &quot;body&quot;

data Box a = Box a
{- example: Read the following as:
&quot;I can 'show' a Box only if the type stored in the Box can also be shown.&quot;
-}
instance (Show a) =&gt; Show (Box a) where
  show (Box a) = &quot;Box(&quot; &lt;&gt; show a &lt;&gt; &quot;)&quot;

-- We have names for specific parts of the instance
instance (InstanceContext a) =&gt; A_TypeClass (InstanceHead a) where
  function2 _ = &quot;body&quot;

-- Implicit Usage: Since we know that the values below are of type &quot;Box Int&quot;
-- We can use &quot;show&quot; without constraining any types.
test1 :: Boolean
test1 =
  show (Box 4) == &quot;Box(4)&quot;

test2 :: Boolean
test2 =
  show (Box (Box 5)) == &quot;Box(Box(5))&quot;

-- Explicit Usage: The only thing we know about 'a' is that it can be shown.
showIt :: forall a. Show a =&gt; a -&gt; String
showIt showableThing = show showableThing

-- All of these work because they all have a Show instance.
test3 :: String
test3 = showIt 4

test4 :: String
test4 = showIt (Box 5)

test5 :: String
test5 = showIt (Box (Box (Box 5)))

-- necessary to make file compile

class TypeClass1 a where
  function1 :: a -&gt; String

class InstanceContext :: Type -&gt; Constraint
class InstanceContext a

instance InstanceContext a

data InstanceHead :: Type -&gt; Type
data InstanceHead a = InstanceHead

class A_TypeClass a where
  function2 :: a -&gt; String

instance TypeClass1 String where
  function1 a = a

class TypeClass2 :: Type -&gt; Constraint
class TypeClass2 a

instance TypeClass2 String

type Type1 = String
type Type2 = String
type ReturnType = String

data IntanceType a = InstanceType a
</code></pre>
<h1><a class="header" href="#03-dictionaries--how-type-classes-workpurs" id="03-dictionaries--how-type-classes-workpurs">03-Dictionaries--How-Type-Classes-Work.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.Dictionaries where

{-
Previously, we saw that `show` could be used &quot;implicitly&quot; when we
knew what the type was and &quot;explicitly&quot; when we did not know what
the type was but knew it had a constraint

In both cases, the compiler automatically figures out how which instance's
implementation to use. But how does it do this? How do Type Classes work?

Dictionaries are what enable a function/value to magically appear in the
implementation of a function's body. The below code is a summary of
this article about type class 'dictionaries' written by Jonathan Fischoff:
https://web.archive.org/web/20200116160958/https://www.schoolofhaskell.com/user/jfischoff/instances-and-dictionaries

I could not explain it clearer nor more concisely than Jonathan did.
-}

-- This code....
class ToBoolean a where
  toBoolean :: a -&gt; Boolean

  unUsed :: a -&gt; String

example :: forall a. ToBoolean a =&gt; a -&gt; Boolean
example value = toBoolean value

-- ... gets desugared to this code

data ToBooleanDictionary a =
  ToBooleanDictionary
    { toBoolean :: a -&gt; Boolean
    , unUsed :: a -&gt; String
    }

example' :: forall a. ToBooleanDictionary a -&gt; a -&gt; Boolean
example' (ToBooleanDictionary record) value = record.toBoolean value
</code></pre>
<h1><a class="header" href="#04-deriving-common-typeclass-instances-for-custom-typespurs" id="04-deriving-common-typeclass-instances-for-custom-typespurs">04-Deriving-Common-Typeclass-Instances-for-Custom-Types.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Deriving.Typeclass where

import Prelude


-- Given the following type classes, Eq and Ord

-- | Determines whether two values of the same type are equal
class Eq_ a where
  eq_ :: a -&gt; a -&gt; Boolean


data Ordering_ = LT_ | GT_ | EQ_

-- | Determines whether left is less than, greater than, or equal to right
class Ord_ a where
  compare_ :: a -&gt; a -&gt; Ordering_

-- Original credit: @paf31
-- Link: https://github.com/paf31/24-days-of-purescript-2016/blob/master/3.markdown
-- Changes made: use meta-language to explain type class derivation syntax
--
-- Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
--   https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US
data Type1
  = First Int
  | Second String

-- To create instances of `Eq` and `Ord` for `Type` we'd usually write it by hand:
instance Eq Type1 where
  eq (First a) (First b) = a == b
  eq (Second a) (Second b) = a == b
  eq _ _ = false

instance Ord Type1 where
  compare (First a) (First b) = compare a b
  compare (First _) _ = LT
  compare (Second a) (Second b) = compare a b
  compare (Second _) _ = GT

-- Imagine if we added a Third constructor to Type. We'd need to account for
--   that type as well now.
-- This gets tedious and, fortunately, the compiler can figure out what these
-- should be based on the 'shape' of the types. To reduce the boilerplate,
-- we can just add `derive` in front of the instance and not implement
-- the function:

data Type2
  = First2 Int
  | Second2 String

derive instance Eq Type2
derive instance Ord Type2

test2 :: Boolean
test2 =
  (compare (First2 1) (Second2 &quot;Foo&quot;)) == LT

-- Ordering between &quot;First&quot; and &quot;Second&quot; depend on their sequence in the ADT.

data Type3
  = Second3 String
  | First3 Int

derive instance Eq Type3
derive instance Ord Type3

test3 :: Boolean
test3 =
  (compare (First3 1) (Second3 &quot;Foo&quot;)) == GT

-- In other cases (like higher-kinded types),
-- we can use type class constraints to derive them:
data Box a = Box a
derive instance Eq a =&gt; Eq (Box a)
derive instance Ord a =&gt; Ord (Box a)

{-
Note: this works for only two reasons:

First, because Int and String
  both have an Eq and Ord instance. If one of these did not,
  then the compiler would not know how to create them.

Second, because we can only derive typeclasses for a few
  type classes:
  - Data.Eq (from `purescript-prelude`)
  - Data.Ord (from `purescript-prelude`)
  - Data.Functor (from `purescript-prelude`)

(These type classes can also be derived but they use a different syntax):
  - Data.Newtype (from `purescript-newtype`)
  - Data.Generic.Rep (from `purescript-generics-rep`)
-}
</code></pre>
<h1><a class="header" href="#05-typeclass-relationshipspurs" id="05-typeclass-relationshipspurs">05-Typeclass-Relationships.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.RequiredTypeClasses where

import Prelude

{-
Type classes can also have relationships with other type classes.

While the syntax looks hierarchial (i.e. parent-child relationships),
they aren't necessarily hierarchical. Rather, one should see them as
&quot;conditional,&quot; which will be shown soon.
-}

-- Here's the syntax. It reads,
--    &quot;Type 'a' can have an instance of the type class,
--    'ActualTypeClass.' However, it must also have an instance
--    of the type class, 'RequiredTypeClass.'&quot;
class RequiredTypeClass a &lt;= ActualTypeClass a where
  functionName :: a -&gt; ReturnType

-- examples
-- the required type class of 'PlusFive'
class ToInt a where
  toInt :: a -&gt; Int

class ToInt a &lt;= PlusFive a where
  plusFive :: a -&gt; Int

-- Writing an instance of ActualTypeClass does not require a constraint
-- from RequiredTypeClass in its type signature as this is already known due
-- to `ActualTypeClass`'s definition
instance ActualTypeClass TheType where
  functionName _ = &quot;body&quot;

-- example
instance ToInt Boolean where
  toInt true = 1
  toInt false = 0

instance PlusFive Boolean where
  plusFive b = 5 + toInt b

-- using it in code
test1 :: Boolean
test1 = (plusFive true) == 6

test2 :: Boolean
test2 = (plusFive false) == 5

-- Now let's explain what we mean by &quot;conditional.&quot;
instance ToInt Int where
  -- notice how the required type class, `ToInt`, is using functions
  -- from its extension type class, `PlusFive`.
  toInt x = plusFive x

instance PlusFive Int where
  plusFive b = 5 + b

-- If a type implements instances for a number of type classes, its instances
-- can use any of these type class' functions/values. Still,
-- one of those instances will actually need to be independent from the
-- others (i.e. it doesn't use any functions/values from other type classes).



-- A type class can also combine multiple typeclasses. Sometimes,
-- they will add additional functionality or laws. Other times,
-- they simply combine two or more type classes into one.

class RequiredTypeClass1 a where
  fn1 :: a -&gt; String

class RequiredTypeClass2 a where
  fn2 :: a -&gt; String

-- Example of combining and adding additional functionality:
class (RequiredTypeClass1 a, RequiredTypeClass2 a {-, ... -}) &lt;= TheTypeClass a where
  function :: a -&gt; a

-- Example of only combining and not adding any additional functionality.
-- Sometimes, this will add another law; other times, it only combines
-- multiple type classes together:
class (RequiredTypeClass1 a, RequiredTypeClass2 a {-, ... -}) &lt;= CombineOnly a

-- necessary to make file compile

type ReturnType = String
data TheType = TheType

class RequiredTypeClass a where
  fn :: a -&gt; String

instance RequiredTypeClass TheType where
  fn _ = &quot;body&quot;
</code></pre>
<h1><a class="header" href="#06-typeclasses-with-no-definitionspurs" id="06-typeclasses-with-no-definitionspurs">06-Typeclasses-with-No-Definitions.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclasses.NoDefinition where

import Prelude

{-
Some type classes do not declare any functions or values in their definition.

This usually occurs for one of two reasons:

1. They specify another law on top of the previous type class.

For example, the `ToString` type class converts any type's value into a String.
-}
class ToString a where
  toString :: a -&gt; String

-- However, it doesn't specify how big or small that String should be.
-- So, we can extend it with another type class that adds a law on how
-- long the String can be before it's too long.

class (ToString a) &lt;= ToString_50CharLimit a -- no &quot;where&quot; keyword here!
  -- no function or value here!

-- Assuming we've already written the `ToString` instance,
-- to create an instance for the above type class, we'd write:
instance ToString_50CharLimit Int -- no &quot;where&quot; keyword!
-- This instance means the developer who wrote it asserts that
-- the given type, Int, satisfies the given law.

{-
A developer making a library that specifies such a type as this has
documented through the types what users of that library should expect:
  calling 'toString a' will produce a String that is 50 chars or less.

Note:
Since the following are true...
  - `toString` defines a function `toString`
  - Int has an instance of `ToString`
  - `ToString_50CharLimit` adds a law to `ToString`'s `toString` function
  - Int has an instance of `ToString_50CharLimit`

... then a function that uses `show Int` will still output a String
that is 50 chars or less, even if the Int is not constrained to
the `ToString_50CharLimit` type class.

Since the latter imposes more restrictions on the former, the former must
also abide by those restrictions.

If one wanted to avoid this, they should define a new type class that
adds a function specifically for that:

  class (ToString a) &lt;= ToString_50CharLimt_2 a where
    toString_limited a = -- implementaton that uses 'show'
-}

-- 2. Some type classes merely combine two or more type classes together:

data Box a = Box a

class Wrap a where
  wrapIntoBox :: a -&gt; Box a

class Unwrap a where
  unwrapFromBox :: Box a -&gt; a

class (Wrap a, Unwrap a) &lt;= Boxable a

-- To create an instance of `Boxable`, we need to define instances
-- for Wrap, Unwrap, and Boxable, even if `Boxable` doesn't require
-- you to implement any functions/values.

instance Wrap Int where
  wrapIntoBox i = Box i

instance Unwrap Int where
  unwrapFromBox (Box i) = i

instance Boxable Int

useBoxable :: forall a. (Boxable a) =&gt; a -&gt; a
useBoxable a = unwrapFromBox (wrapIntoBox a)

-- Necessary to compile

instance ToString Int where
  toString = show
</code></pre>
<h1><a class="header" href="#07-multi-paramterpurs" id="07-multi-paramterpurs">07-Multi-Paramter.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.MultiParameters where

import Prelude

-- A type class can have more than just a single parameter as its type.

-- Syntax
class MultiParameterTypeClass1 type1 type2 {- typeN -} where
  functionName1 :: type1 -&gt; type2 -&gt; {- typeN -&gt; -} ReturnType

-- Again, a parameter could be the return type
class MultiParameterTypeClass2 type1 type2 {- typeN -} where
  functionName2 :: Int -&gt; type1 -&gt; {- typeN -&gt; -} type2

-- example (not practical, but gets the idea across)
class ConvertFromAToB a b where
  convert :: a -&gt; b

instance ConvertFromAToB Boolean String where
  convert true = &quot;true&quot;
  convert false = &quot;false&quot;

instance ConvertFromAToB Boolean Int where
  convert true = 1
  convert false = 0

toString :: forall a. ConvertFromAToB a String =&gt; a -&gt; String
toString a = convert a

test :: Boolean
test = (toString true) == &quot;true&quot;

-- necessary to make file compile
type ReturnType = String
</code></pre>
<h1><a class="header" href="#08-functional-dependenciespurs" id="08-functional-dependenciespurs">08-Functional-Dependencies.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.MultiParameters.FunctionalDependencies where

{-
Sometimes in multi-parameter type classes, there is a relationship
between the types. In such cases, we call them 'functional dependencies' (FDs).

The next block summarizes these links:
- https://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell/20040427#20040427
- https://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell/20040343#20040343
- Section 2.1.2 shows an example where it needs FDs to work correctly
    https://jgbm.github.io/pubs/morris-icfp2010-instances.pdf

Syntax:
  Read
    class SomeClass type1 type2 | type1 -&gt; type2
  as
    &quot;Once you tell the type inferencer what the types on the left-hand side
    of the arrow are (e.g. `type1`), then the type inferencer will stop
    trying to infer what the types on the right-hand side of the arrow are
    (e.g. `type2`).

    Rather, the compiler will look for an instance where
    the left-hand side types are defined and use that instance
    to determine what the right-hand side types are. If the compiler finds
    multiple instances where the left-hand side types are the same types
    between instances but the right-hand side types are different,
    it will throw a compiler error.
-}
class TypeClassWithFunctionalDependency type1 type2 | type1 -&gt; type2  where
  functionName1 :: type1 -&gt; type2

-- Example

data Box a = Box a

class Unwrap a b | a -&gt; b where
  unwrap :: a -&gt; b

-- Here, the type of &quot;a&quot; (i.e. Box String) determines what &quot;b&quot; will be:
instance Unwrap (Box String) String where
  unwrap (Box s) = s

{-
If we defined another instance of `Unwrap` where
&quot;a&quot; is the same type (e.g. `Box String`) but `b` is different,
the compiler will throw an error:

instance Unwrap (Box String) Int where
  unwrap (Box s) = length s                                                 -}

------------------------

-- If multiple types determine what another type is, use this syntax:
class ManyTypesDetermineAnotherType a b c | a b {- n -} -&gt; c  where
  functionName2 :: a -&gt; b -&gt; c

class OneTypeDeterminesManyTypes a b c | a -&gt; b c where
  functionName3 :: a -&gt; b -&gt; c

-- We can also add an explicit kind signature here:
class OneInfersMany_ExplicitKindSignature :: Type -&gt; Type -&gt; Type -&gt; Constraint
class OneInfersMany_ExplicitKindSignature a b c | a -&gt; b c where
  functionName4 :: a -&gt; b -&gt; c

------------------------

{-
In some situations, there might be multiple ways to determine
a type. In such cases, we can use multiple FDs to tell the compiler
how to infer a given type in the type class.

The following two FDs can be read as,
  &quot;Make the type checker try to find an instance of ManyFDRelationships where
  the `a` type and `b` type are known and then use
  the instance to infer what the `c` type is.

  However, if the type checker can't ultimately find such an instance,
  then try to find an instance where the `c` type is known and
  use that instance to infer what the `a` type and `b` type are.&quot;
-}
class ManyFDRelationships a b c | a b -&gt; c, c -&gt; a b where
  functionName5 :: a -&gt; b -&gt; c

-- Same thing but with a kind signature.
class ManyFDRelationships_KindSignature :: Type -&gt; Type -&gt; Type -&gt; Constraint
class ManyFDRelationships_KindSignature a b c | a b -&gt; c, c -&gt; a b where
  functionName6 :: a -&gt; b -&gt; c

{-
In short, the type checker will use the FDs to determine how it should &quot;unify&quot;
the types together. If one FD fails, it'll go to the next one. If all of them
fail, it'll assume that there is no such type class instance.
-}

{-
In Haskell literature, functional dependencies can also be written as
&quot;Type Families.&quot; To see how one can write the same concept in both
styles, see the below link:
https://wiki.haskell.org/GHC/Type_families#The_class_declaration_2

For advantages/disadvantages of both approaches, see these links:
https://wiki.haskell.org/Functional_dependencies_vs._type_families
https://ghc.haskell.org/trac/ghc/wiki/TFvsFD
-}
</code></pre>
<h1><a class="header" href="#09-instance-chainspurs" id="09-instance-chainspurs">09-Instance-Chains.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.InstanceChains where

-- ## Instance Chains: Syntax

import Prelude -- imports the '+' operation below...

data Type1 = Type1
data Type2 = Type2
data Type3 = Type3

-- A kind signature is necessary here because `theType`
-- `ExampleClass1` doesn't define a function or value that refers to `theType`
-- in that function/value's type signature.
class ExampleClass1 :: Type -&gt; Constraint
class ExampleClass1 theType

-- Instance chains are a workaround to the problem of &quot;overlapping instances.&quot;
-- Here's how the syntax works:
instance ExampleClass1 Type1
else instance ExampleClass1 Type2
-- ...
else instance ExampleClass1 Type3

-- For readability, the `else` and `instance` keywords can appear on
-- their own line or with a newline separating the keywords
class ExampleClass2 :: Type -&gt; Constraint
class ExampleClass2 theType

instance ExampleClass2 Type1
else
instance ExampleClass2 Type2
else

instance ExampleClass2 Type3

-- ## Instance Chains: Use Cases

-- Instance chains are useful because they allow you to define multiple
-- instances for a given type class, but define the order in which the
-- type class constraint is solved.

data SomeRandomType
  = FirstValue
  | SecondValue

class ProduceAnInt a where
  mkInt :: a -&gt; Int

-- When solving for `ProduceAnInt someType`, the compiler will
-- solve for `someType` in the following order:
instance ProduceAnInt Int where
  mkInt theInt = theInt
else
instance ProduceAnInt String where
  mkInt _ = 13
else
instance ProduceAnInt SomeRandomType where
  mkInt FirstValue = 89
  mkInt SecondValue = 98
else
instance ProduceAnInt allOtherPossibleTypes where
  mkInt _ = 42

data HasNoInstance = HasNoInstance

example :: Int
example =
  (mkInt 1 ) + (mkInt &quot;foo&quot;) + (mkInt FirstValue) + (mkInt HasNoInstance)     {-

  which, once the constraints are solved, will be the same as computing

  (1)        + (13)          + (89)               + (42)                      -}


-- ## Instance Chains Gotchas: No Backtracking

-- Given the following type class

class Stringify a where
  stringify :: a -&gt; String

-- One might write an instance chain like so with the following idea:
-- 1. First attempt to show the item using that type class instance
-- 2. Otherwise, indicate that it cannot be shown.

instance (Show allPossibleTypes) =&gt; Stringify allPossibleTypes where
  stringify a = show a
else
instance Stringify a where
  stringify _ = &quot;The value could not be converted into a String.&quot;

-- Then, one might attempt to use that code like so:
data Foo = Foo

-- failsToCompile :: String
-- failsToCompile = stringify &quot;a normal string&quot; &lt;&gt; stringify Foo

{-
Uncommenting that will produce the following compiler error:

  No type class instance was found for

      Data.Show.Show Foo


  while applying a function stringify
    of type Stringify t0 =&gt; t0 -&gt; String
    to argument Foo
  while checking that expression stringify Foo
    has type String
  in value declaration failsToCompile

  where t0 is an unknown type

-}

-- Why does this occur? Because the `doMeFirst` instance will match on
-- every type since the parameter passed to Stringify is literally
-- `allPossibleTypes`. It will then attempt to find the `Show` instance
-- for `allPossibleTypes`. In the case of `Foo`, which does not
-- have such an instance, the compiler does not &quot;backtrack&quot; and
-- attempt to use the `defaultToMeOtherwise` instance. Rather, it immediately
-- fails with the above error.
-- Backtracking is a feature that has not yet been implemented in the
-- compiler.
</code></pre>
<h1><a class="header" href="#11-type-equality-not-propagatepurs" id="11-type-equality-not-propagatepurs">11-Type-Equality-Not-Propagate.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Typeclass.Gotchas.TypeEqualityNotPropagate where

import Unsafe.Coerce (unsafeCoerce)

-- ## Gotcha Number 1: Type Equality isn't yet included in Type Class Constraints

-- ### Example of the Problem

-- Given a type class like so...
class TwoTypesButTheyAreTheSameThing :: Type -&gt; Type -&gt; Constraint
class TwoTypesButTheyAreTheSameThing a b | a -&gt; b, b -&gt; a

-- and an instance like so...
instance TwoTypesButTheyAreTheSameThing Int Int

-- ... the below code will fail to compile
{-
foo :: forall int
     . TwoTypesButTheyAreTheSameThing Int int
    =&gt; int
foo = 8

Compiler Error:

  Could not match type

      Int

    with type

      int0


  while checking that type Int
    is at least as general as type int0
  while checking that expression 8
    has type int0
  in value declaration foo

  where sameAsInt0 is a rigid type variable
          bound at (line 9, column 7 - line 9, column 8)

-}

-- Why? Because the compiler does not also infer that `int` must be
-- the type, `Int`, when solving the type class constraint, even if the
-- instance and type class' functional dependencies indicate otherwise.

-- ### Current Workaround

class A_Determines_B :: Type -&gt; Type -&gt; Constraint
class A_Determines_B a b | a -&gt; b

instance A_Determines_B Int String

-- The below &quot;foreign import&quot; syntax will be covered more in the FFI folder
foreign import data Computed :: Type -&gt; Type

fromComputed :: forall a b. A_Determines_B a b =&gt; Computed a -&gt; b
fromComputed = unsafeCoerce

toComputed :: forall a b. A_Determines_B a b =&gt; b -&gt; Computed a
toComputed = unsafeCoerce

-- As hdgarood explained it,
-- &quot;This is safe because you have to tell the compiler that you have an
-- `A_Determines_B a b` instance before it will coerce between the `a` and `b`.
-- But yes its expected that constraints with fundeps dont propagate
-- type equalities. Thats not yet implemented.&quot;
</code></pre>
<h1><a class="header" href="#designing-type-classes" id="designing-type-classes">Designing Type Classes</a></h1>
<p>Why does PureScript disallow Orphan Instances while other languages (e.g. Haskell) allow them? Scala has type classes, but they don't function like PureScript's type classes.</p>
<p>If you are curious to learn more, read <a href="https://github.com/AndrasKovacs/pny1-assignment/blob/master/DepTC.md">Type classes, class coherence and dependent types</a>, which provides insight into the design and implementations of the 'type class' concept as well as implementations' tradeoffs.</p>
<h1><a class="header" href="#10-keyword--newtypepurs" id="10-keyword--newtypepurs">10-Keyword--Newtype.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Newtype where

import Prelude

{-
The last data type keyword to explain here is `newtype`.

It is a compile-time-only type that only takes one type as its argument.

These are useful primarily for two reasons
  - They add a more meaningful name to another type (like type aliases)
      but act as a completely different type (unlike type aliases).
  - They are compile-time-only types, so one does not incur runtime overhead
      (like type aliases).
  - They need to be constructed/deconstructed in code (unlike type aliases).
      When used with Phantom Types (see the `Design Patterns` folder), they can
      restrict how developers can use the type in very useful ways.
  - They enable one to define multiple type class instances for the same type.
-}

-- Syntax:
newtype NewTypeName = OnlyAllowsOneConstructor WhichOnlyTakesOneArgument_TheWrappedType

newtype NamedStringType = NamedStringType String

-- Pattern matching on a type defined via the `newtype` keyword works
-- just like a type defined via the `data` keyword.
-- You can expose the value wrapped by the newtype constructor
-- using a pattern match and/or `case _ of` syntax
patternMatching :: String
patternMatching =
  unwrap_a_newtype_via_pattern_match
    (wrap_a_value_via_constructor
      (unwrap_a_newtype_via_pattern_match
        (NamedStringType &quot;example&quot;)
      )
    )

  where
    wrap_a_value_via_constructor :: String -&gt; NamedStringType
    wrap_a_value_via_constructor str = NamedStringType str

    unwrap_a_newtype_via_pattern_match :: NamedStringType -&gt; String
    unwrap_a_newtype_via_pattern_match (NamedStringType str) = str

    unwrap_a_newtype_via_case_of_syntax :: NamedStringType -&gt; String
    unwrap_a_newtype_via_case_of_syntax = case _ of
      NamedStringType str -&gt; str

-- Given the following code:
data Box a = Box a

class Show_ a where
  show_ :: a -&gt; String

instance (Show a) =&gt; Show (Box a) where
  show (Box a) = &quot;Box(&quot; &lt;&gt; show a &lt;&gt; &quot;)&quot;

-- What if we wanted to use a different type class instance for `Box` in some
-- situations, but not want to redefine `Box` as a new type with a different
-- name? We would do this:
newtype Box2 a = Box2 (Box a)

-- Since `Box2` is a different type than `Box`, we can define a type class
-- instance on it. This is a way to provide an alternative `Show` instance
-- on the underlying `Box` type.
instance (Show a) =&gt; Show (Box2 (Box a)) where
  show (Box2 (Box a)) = &quot;Box with value of [&quot; &lt;&gt; show a &lt;&gt; &quot;] inside of it.&quot;

-- Or, to add more context to a type, we can use a newtype to ensure we
--   - don't use a `String` where we need to use a `Name`.
--   - don't use an `Int` where we need to use an `Age`.
newtype Name = Name String
newtype Age = Age Int
newtype Relationships = Relationships (List People)

-- Assuming all three above have a Show instance:
--
-- printPerson :: Name -&gt; Age -&gt; Relationships -&gt; String
-- printPerson (Name n) (Age i) (Relationships l) =
--    &quot;Name: &quot; &lt;&gt; n &lt;&gt; &quot;, Age: &quot; &lt;&gt; show i &lt;&gt; &quot;, Relationships: &quot; &lt;&gt; show l

-- Similar to `data` and `type`, newtypes can also have a kind signature:

-- Implicit kind signature: Type -&gt; Type
newtype SomeValue a = SomeValue (Box a)

newtype SomeValue_ExplicitKindSignature :: Type -&gt; Type
newtype SomeValue_ExplicitKindSignature a = SomeValueExplicit (Box a)

-- needed to compile

type WhichOnlyTakesOneArgument_TheWrappedType = String

data List :: Type -&gt; Type
data List a

data People
</code></pre>
<h1><a class="header" href="#22-deriving-typeclass-instances-for-newtyped-typespurs" id="22-deriving-typeclass-instances-for-newtyped-typespurs">22-Deriving-Typeclass-Instances-for-Newtyped-Types.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Deriving.Newtype where

import Prelude

-- needed for deriving Newtype example
import Data.Newtype (class Newtype, over)

-- License applies to a portion of this document --&gt; Start

-- Original credit: @paf31
-- Link: https://github.com/paf31/24-days-of-purescript-2016/blob/master/4.markdown
-- Changes made: use meta-language to explain newtype typeclass derivation syntax
--
-- Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
--   https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US

-- Newtypes are used to wrap existing types with more information around them
newtype EmailAddress1 = EmailAddress1 String

-- However, defining type class instances for them
-- can get tedious:

instance Eq EmailAddress1 where
  eq (EmailAddress1 s1) (EmailAddress1 s2) = s1 == s2
-- same for Ord type class

-- same for other newtypes
newtype Phone = Phone String
newtype FirstName = FirstName String
-- etc...

-- This is boilerplate since we unpack the instance and delegate the function
-- to the wrapped type's implementation. It's also inefficient in terms of
-- evaluation. Purescript gives us a way to derive, for newtypes, any instance
-- the boxed type implements, using the following syntax.
-- We use 'derive newtype' in front of the instance:

newtype EmailAddress2 = EmailAddress2 String

derive newtype instance Eq EmailAddress2
derive newtype instance Eq Phone
derive newtype instance Eq FirstName

-- &lt;--- End

-- License applies to a portion of this document --&gt; Start

-- Original credit: @paf31
-- Link: https://github.com/paf31/24-days-of-purescript-2016/blob/master/5.markdown
-- Changes made: use meta-language to explain Newtype typeclass derivation syntax
--
-- Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
--   https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US

-- Another useful class we can derive from is found in the `newtype` library: purescript-newtype
class Newtype_ new old | new -&gt; old

newtype EmailAddress3 = EmailAddress3 String

-- no need to indicate what &quot;_&quot; is since the compiler can figure it out
derive instance Newtype EmailAddress3 _

-- Data.Newtype provides other useful functions that lets us avoid manually
-- wrapping and unwrapping. For example:
upperEmail :: EmailAddress3 -&gt; EmailAddress3
upperEmail = over EmailAddress3 prefixWithText

-- To see the full list, look at the package's docs:
-- https://pursuit.purescript.org/packages/purescript-newtype/3.0.0/docs/Data.Newtype
-- &lt;--- End

-- needed to compile

-- | prefixes a given string with 'text'
prefixWithText :: String -&gt; String
prefixWithText str = &quot;text&quot; &lt;&gt; str
</code></pre>
<h1><a class="header" href="#global-typeclasses" id="global-typeclasses">Global Typeclasses</a></h1>
<h2><a class="header" href="#type-class-instances-global-vs-local" id="type-class-instances-global-vs-local">Type Class Instances: Global vs Local</a></h2>
<p>To state that a given type (e.g. <code>Box</code>) can satisfy a type class' requirements, one writes a &quot;<strong>type class instance</strong>&quot;. This instance actually defines how a given type (e.g. <code>Box</code>) implements that type class (e.g. <code>Functor</code>).</p>
<p>A language can implement type classes in two different ways:</p>
<ul>
<li>Global: one type can only have one instance for any given type class.</li>
<li>Local: one type can have multiple instances for any given type class.</li>
</ul>
<p>PureScript uses global type class instances whereas languages like Scala use local type class instances. So, what's the difference?</p>
<h3><a class="header" href="#benefits-of-global-instances" id="benefits-of-global-instances">Benefits of Global Instances</a></h3>
<p>Let's say I use functions that require the underlying data type to satisfy the <code>Functor</code> type class' requirements. Sometimes, that underlying data type is <code>Array</code>. Sometimes, it's <code>Box</code>. Sometimes, it's <code>Maybe</code>.</p>
<p>Global instances mean that a given data type (e.g. <code>Box</code>) can only have one instance for a given type class (e.g. <code>Functor</code>). Thus, every time and everywhere that I use <code>Functor</code> in my code where the underlying type is <code>Box</code>, the same Box-Functor instance is always used. This makes it easy for the compiler to figure out which instance to use, and the programmer does not have to think deeply about which instance will be used.</p>
<p>Local instances mean that a given data type (e.g. <code>Box</code>) can have an infinite number of instances for a given type class (e.g. <code>Functor</code>). Thus, any time I use <code>Functor</code> in my code and the underlying type is <code>Box</code>, any one of its instances could be used. This makes it harder for the compiler to figure out which instance to use. Ultimately, the compiler chooses an appropriate instance based on which instance is &quot;closest&quot; in the given scope. However, the programmer has to think more deeply about how to properly configure/arrange their code, so that the instance they want the compiler to choose is actually chosen and used.</p>
<h3><a class="header" href="#costs-of-global-instances-orphan-instances" id="costs-of-global-instances-orphan-instances">Costs of Global Instances: Orphan Instances</a></h3>
<p>Given this tradeoff, it may seem strange that global instances aren't used everywhere. If it's easier for the compiler and programmer, why use local instance?</p>
<p>The major pain point of global instances is &quot;orphan instances.&quot;</p>
<p>For the below examples, let's say there is a type class, <code>MyTypeClass</code>, that is defined in <code>Data.MyTypeClass</code>. Let's say there is a data type, <code>Box</code>, that is defined in <code>Data.Box</code>. Let's say there is a third module, <code>Data.Orphan</code>, that has various other functions and values.</p>
<p>Due to how global instances work, an instance for a type class must be defined in one of two ways. There are two places where we could declare and implement the <code>Box</code>-<code>MyTypeClass</code> instance:</p>
<ul>
<li>either in <code>Data.MyTypeClass</code> module, which imports the <code>Box</code> module and its type</li>
<li>or in the <code>Data.Box</code> module, which imports the <code>Data.MyTypeClass</code> module and its class.</li>
</ul>
<p>If an instance is defined anywhere else (e.g. defined in <code>Data.Orphan</code>), it's called an &quot;orphan instance.&quot; For example, Bob writes a library that exposes a type class (e.g. <code>MyTypeClass</code>). Sally, writes a data type that exposes a type (e.g. <code>Box</code>). The <code>Box</code>-<code>MyTypeClass</code> instance can be defined in either Bob's library or Sally's library. You are a third-party who wishes the <code>Box</code>-<code>MyTypeClass</code> instance was implemented differently than what either Bob or Sally implemented it as. However, since your module (e.g. <code>Data.Orphan</code>) is not one of those two modules, you cannot redefine the instance.</p>
<p>The only workaround to this situation is to define a newtype over <code>Box</code> that provides a different <code>Box</code>-<code>MyTypeClass</code> instance. While this seems simple to do, newtype wrapping and unwrapping can start to feel like &quot;bloat&quot; that gets in the way of other things.</p>
<h3><a class="header" href="#why-orphan-instances-are-painful" id="why-orphan-instances-are-painful">Why Orphan Instances Are Painful</a></h3>
<h4><a class="header" href="#an-example" id="an-example">An Example</a></h4>
<p>Let's say you have a library called <code>purescript-unordered-collections</code> that defines a data type called <code>HashMap</code>. Let's say you have another library called <code>purescript-argonaut-codecs</code> that defines two type classes called <code>EncodeJson</code> and <code>DecodeJson</code>. Where do you define <code>HashMap</code>'s instances for those two type classes?</p>
<p>If in the data-type library (where the <code>HashMap</code> data type is declared), then that library will need to depend on the codec library.
If in the codec library (where the <code>EncodeJson/DecodeJson</code> type classes are declared), then it will need to depend on the data-type library.</p>
<p>Either way, someone will get annoyed by something:</p>
<ul>
<li>once the instance is defined in either library, everyone in the ecosystem is now stuck using that instance's definition. If they thought it should have been defined differently, they often have to write boilerplatey code via <code>newtype</code>s to be able to define their own instances.</li>
</ul>
<p>Languages with local instances can shrug their shoulders as they have more control as to which instance gets chosen.</p>
<h4><a class="header" href="#the-default-type-class" id="the-default-type-class">The <code>Default</code> Type Class</a></h4>
<p>Type classes provide a &quot;convenience&quot; of sorts: rather than forcing the developer to pass in an implementation of the function, <code>(a -&gt; Boolean)</code>, the compiler can infer what that function's implementation is <strong>as long as it can infer what the type of <code>a</code> is</strong>.</p>
<p>Thus, new learners tend to reach the following conclusion. Let's say you are writing a library where you want to make it easier for the developer to use this library. At some point in the library, you need them to provide a default value. &quot;Gee!&quot; you think, &quot;Why not use a type class called <code>Default</code>? The compiler can infer which instance to use and the developer's life will be that much easier!&quot; While your intentions are good, that's a terrible idea as it will lead to &quot;instance wars&quot; due to orphan instances.</p>
<p>Although it can suffer from similar problems, a better choice is <code>Monoid</code>. See Gabriel Gonzalez' post on <a href="http://www.haskellforall.com/2013/04/defaults.html">Defaults</a>.</p>
<p>Similarly, read <a href="https://www.reddit.com/r/haskell/comments/5gospp/dont_use_typeclasses_to_define_default_values/">Don't Use Type Classes to Define Default Values</a>.</p>
<h3><a class="header" href="#summary-of-global-vs-local-type-class-instances-tradeoffs" id="summary-of-global-vs-local-type-class-instances-tradeoffs">Summary of Global vs Local Type Class Instances' Tradeoffs</a></h3>
<table><thead><tr><th>Type</th><th>Pros</th><th>Cons</th></tr></thead><tbody>
<tr><td>Global</td><td><ul><li>Easier for the compiler to find an instance</li><li>To the programmer, it's obvious which instance will be used</li></ul></td><td>Orphan Instances or writing boilerplatey <code>newtyp</code> code to get around them</td></tr>
<tr><td>Local</td><td><ul><li>Harder for the compiler to find an instance</li><li>To the programmer, it's not obvious which instance will be used and sometimes very difficult to properly configure/arrange one's code, so that the correct instance is eventually used</li></ul></td><td>Best instance for the problem can be used without boilerplate</td></tr>
</tbody></table>
<p>Scala uses local instances. Haskell uses global instances and orphan instances are disallowed by default; however, I believe Haskell has an &quot;escape hatch&quot; that allows orphan instances to exist.</p>
<p>PureScript uses global instances, and orphan instances are strictly disallowed. Unlike Haskell, there are no &quot;escape hatches.&quot; For more context, see <a href="https://github.com/purescript/purescript/issues/1247#issuecomment-512975645">Harry's comment in 'Disallow Orphan Instances' (purescript/purescript#1247)</a>.</p>
<h2><a class="header" href="#scrap-your-type-classes-sytc" id="scrap-your-type-classes-sytc">Scrap Your Type Classes (SYTC)</a></h2>
<p>At the end of the day, mainstream usage of type classes provide a lot of convenience to the developer. Rather than defining a function that takes many arguments, it only takes a few arguments that highlight what you want to do.</p>
<p>As a result, some developers who encounter a problem will immediately decide to use type classes as their solution rather than some other language feature that is more appropriate (e.g. regular functions). For some problems, it is better to use regular functions rather than type classes. Regular functions might be less convenient than type classes, but they can be easier to use in some cases and more performant in others.</p>
<p>To understand the tradeoff, you must</p>
<ol>
<li>understand that <a href="https://www.schoolofhaskell.com/user/jfischoff/instances-and-dictionaries">type class constraints are replaced with arguments called 'type class dictionaries'</a></li>
<li>realize that the possibly &quot;larger&quot; type class dictionary object argument could be replaced with a &quot;smaller&quot; single function</li>
</ol>
<p>For more context, see <a href="http://www.haskellforall.com/2012/05/scrap-your-type-classes.html">Scrap Your Type Classes</a></p>
<h2><a class="header" href="#other-usages-of-type-classes" id="other-usages-of-type-classes">Other Usages of Type Classes</a></h2>
<p>Some type classes are purposefully designed to be lawless because they are used for other situations. Here are some examples:</p>
<ul>
<li>Type-level documentation
<ul>
<li><code>Partial</code> - represents a partial function: a function that does not always return a value for every input, but which will throw a runtime error on some inputs (covered in <code>Design Patterns/Partial Functions</code>)</li>
</ul>
</li>
<li>Custom compiler warnings/errors
<ul>
<li><code>Warn</code>/<code>Fail</code> - causes the compiler to emit a custom warning or a compiler error when the associated function/value is used in the code base (covered in <code>Hello World/Debugging/Custom Type Errors</code>)</li>
</ul>
</li>
<li>Type-level functions
<ul>
<li><code>Symbol.Append</code> - represents a type-level function (covered in <code>Syntax/Type-Level Programming Syntax</code> and <code>Hello World/Type-Level Programming</code>).</li>
</ul>
</li>
<li>Function/Value Name Overloading (see next section's explanation and debate about this idea)</li>
</ul>
<h3><a class="header" href="#debate-must-type-classes-always-be-lawful" id="debate-must-type-classes-always-be-lawful">Debate: Must Type Classes Always Be Lawful?</a></h3>
<p>While I already linked to the following link in the 'default type class' issue explained above, the link also covers another topic: why type classes should be lawful. Focusing on that aspect, the following is a (somewhat biased) summary of <a href="https://www.reddit.com/r/haskell/comments/5gospp/dont_use_typeclasses_to_define_default_values/">Don't Use Type Classes to Define Default Values</a></p>
<p>Those that say &quot;yes&quot; likely value the benefit of laws. Laws guarantee relationships between functions and values. In short, it's easier to understand and reason about code that uses lots of generic types (e.g. <code>forall a. a -&gt; String</code>) if one knows that functions that operate on values of the type, <code>a</code>, or values that provide an <code>a</code> value adhere to certain laws.</p>
<p>Those that say &quot;no&quot; likely value the benefit of overloading a function name with different implementations. For example, what if one wanted to provide a default value of some type? Reusing the function name &quot;default&quot; is pretty easy to understand. However, what laws does it abide by? Without a deeper context, it's hard, if not impossible, to say.</p>
<p>The counterargument from those that say &quot;laws must be required&quot; is: &quot;one usually hasn't thought through their design that deeply yet.&quot; As an example, is <code>Default Int</code> just a different name for <code>Monoid</code>'s <code>mempty</code>, (i.e. <code>0</code> in addition (<code>1 + 0 == 1</code> and <code>0 + 1 == 1</code>)? Is their approach to their design actually flawed because there is a &quot;better&quot; way and they just haven't realized it yet?</p>
<p>Are there cases where the function name would &quot;read well&quot; in two contexts but mean two different things? For example, Context A's use of <code>default</code> might return <code>0</code> whereas Context B's use of <code>default</code> might return <code>12</code>.</p>
<p>Thus, it seems that lawless type classes imply a domain-specific meaning in each context whereas lawful type classes imply a domain-independent meaning.</p>
<p>The reader is left with these question:</p>
<ul>
<li>Are there ever times where gaining the convenience of overloaded function names are worth the loss of lawful-reasoning?
<ul>
<li>Does this change when adds in other factors?
<ul>
<li>Time (e.g. cost is great short-term but sucks long-term; cost stays the same through short- and long-term)</li>
<li>Business cost (e.g. cost to refactor non-lawful type classes vs cost of only making lawful type classes when overloaded functions names would have made development easier / accomplished the goal at the end of the day)</li>
<li>Hobby (e.g. I'm just making a fun project that no one will ever use)</li>
</ul>
</li>
</ul>
</li>
<li>If so, when should it be done? How would one know that it was the wrong approach and when would that likely happen?</li>
<li>What problems did developer X face when sticking to Side A instead of Side B?</li>
</ul>
<h1><a class="header" href="#21-documentationpurs" id="21-documentationpurs">21-Documentation.purs</a></h1>
<pre><code class="language-haskell">-- | This is a single-line documentation.

-- | This
-- | is
-- | a
-- | multi-line
-- | documentation block, not a comment.
-- | Because it appears above the module declaration below,
-- | it will be combined with the next few documentation blocks.

-- | One can use markdown inside of documentation:
-- |
-- | Look an unordered list:
-- | - item 1
-- | - item 2
-- |
-- | An ordered list:
-- | 1. Item
-- | 2. Item
-- | 3. Item
-- |
-- | Unfortunately, markdown tables don't work...:
-- |
-- | | One | Two | Three |
-- | | --- | --- | ----- |
-- | | a   | b   | c     |
-- |
-- | # Headers level 1 work
-- |
-- | ## Headers level 2 work
-- |
-- | ### Headers level 3 work
-- |
-- | #### Headers level 4 work
-- |
-- | ##### Headers level 5 work
-- |
-- | ###### Headers level 6 work
-- |
-- | Some code:
-- | ```purescript
-- | f :: Int
-- | f = 4
-- | ```

-- | Documentation on a given module
module Syntax.Basic.Documentation where

-- | Documentation on a value
value :: Int
value = 4

-- | Documentation on a function
function :: Int -&gt; String
function _ = &quot;easy&quot;

-- | Documentation on a given data type
data SomeData
  -- | Documentation on a particular data constructor
  = SomeData

-- | Documentation on a given type alias
type MyType = String

-- | Documentation on a given newtype
newtype SmallInt = SmallInt Int

-- | Documentation on a given type class
class MyClass a b | a -&gt; b where
  -- | Documentation for a particular function/value
  -- | defined in a type class
  myFunction :: a -&gt; b

-- | Documentation for a particular instance of a type class
instance MyClass String Int where
  myFunction _ = 4
</code></pre>
<h1><a class="header" href="#22-unicode-syntax-supportpurs" id="22-unicode-syntax-supportpurs">22-Unicode-Syntax-Support.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Basic.Unicode where

-- Unicode sytax is supported

-- Original credit: @paf31
-- Link: https://github.com/paf31/24-days-of-purescript-2016/blob/master/2.markdown
-- Changes made:
--  - copied type signature that use unicode syntax except for union/intersect
--  - copied links showing unicode syntax in real libraries
--  - added library showing emoji operators in real library
--  - added forall /  comparison
--
-- Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
--   https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US

data  = Zero | Succ 

add ::  -&gt;  -&gt; 
add _ _ = Zero

 :: Number
 = 0.001

{-
Using unicode syntax, instead of using a combination of characters,
one could use a single character to save space:

| Instead of...  | -&gt; | &lt;- | =&gt; | &lt;= | :: | forall |
|----------------+----+----+----+----+----+--------+
| you can use... |   |   |   |   |   |       |

Using Unicode syntax can make things unreadable, but sometimes it makes things more readable:
- https://github.com/paf31/purescript-isomorphisms/blob/f1a9e59f831cc3150dd9bc7aa66b2661df250ebe/src/Data/Iso.purs#L22
- https://github.com/paf31/purescript-pairing/blob/837638470c58df3971fe2e56395d65f391c9ba00/src/Data/Functor/Pairing.purs#L43

Yes, this does enable emoiji operators. See this library for an example of
why you might and might not want to use that syntax:
- https://pursuit.purescript.org/packages/purescript-prelewd/0.1.0

-}
</code></pre>
<h1><a class="header" href="#understanding-type-inference" id="understanding-type-inference">Understanding Type Inference</a></h1>
<p>The below video explains how type inference works. It can be very helpful to understand what is going on behind the scenes when you get compiler errors: <a href="https://www.youtube.com/watch?v=x3evzO8O9e8">How GHC's Type Inference Engine Works</a></p>
<h1><a class="header" href="#foreign-function-interface-ffi-syntax" id="foreign-function-interface-ffi-syntax">Foreign Function Interface (FFI) Syntax</a></h1>
<h2><a class="header" href="#alternate-backends" id="alternate-backends">Alternate Backends</a></h2>
<p>Besides compiling to Javascript, Purescript can also compile to other languages. See <a href="https://github.com/purescript/documentation/blob/master/ecosystem/Alternate-backends.md">this link</a> for a full list (may be outdated)</p>
<h2><a class="header" href="#syntax-1" id="syntax-1">Syntax</a></h2>
<p>This folder provides examples of FFI for simple cases regarding the JavaScript backend. However, see <a href="https://blog.ndk.io/purescript-ffi.html">Wrapping JavaScript for PureScript</a> for more detailed examples as to how to do FFI properly.</p>
<p>You should also look at the Purescript and Javascript source code for Effect.Uncurried:</p>
<ul>
<li><a href="https://github.com/purescript/purescript-effect/blob/v2.0.0/src/Effect/Uncurried.purs#L139">Purescript</a></li>
<li><a href="https://github.com/purescript/purescript-effect/blob/v2.0.0/src/Effect/Uncurried.js#L1">Javascript</a></li>
</ul>
<p>Lastly, there may be some cases where you need to write FFI with <code>Effect</code>, but <code>Effect</code> isn't the best type to use. In such cases, take a look at <a href="https://pursuit.purescript.org/packages/purescript-aff/5.0.2/docs/Effect.Aff.Compat">Aff's FFI</a>:</p>
<h2><a class="header" href="#using-purescript-code-within-a-javascript-context" id="using-purescript-code-within-a-javascript-context">Using PureScript code within a JavaScript context</a></h2>
<blockquote>
<p>If I want to create some standalone PureScript functions that integrate with a broader JavaScript codebase, is there a way to take the output from browserify and accomplish that?</p>
</blockquote>
<pre><code>$ cat src/GCD.purs
module GCD where

import Prelude

gcd2 :: Int -&gt; Int -&gt; Int
gcd2 n m | n == 0 = m
gcd2 n m | m == 0 = n
gcd2 n m | n &gt; m = gcd (n - m) m
gcd2 n m = gcd (m - n) n

$ cat build.sh
pulp browserify --main GCD --skip-entry-point --standalone index --to js/index.js```
</code></pre>
<blockquote>
<p>As-in, is there some magic required to import <code>index.js</code> and expose <code>gcd2</code>?</p>
</blockquote>
<blockquote>
<p>At Awake, we would write something like a <code>GCD.Interop</code>, which has bindings from JS reps to the PS reps, and then we would just import the output directly</p>
</blockquote>
<blockquote>
<p>Can you give an example of what that would look like specifically?</p>
</blockquote>
<blockquote>
<p>Sure.</p>
</blockquote>
<pre><code class="language-haskell">module GCD.Interop where
import Prelude
import GCD as GCD
import Data.Function.Uncurried (mkFn2)

gcd2 :: Fn2 Int Int Int
gcd2 = mkFn2 GCD.gcd2
</code></pre>
<blockquote>
<p>That gets compiled to <code>./output/GCD.Interop/index.js</code> and then in a js file I can do</p>
</blockquote>
<pre><code class="language-javascript">import { gcd2 } from &quot;./output/GCD.Interop/index.js&quot;;
gcd2(4, 5);
</code></pre>
<blockquote>
<p>Okay cool. That is helpful. Thank you!</p>
</blockquote>
<blockquote>
<p>You can import the original file directly as well but the reason we write an Interop file is so we can change PS files without breaking JS consumers, or at least, if we change types, we know that JS consumers need to be verified</p>
</blockquote>
<blockquote>
<p>If I load the original file via a script tag, I can't figure out how to call <code>gcd2</code>, as it feels like it's hidden behind a closure, am I wrong? I don't totally understand the magic browserify is doing...</p>
</blockquote>
<blockquote>
<p>If you use browserify with standalone, then you can configure what the global variable is. So <code>pulp browserify --main GCD --skip-entry-point --standalone GCD --to index.js</code>. If you load that index file with a script tag, then youll have <code>GCD.gcd2</code> available in the global namesapce</p>
</blockquote>
<blockquote>
<p>That's what I was looking for.</p>
</blockquote>
<h1><a class="header" href="#same-file-namejs" id="same-file-namejs">Same-File-Name.js</a></h1>
<pre><code class="language-javascript">// don't forget to add this line here!
&quot;use strict&quot;;

exports.basicValue = 4.0;

exports.basicCurriedFunction = function(number) {
  return number * 4.0;
};

exports.basicEffect = function() {
  return 4.0;
};

exports.threeArgCurriedFunction = function(arg1) {
  return function(arg2) {
    return function(arg3) {
      // body of function
      return arg1 * arg2 * arg3;
    };
  };
};

exports.curriedFunctionProducingEffect = function(string) {
  return function() {
    return string;
  };
};

exports.basicUncurriedFunction = function(fn) {
  return function(arg1) {
    return function(arg2) {
      return fn(arg1)(arg2)();
    };
  };
};

var twoArgFunction = function(arg1, arg2) {
  console.log(arg1 + &quot; &quot; + arg2);
};

exports.twoArgCurriedFunctionImpl = twoArgFunction;
</code></pre>
<h1><a class="header" href="#same-file-namepurs" id="same-file-namepurs">Same-File-Name.purs</a></h1>
<pre><code class="language-haskell">module Syntax.FFI where

import Prelude

import Effect (Effect)
import Effect.Uncurried (EffectFn2, runEffectFn2)

foreign import data DataType :: Type

foreign import data HigherKindedType :: Type -&gt; Type

foreign import basicValue :: Number

foreign import basicEffect :: Effect Number

foreign import basicCurriedFunction :: Number -&gt; Number

foreign import threeArgCurriedFunction :: Number -&gt; Number -&gt; Number -&gt; Number

foreign import curriedFunctionProducingEffect :: String -&gt; Effect String

foreign import basicUncurriedFunction :: EffectFn2 Number Number Number

foreign import twoArgCurriedFunctionImpl :: EffectFn2 String String Unit

twoArgFunction :: String -&gt; String -&gt; Effect Unit
twoArgFunction = runEffectFn2 twoArgCurriedFunctionImpl
</code></pre>
<h1><a class="header" href="#type-level-programming-syntax" id="type-level-programming-syntax">Type-Level Programming Syntax</a></h1>
<p>Read the files in order. It may take a few read-throughs for it to make sense as to why some things are needed but it will make sense eventually.</p>
<p>Note: there is an annoyance that can occur if you play around with the code: due to using the same names for some things, the IDE may try to import these names from other modules. If it does so, it may result it some definition being declared twice in the same file and produce a compiler error. If you experience such a problem, check the top of the file and delete any imports there.</p>
<h2><a class="header" href="#other-learning-sources" id="other-learning-sources">Other Learning Sources</a></h2>
<p>Consider purchasing <a href="https://leanpub.com/thinking-with-types/">Thinking with Types</a>, a book that claims to be &quot;the comprehensive manual for type-level programming&quot;. Abhinav Sarkar also made <a href="https://abhinavsarkar.net/posts/twt-notes-1/">his notes public</a></p>
<h1><a class="header" href="#an-overview-of-terms-and-concepts" id="an-overview-of-terms-and-concepts">An Overview of Terms and Concepts</a></h1>
<h2><a class="header" href="#comparison" id="comparison">Comparison</a></h2>
<p>In programming, there are usually two terms we use to describe &quot;when&quot; a problem/bug/error can occur:</p>
<ul>
<li>Compile-time: Turns source code into machine code. Compiler errors occur due to types not aligning.</li>
<li>Runtime: Executes machine code. Runtime errors occur due to values of types not working as expected/verified by the compiler (e.g. you expected a <code>String</code> at runtime but got <code>null</code>).</li>
</ul>
<h2><a class="header" href="#definition" id="definition">Definition</a></h2>
<table><thead><tr><th>Term</th><th>Definition</th><th>&quot;Runtime&quot;</th></tr></thead><tbody>
<tr><td>Value-Level Programming</td><td>Writing source code that gets executed during runtime</td><td>Node / Browser</td></tr>
<tr><td>Type-Level Programming</td><td>Writing source code that gets executed during compile-time</td><td>Type Checker / Type Class Constraint Solver^</td></tr>
</tbody></table>
<p>^ First heard of this from @natefaubion when he mentioned it in the #purescript Slack channel</p>
<h2><a class="header" href="#what-are-types-and-functions" id="what-are-types-and-functions">What Are Types and Functions?</a></h2>
<h3><a class="header" href="#types-reexamined" id="types-reexamined">Types Reexamined</a></h3>
<p>When we define a type like so...</p>
<pre><code class="language-haskell">data MyType
  = Value1
  | Value2
</code></pre>
<p>... we are saying there is a set or domain called <code>MyType</code> that has two members, <code>Value1</code> and <code>Value2</code>.
Thus, when we write...</p>
<pre><code class="language-haskell">value1 :: MyType
value1 = Value1
</code></pre>
<p>... we could also write it with more type information:</p>
<pre><code class="language-haskell">value1 :: MyType
value1 = (Value1 :: MyType)
</code></pre>
<p>The syntax <code>(Value1 :: MyType)</code> means <code>Value1</code> is a value of the <code>MyType</code> type (or <code>Value1</code> is a member of the <code>MyType</code> set/domain)</p>
<h3><a class="header" href="#functions-reexamined" id="functions-reexamined">Functions Reexamined</a></h3>
<p>Functions can be either pure or impure. Pure functions have 3 properties, but the third (marked with <code>*</code>) is expanded to show its full weight:</p>
<table><thead><tr><th></th><th>Pure</th><th>Pure Example</th><th>Impure</th><th>Impure Example</th></tr></thead><tbody>
<tr><td>Given an input, will it always return some output?</td><td>Always<br>(Total Functions)</td><td><code>n + m</code></td><td>Sometimes<br>(Partial Functions)</td><td><code>4 / 0 == undefined</code></td></tr>
<tr><td>Given the same input, will it always return the same output?</td><td>Always <br> (Deterministic Functions)</td><td><code>1 + 1</code> always equals <code>2</code></td><td>Sometimes <br> (Non-Deterministic Functions)</td><td><code>random.nextInt()</code></td></tr>
<tr><td>*Does it interact with the real world?</td><td>Never</td><td></td><td>Sometimes</td><td><code>file.getText()</code></td></tr>
<tr><td>*Does it acces or modify program state</td><td>Never</td><td><code>newList = oldList.removeElemAt(0)</code><br>Original list is copied but never modified</td><td>Sometimes</td><td><code>x++</code><br>variable <code>x</code> is incremented by one.</td></tr>
<tr><td>*Does it throw exceptions?</td><td>Never</td><td></td><td>Sometimes</td><td><code>function (e) { throw Exception(&quot;error&quot;) }</code></td></tr>
</tbody></table>
<p>Pure functions can better be explained as mapping some input to some output. The simplest example is pattern matching:</p>
<pre><code class="language-haskell">data Fruit = Apple | Orange

stringify :: Fruit -&gt; String
stringify Apple = &quot;Apple&quot;
stringify Orange = &quot;Orange&quot;
</code></pre>
<p>The function, <code>stringify</code>, doesn't &quot;do&quot; anything: it doesn't modify its arguments, nor does it really &quot;use&quot; its arguments in some manner. Rather, it merely defines what to output when given some input.</p>
<p>In this way, functions merely specify how to map values of some type (e.g. Fruit) to values of another type (e.g. String). This idea is the heart of Category Theory. Thus, types and functions go hand-in-hand.</p>
<h2><a class="header" href="#kinds-redefined" id="kinds-redefined">Kinds Redefined</a></h2>
<p>Previously, we said:</p>
<blockquote>
<p>Kinds = &quot;How many more types do I need defined before I have a 'concrete' type?&quot;</p>
</blockquote>
<p>And using the table from earlier...</p>
<table><thead><tr><th>Example</th><th align="right">Kind</th><th>Meaning</th></tr></thead><tbody>
<tr><td>String</td><td align="right">Type</td><td>Concrete value</td></tr>
<tr><td>Int</td><td align="right">Type</td><td>Concrete value</td></tr>
<tr><td>Box a</td><td align="right">Type -&gt; Type</td><td>Higher-Kinded Type (by 1)<br>One type needs to be defined before the type can be instantiated</td></tr>
<tr><td>(a -&gt; b)<br>Function a b</td><td align="right">Type -&gt; Type -&gt; Type</td><td>Higher-Kinded Type (by 2)<br>Two types need to be defined before the type can be instantiated</td></tr>
</tbody></table>
<p>This definition sufficed when we were learning only value-level programming. In reality, it's more like this:</p>
<table><thead><tr><th>Name</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Kind</td><td>A &quot;Type&quot; for type-level programming</td></tr>
<tr><td>Type</td><td>The &quot;kind&quot; (i.e. type-level type) that indicates a value-level type for value-level programming</td></tr>
</tbody></table>
<p>Sometimes, pictures say a lot more than words:
<img src="content/11-Syntax/03-Type-Level-Programming-Syntax/src/../assets/Comparing-Kinds-With-Types.svg" alt="comparing-kinds-with-types" title="Comparing Kinds with Types" /></p>
<p>We can now modify the definition to account for this new understanding:</p>
<blockquote>
<p>Kinds = &quot;How many more type-level types do I need defined before I have a 'concrete' type-level type? Also, the kind, <code>Type</code>, is a type-level type whose 'values'/'members' are value-level types.</p>
</blockquote>
<h3><a class="header" href="#summary-of-inferred-kinds" id="summary-of-inferred-kinds">Summary of Inferred Kinds</a></h3>
<p>Returning to a table we showed previously, we'll add the header that we removed (all caps) when we first displayed the table and include <code>Record</code>/<code>Row</code>.</p>
<table><thead><tr><th>TYPE-LEVEL EXPRESSION</th><th align="right">Inferred kind</th></tr></thead><tbody>
<tr><td><code>Unit</code></td><td align="right"><code>Type</code></td></tr>
<tr><td><code>Array Boolean</code></td><td align="right"><code>Type</code></td></tr>
<tr><td><code>Array</code></td><td align="right"><code>Type -&gt; Type</code></td></tr>
<tr><td><code>Either Int String</code></td><td align="right"><code>Type</code></td></tr>
<tr><td><code>Either Int</code></td><td align="right"><code>Type -&gt; Type</code></td></tr>
<tr><td><code>Either</code></td><td align="right"><code>Type -&gt; Type -&gt; Type</code></td></tr>
<tr><td><code>Record (foo :: Int)</code></td><td align="right"><code>Type</code></td></tr>
<tr><td><code>Record</code></td><td align="right"><code>Row Type -&gt; Type</code></td></tr>
<tr><td><code>(foo :: Int)</code></td><td align="right"><code>Row Type</code></td></tr>
<tr><td>...</td><td align="right">...</td></tr>
</tbody></table>
<h2><a class="header" href="#type-level-programming-flow" id="type-level-programming-flow">Type-Level Programming Flow</a></h2>
<p>Type-Level programming has 2-3 stages:</p>
<ul>
<li>Creation
<ul>
<li>Define a type-level value by declaring a literal one</li>
<li><strong>Reification</strong> - convert a value-level (i.e. runtime value) value into a type-level value via a <code>Proxy</code> type</li>
</ul>
</li>
<li>(optional) Modify that value during compile-time</li>
<li>Terminal
<ul>
<li>Constrain types, so that an impossible state/code fails with a compiler error</li>
<li><strong>Reflection</strong> - convert a type-level value stored in the <code>Proxy</code> type into a value-level value</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#related-papers" id="related-papers">Related Papers</a></h2>
<ul>
<li><a href="http://www.cse.chalmers.se/%7Ehallgren/Papers/hallgren.pdf">Fun with Functional Dependencies</a></li>
</ul>
<h1><a class="header" href="#01-defining-custom-kindspurs" id="01-defining-custom-kindspurs">01-Defining-Custom-Kinds.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.DefiningCustomKinds where

----------------------
-- To change the value-level type into a type-level type:
data Value_Level_Type
  = Value_Level_Value1
  | Value_Level_Value2
----------------------
-- We first define a data type that does not have any data constructors.
-- This indicates that `Type_Level_Type` is a kind we created.
data Type_Level_Type

-- Then, we use FFI-like syntax to declare the type-level values that kind
-- has. We do not declare a right hand side (RHS) since it has no values
--                    |--------- RHS -------|
--      data SomeType = Value1 | Value2
-- Rather, we indicate that the type is a member of that kind using
-- the following syntax:
foreign import data Type_Level_Value1 :: Type_Level_Type
foreign import data Type_Level_Value2 :: Type_Level_Type

-- Note: there is no corresponding javascript file for this one
-- despite the &quot;foreign import&quot; syntax!
----------------------

-- Using a Boolean-like value-level type as an example...
data YesNo = Yes | No

data YesNoKind

foreign import data YesK :: YesNoKind
foreign import data NoK  :: YesNoKind
----------------------
</code></pre>
<h1><a class="header" href="#02-kind-signaturespurs" id="02-kind-signaturespurs">02-Kind-Signatures.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.KindSignatures where

-- We showed previously that `data`, `type`, `newtype`, and `class` declarations
-- can all have explicit kind signatures. In previous situations,
-- kind signatures only used the kind, `Type`. Now that we know how to
-- define our own custom kind, let's use it below.

data A_Kind_I_Created
foreign import data Only_Value_For_My_Kind :: A_Kind_I_Created

data DataExample :: A_Kind_I_Created -&gt; Type
data DataExample a_kind_I_created_type_level_value = DataExample

-- This will succesfully compile because `Only_Value_For_My_Kind` has
-- kind, `A_Kind_I_Created`, which matches the one expected in the
-- declaration for `DataExample`.
compileStatus_success :: DataExample Only_Value_For_My_Kind
compileStatus_success = DataExample

-- This will fail to compile because `String` has
-- kind, `Type`, not kind, `A_Kind_I_Created`.
--
-- compileStatus_fail :: DataExample String
-- compileStatus_fail = DataExample

type TypeExample :: A_Kind_I_Created -&gt; Type
type TypeExample a_kind_I_created_type_level_value = Int

newtype NewtypeExample :: A_Kind_I_Created -&gt; Type
newtype NewtypeExample a_kind_I_created_type_level_value = NewtypeExample Int

-- Similarly, a type class can use kinds other than `Type`. This type class
-- does not have any functions/values:
class TypeClassExample :: A_Kind_I_Created -&gt; Constraint
class TypeClassExample a_kind_I_created_type_level_value
</code></pre>
<h1><a class="header" href="#03-polymorphic-kindspurs" id="03-polymorphic-kindspurs">03-Polymorphic-Kinds.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.PolymorphicKinds where

-- In the previous file, the following would not compile because `String` has
-- a kind that is different than the one expected by `MyData` below:

data MyKind
foreign import data OnlyValueForMyKind :: MyKind

data MyData :: MyKind -&gt; Type
data MyData typeThatHasKind_'myKind' = MyData

-- Fails to Compile:
-- compileStatus_fail :: MyData String
-- compileStatus_fail = MyData

-- What if we wanted `MyData` to work &quot;for all&quot; kinds: `Type`, `MyKind`, or
-- one written by someone else? We would use &quot;forall&quot; syntax. This syntax
-- should look similar to how we would write it for a value-level function:
valueLevelFunction :: forall a. a -&gt; a
valueLevelFunction valueOfType_a = valueOfType_a

-- Note: `kind` is often abbreviated as `k` to indicate kind.
data MyDataPolyKind :: forall kind. kind -&gt; Type
data MyDataPolyKind typeThatHasAGivenKind = MyDataPolyKind

compilesSuccessfully1 :: MyDataPolyKind String -- kind is Type
compilesSuccessfully1 = MyDataPolyKind

compilesSuccessfully2 :: MyDataPolyKind OnlyValueForMyKind -- kind is MyKind
compilesSuccessfully2 = MyDataPolyKind
</code></pre>
<h1><a class="header" href="#04-proxypurs" id="04-proxypurs">04-Proxy.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Proxy where

-- When we write programs, arguments and definitions are at the value-level.
-- Since the values of type-level types (i.e. kinds) are types themselves,
-- how do we pass type-level values around in our program when the program
-- is written at the value level?

-- For type-level values, we use a simple type that &quot;stores&quot; the type-level
-- value as a phantom type (see `Design Patterns/Phantom Types.md`).
-- By making that phantom type polymorphic on kinds (i.e polykinded),
-- one type will work for all kinds:
data Proxy :: forall kind. kind -&gt; Type
data Proxy k = Proxy

-- Given that we have the following two custom kinds...

-- data Kind_1
--   = Kind_1_Value_1
--   = Kind_1_Value_2
data Kind_1
foreign import data Kind_1_Value_1 :: Kind_1
foreign import data Kind_1_Value_2 :: Kind_1

data Kind_2
foreign import data Kind_2_Value :: Kind_2

-- ... we can define a value that stores the type-level value via `Proxy` ...

kind1Value1 :: Proxy Kind_1_Value_1
kind1Value1 = Proxy

kind2Value :: Proxy Kind_2_Value
kind2Value = Proxy

-- ... and pass around the type-level values by passing around the Proxy value
-- and annotating the type signature with the type-level value.

-- This function only works on the first `Kind_1_Value`.
kind1_to_kind2_specific :: Proxy Kind_1_Value_1 -&gt; Proxy Kind_2_Value
kind1_to_kind2_specific _ {- Proxy, which can be ignored -} =
  Proxy -- Proxy whose type is different than first Proxy type

-- This function only works on all possible `Kind_1_Value`s.
kind1_to_kind2_generic
  :: forall (kind1Values :: Kind_1) (kind2Values :: Kind_2)
   . Proxy kind1Values
  -&gt; Proxy kind2Values
kind1_to_kind2_generic _ {- Proxy, which can be ignored -} =
  Proxy -- Proxy whose type is different than first Proxy type

-- The above definition will make more sense in the future.
</code></pre>
<h1><a class="header" href="#defining-functions" id="defining-functions">Defining Functions</a></h1>
<h2><a class="header" href="#solve-for-x" id="solve-for-x">Solve for X</a></h2>
<p>Normally, when we define a function for value-level programming, it looks like this:</p>
<pre><code class="language-haskell">function :: InputType -&gt; OutputType
function InputValue = OutputValue
</code></pre>
<p>In other words, when given <code>InputValue</code>, return <code>OutputValue</code>. The direction of this &quot;relationship&quot; is ALWAYS in one direction: to the right (i.e. <code>-&gt;</code>).</p>
<p>When we define a function for type-level programming, we're not defining a function that takes some input and returns an output. Rather, we are defining a &quot;relationship&quot; between some input(s) and some output(s). In other words, these &quot;relationships&quot; can be applied in multiple directions to create multiple functions. One could say that type-level functions work in <strong>multiple directions</strong>. To put it another way...:</p>
<ul>
<li><code>function InputValue</code> outputs <code>OutputValue</code></li>
<li><code>function OutputValue</code> outputs <code>InputValue</code></li>
</ul>
<p>Let's give a much clearer example by solving an equation:</p>
<pre><code>total = x + y
</code></pre>
<p>Right now, the equation is making us solve for <code>total</code>. However, with some simple rearranging, we can make it solve for <code>x</code></p>
<pre><code>total = x + y
total - y = x + y - y
total - y = x
x = total - y
</code></pre>
<p>We can also make it solve for <code>y</code>:</p>
<pre><code>total = x + y
total - x = x - x + y
total - x = y
y = total - x
</code></pre>
<p>Thus, we can take this &quot;relationship&quot;/equation and figure out one entity if we know the other two entities. Putting it into programming terms, if we have one relationship/equation (like that above), we can define three functions:</p>
<ol>
<li><code>f1 :: X -&gt; Y     -&gt; Total</code></li>
<li><code>f2 :: X -&gt; Total -&gt; Y</code></li>
<li><code>f3 :: Y -&gt; Total -&gt; X</code></li>
</ol>
<p>This is the same idea used in type-level programming. So, how does this actually work in Purescript? Multi-parameter type classes and functional dependencies.</p>
<table><thead><tr><th>The Relationship/Equation</th><th>The Number of Functions &amp; its type signature</th><th>The implementation of a function</th></tr></thead><tbody>
<tr><td>a multi-parameter type class</td><td>functional dependencies (the exact number depends)</td><td>type class instances</td></tr>
</tbody></table>
<p>For example, assuming we had 1) a type-level number called <code>IntK</code>, 2) its value-level Proxy type, <code>IProxy</code>, and 3) instances for the below type class, we could write an <code>add</code> and two <code>subtract</code> functions using just one relationship:</p>
<pre><code class="language-haskell">-- the relationship itself
class AddOrSubtract :: IntK -&gt; IntK -&gt; IntK -&gt; Constraint
class AddOrSubtract x y total
  -- the normal &quot;add&quot; function: &quot;total = x + y&quot;
  | x y -&gt; total

  -- the first 'subtract' function: &quot;y = total - x&quot;
  , x total -&gt; y
  -- the second 'subtract' function: &quot;x = total - y&quot;
  , y total -&gt; x
</code></pre>
<p>Then, we could use this one relationship as three different functions:</p>
<pre><code class="language-haskell">-- given two IntK values, I can add them together by returning
-- `total`, which is &quot;calculated&quot; via the type class `AddOrSubtract`
addTwoIntK :: forall x y total
            . AddOrSubtract x y total
           =&gt; IProxy x -&gt; IProxy y -&gt; IProxy total
addTwoIntK _ _ = IProxyValue

-- given two IntK values, I can subtract one from another by
-- returning `x`/`y`, which is &quot;calculated&quot;
-- via the type class `AddOrSubtract`
subtractIntK_1 :: forall x y total
                . AddOrSubtract x y total
               =&gt; IProxy x -&gt; IProxy total -&gt; IProxy y
subtractIntK_1 _ _ = IProxyValue

subtractIntK_2 :: forall x y total
                . AddOrSubtract x y total
               =&gt; IProxy y -&gt; IProxy total -&gt; IProxy x
subtractIntK_2 _ _ = IProxyValue
</code></pre>
<h2><a class="header" href="#unification" id="unification">Unification</a></h2>
<h3><a class="header" href="#an-overview-and-how-type-level-functions-compute" id="an-overview-and-how-type-level-functions-compute">An Overview and How Type-Level Functions &quot;Compute&quot;</a></h3>
<p>Recall that the type checker / type constraint solver &quot;computes&quot; type-level expressions by figuring out what type something is. Thus, the above analogy is helpful for understanding type-level programming, but it is incomplete without an explanation on how types &quot;unify&quot;. In short, <strong>unification</strong> is the way by which the compiler infers or figures out some type. For our context, it is how the type checker computes the &quot;type-level output&quot; of a type-level function. It does this by unifying the undefined types in a type class' definition with a concrete type's instance of that type class.</p>
<p>Let's review something first. In a type class definition and its instance, we have terms to refer to specific parts of it:</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String

{-            |  1   |         |  2  |                                -}
instance (Show a) =&gt; Show (Box a) where
  show (Box a) = show a
</code></pre>
<ol>
<li>Instance Context</li>
<li>Instance Head</li>
</ol>
<p>The &quot;Instance Context&quot; and &quot;Instance Head&quot; terms are crucial to understanding the unification rules below.</p>
<p>Unification is how logic programming works. A popular language which uses logic programming to compute is Prolog, which has a nice explanation on unification. (Curious readers can see the bottom of the file for links about Prolog). To see the rules for how this works in general, I've adapted the Prolog unification rules defined by Blackburn et al. below:</p>
<ol>
<li>Two concrete terms unify. A &quot;term&quot; for this explanation is either a <code>Type</code> or a <code>Kind</code>:
<ul>
<li>Type
<ul>
<li><code>String</code> unifies with <code>String</code></li>
<li><code>String</code> does not unify with <code>Int</code></li>
</ul>
</li>
<li>Kind
<ul>
<li>kind <code>BooleanK</code> unifies with kind <code>BooleanK</code></li>
<li>kind <code>BooleanK</code> does not unify with kind <code>IntK</code></li>
</ul>
</li>
<li>a Kind term only unifies with other Kind terms, not Type terms.</li>
<li>a Type term only unifies with other Type terms, not Kind terms.</li>
</ul>
</li>
<li>A concrete term and a polymorphic/generic term (i.e. term variable) unify and the term variable is assigned to a concrete term:
<ul>
<li>Similar to how a variable can be assigned a value, <code>let a = 5</code>, so one assigns a term to a term variable: <code>a = Int</code> (type variable assigned to a concrete type) or <code>a = IntK</code> (kind variable assigned to a concrete kind). By this analogy, every time one sees an <code>a</code> type/kind in a type/kind signature, they can replace it with <code>Int</code>/<code>IntK</code>.</li>
</ul>
</li>
<li>Two term variables unify and their relationship is saved
<ul>
<li>Ignoring the <code>forall .</code> syntax, given <code>f :: Add a b c =&gt; Add c d e =&gt; a -&gt; b -&gt; d -&gt; e</code>, the <code>c</code> type/kind in both <code>Add</code> constraints are unified and their relationship is &quot;saved&quot;. As soon as one of them is assigned to a concrete term, the other will be assigned that term, too.</li>
</ul>
</li>
<li>Complex &quot;term chains&quot; (e.g. a type class and a concrete type's instance of that type class) unify if and only if all of their corresponding arguments unify:
<ul>
<li>the number of parameter terms in the type class is the same number of terms in the instance
<ul>
<li><code>class MyClass first second</code></li>
<li><code>instance MyClass String Int</code></li>
</ul>
</li>
<li>instance types unify with the class' constraints
<ul>
<li><code>class (SuperClass constrained) &lt;= ThisClass constrained</code></li>
<li><code>instance SuperClass String</code></li>
<li><code>instance ThisClass String</code></li>
</ul>
</li>
<li>types in the instance context unify with their corresponding class
<ul>
<li><code>instance OtherConstraint a</code></li>
<li><code>instance (OtherConstraint a) =&gt; FastClass a</code></li>
</ul>
</li>
<li>the type of terms in the type class unify only with their corresponding term type in the instance:
<ul>
<li>The type class' Kind terms are made to unify only with other Kind terms, not Type terms, in the instance</li>
<li>The type class' Type terms are made to unify only with other Type terms, not Kind terms, in the instance.</li>
</ul>
</li>
<li>a term variable is only assigned once and is not assigned to two different concrete term during the unification process</li>
</ul>
</li>
</ol>
<p>A type-level function can only &quot;compute&quot; a type-level expression when the types unify. This will fail in a few situations (this list may not be exhaustive):</p>
<ul>
<li>infinite unification: to unify some term, <code>a</code>, one must unify some term, <code>b</code>, which can only be unified if <code>a</code> is unified. After making X many recursive steps, the type inferencer will eventually give up and throw an error. This is a hard-coded number in the Purescript compiler.</li>
<li>situations where the type inferencer cannot infer the correct type/kind</li>
<li>situations where one needs to do &quot;backtracking&quot;.</li>
</ul>
<h3><a class="header" href="#backtracking-is-not-currently-supported" id="backtracking-is-not-currently-supported">Backtracking Is Not (Currently) Supported</a></h3>
<p>Here is an example of &quot;backtracking&quot;. It will make more sense after you have read through the <code>Pattern-Matching-Using-Instance-Chains.purs</code> file.</p>
<pre><code class="language-haskell">class MyClass a
  someValue :: Boolean

instance (SomeConstraint a) =&gt; MyClass a where
  someValue = true
else instance MyClass a where
  someValue = false
</code></pre>
<p>Here's the steps the compiler walks through:</p>
<ol>
<li>Find the first instance for MyClass ('firstInstance')</li>
<li>Commit to that instance and check whether the <code>a</code> type fulfills the <code>SomeConstraint</code> type class, too.</li>
<li>The <code>a</code> type does not satisfy that type class constraint.</li>
<li>The type checker fails.</li>
</ol>
<p>The issue lies in step 2: the instance head is checked before the instance context. Once the type inferer commits to some instance, it cannot 'backtrack' to the starting position after realizing that its current instance fails. Ideally, the type inferer would jump back to step 2 and realize that there is another instance ('secondInstance') that always works for any <code>a</code> type (since there is no constraint).</p>
<p>&quot;Backtracking&quot; could be implemented in the compiler by using instance guards, but this has not yet been done. For the current progress on this issue, see <a href="https://github.com/purescript/purescript/issues/3120">the related Purescript issue</a>.</p>
<h3><a class="header" href="#more-resources-for-understanding-unification" id="more-resources-for-understanding-unification">More Resources for Understanding Unification</a></h3>
<p>To understand unification at a deeper level, see these links:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ytPAlhnAKro">Type Inference from Scratch</a>. This video explains the ideas behind the notation used in the paper below.</li>
<li><a href="https://www.youtube.com/watch?v=il3gD7XMdmA">Introduction to Type Inference</a>. This video will explain a few more pieces of the notation used in the paper below as well as the problems that arise in type inference. Unfortunately, the teacher goes through concepts quickly and runs out of time, so not everything is immediately understandable through the first viewing.</li>
<li><a href="https://www.youtube.com/embed/SPpIbiZFPRY?start=2258">Phil's overview of the Purescript Type's System</a>, where he shows how the compiler unifies types using the same notation above.</li>
<li><a href="http://web.cecs.pdx.edu/%7Empj/pubs/instancechains.pdf">The original paper describing instance chains</a>.</li>
</ul>
<h2><a class="header" href="#functional-dependencies-reexamined" id="functional-dependencies-reexamined">Functional Dependencies Reexamined</a></h2>
<p>At times, it can be difficult for the type checker to infer what a given type is. Thus, one uses functional dependencies (FDs) to help the compiler. As a reminder, FDs inform the compiler how to infer what some types are given that it knows other types:</p>
<pre><code class="language-haskell">class Add :: IntK -&gt; IntK -&gt; IntK -&gt; Constraint
class Add x y total
  | x y -&gt; total
  , y total -&gt; x
  , x total -&gt; y
</code></pre>
<p>However, sometimes the functional dependencies get a bit more complicated because there are two types on the right-hand side of the arrow. This is where our analogy of a &quot;FDs are type-level functions&quot; starts to break down since a value-level function can only return one value at a time. (Granted, one can use a <code>Tuple</code> or <code>Record</code> to return multiple values in a container, but the principle still applies.) <strong>With our &quot;relationships&quot;, a single FD can sometimes define multiple type-level functions depending on how we use them.</strong></p>
<p>For example, look at the second FD of <a href="https://pursuit.purescript.org/builtins/docs/Prim.Row#t:Cons"><code>Prim.Row.Cons</code></a>:</p>
<pre><code class="language-haskell">-- Note: Symbol is a type-level String
class Cons :: forall kind. Symbol -&gt; kind -&gt; Row kind -&gt; Row kind -&gt; Constraint
class Cons label a tail row
  | label a tail -&gt; row
  , label row -&gt; a tail
</code></pre>
<p>The first FD can be read as</p>
<blockquote>
<p>If you give me a label, its type-level value, and a pre-existing row (i.e. tail), then I can append that &quot;label and type-level value&quot; association to the tail and give you back the result of the append (i.e. row).&quot;</p>
</blockquote>
<p>The second FD can be read as</p>
<blockquote>
<p>If you provide me a row and the name of a label in that row, then I can give you either</p>
<ol>
<li>that label's type</li>
<li>a row that excludes that label-value association (i.e. the tail)&quot;, or</li>
<li>both</li>
</ol>
</blockquote>
<p>Let's demonstrate a few different examples via the REPL. This will be covered in more detail in this folder:</p>
<ol>
<li>Run <code>spago repl</code></li>
<li>Import the <code>Prim.Row</code> module via <code>import Prim.Row</code></li>
<li>Use the <code>:paste</code> followed by <code>CTRL+D</code> to paste the multi-line <code>verify*</code> functions below into the REPL.</li>
<li>Pass the corresponding arguments into the function to verify that it compiles.</li>
</ol>
<pre><code>-- spago repl
-- import Prim.Row

-- :paste
verifyAddingRowToTailCompiles
  :: forall tail finalRow
   . Cons &quot;first&quot; String tail finalRow
  =&gt; Record tail -&gt; Record finalRow -&gt; String
verifyAddingRowToTailCompiles _ _ =
  &quot;If you see this message rather than an error, the relationship is true.&quot;
-- CTRL+D

-- Run the below function
verifyAddingRowToTailCompiles {apple: &quot;haha&quot;} {apple: &quot;haha&quot;, first: &quot;text&quot; }

-- Great! Let's now switch the `tail` and `finalRow` types
-- in the `Cons` relationship. 

-- :paste
verifyRemovingRowFromTailCompiles
  :: forall tail finalRow
   . Cons &quot;first&quot; String finalRow tail
  =&gt; Record tail -&gt; Record finalRow -&gt; String
verifyRemovingRowFromTailCompiles _ _ =
  &quot;If you see this message rather than an error, the relationship is true.&quot;
-- CTRL+D

-- Run the below function
verifyRemovingRowFromTailCompiles {apple: &quot;haha&quot;, first: &quot;text&quot; } {apple: &quot;haha&quot;}
</code></pre>
<h2><a class="header" href="#prolog-links" id="prolog-links">Prolog Links</a></h2>
<p>Learning Prolog is not necessary to understand how to do type-level programming. However, one may want to learn more about it to understand the idea of unification better. If so, these links helped me understand Prolog:</p>
<ul>
<li>the &quot;Learn Prolog Now&quot; book, <a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-html">chapter 1 - 2</a></li>
<li>the <a href="https://learnxinyminutes.com/docs/prolog/">&quot;Learn X in Y minutes where X = Prolog&quot;</a></li>
<li>this <a href="https://www.doc.gold.ac.uk/%7Emas02gw/prolog_tutorial/prologpages/">Intro to Prolog</a></li>
</ul>
<h2><a class="header" href="#works-cited" id="works-cited">Works Cited</a></h2>
<p>(for lack of a better section header name...)</p>
<p>Blackburn, Patrick, et al. &quot;2.1: Unification.&quot; <em>Learn Prolog Now!</em> vol. 7, College Publications, 2006, http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse5. Accessed 9 Oct. 2018</p>
<h1><a class="header" href="#01-single-arg-syntaxpurs" id="01-single-arg-syntaxpurs">01-Single-Arg-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Functions.SingleArgSyntax where

-- Given the following value-level and type-level types/values...

data InputType = InputValue
data OutputType = OutputValue

data InputKind
foreign import data InputValueK :: InputKind

data OutputKind
foreign import data OutputValueK :: OutputKind

-- ... a value-level function...

-- function's type signature
function :: InputType -&gt; OutputType
-- function's implementation
function InputValue = OutputValue

-- ... can be converted to a type-level function using
--   - type classes
--   - functional dependencies

-- the relationship
class TypeLevelFunction :: InputKind -&gt; OutputKind -&gt; Constraint
class TypeLevelFunction input output
  -- one function's type signature
  | input -&gt; output

  -- another function's type signature
  , output -&gt; input

-- the implementation for both functions (since this is a simple example)
instance TypeLevelFunction InputValueK OutputValueK
</code></pre>
<h1><a class="header" href="#02-multi-arg-syntaxpurs" id="02-multi-arg-syntaxpurs">02-Multi-Arg-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Functions.MultiArgSyntax where

-- Given the following value-level and type-level types/values...

data InputType1 = InputValue1
data InputType2 = InputValue2
data OutputType = OutputValue

data InputKind1
foreign import data InputValueK1 :: InputKind1

data InputKind2
foreign import data InputValueK2 :: InputKind2

data OutputKind
foreign import data OutputValueK :: OutputKind

-- ... a value-level function...

-- function's type signature
function :: InputType1 -&gt; InputType2 -&gt; OutputType
-- function's implementation
function InputValue1 InputValue2 = OutputValue

-- ... converts to

-- The relationship
class TypeLevelFunction :: InputKind1 -&gt; InputKind2 -&gt; OutputKind -&gt; Constraint
class TypeLevelFunction input1 input2 output
  -- the functions' type signatures
  | input1 input2 -&gt; output
  , input1 output -&gt; input2
  , input2 output -&gt; input1

-- functions sole implementation
instance implementation ::
  TypeLevelFunction InputValueK1 InputValueK2 OutputValueK
</code></pre>
<h1><a class="header" href="#03-pattern-matching-using-instancespurs" id="03-pattern-matching-using-instancespurs">03-Pattern-Matching-Using-Instances.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Functions.PatternMatching.InstancesOnly where

-- To handle more pattern matching, we add more values of the type class

-- This...
data InputType2
  = InputValue1
  | InputValue2
  | InputValue3

data OutputType2
  = OutputValue1
  | OutputValue2
  | OutputValue3

function2 :: InputType2 -&gt; OutputType2
function2 InputValue1 = OutputValue1 -- first pattern match
function2 InputValue2 = OutputValue2 -- second pattern match
function2 InputValue3 = OutputValue3 -- third pattern match

-- ... converts to...

data InputKind
foreign import data InputValue1 :: InputKind
foreign import data InputValue2 :: InputKind
foreign import data InputValue3 :: InputKind

data OutputKind
foreign import data OutputValue1 :: OutputKind
foreign import data OutputValue2 :: OutputKind
foreign import data OutputValue3 :: OutputKind

-- the relationship
class TypeLevelFunction :: InputKind -&gt; OutputKind -&gt; Constraint
class TypeLevelFunction input output
  -- the functions' type signatures
  | input -&gt; output
  , output -&gt; input

-- the implementations via pattern matching
instance firstPatternMatch  :: TypeLevelFunction InputValue1 OutputValue1
instance TypeLevelFunction InputValue2 OutputValue2
instance thirdPatternMatch  :: TypeLevelFunction InputValue3 OutputValue3

--------------------------------------------
-- An example using YesNo and Zero/One
data YesNo     = Yes  | No
data ZeroOrOne = Zero | One

toInt :: YesNo -&gt; ZeroOrOne
--    input = output
toInt Yes = One
toInt No = Zero

-- converts to

data YesNoKind
foreign import data YesK :: YesNoKind
foreign import data NoK  :: YesNoKind

data ZeroOrOneKind
foreign import data OneK  :: ZeroOrOneKind
foreign import data ZeroK :: ZeroOrOneKind

class ToInt :: YesNoKind -&gt; ZeroOrOneKind -&gt; Constraint
class ToInt input output | input -&gt; output

instance ToInt YesK OneK
instance ToInt NoK  ZeroK
</code></pre>
<h1><a class="header" href="#04-pattern-matching-using-instance-chainspurs" id="04-pattern-matching-using-instance-chainspurs">04-Pattern-Matching-Using-Instance-Chains.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Functions.PatternMatching.InstanceChains where

{-
So far, our type-level function's pattern matches use literal values.

Whenever we write...
   instance TL_Function InputValue1 OutputValue1
   instance TL_Function InputValue2 OutputValue2

... it's the equivalent of writing

   tl_Function :: Input -&gt; Output
   tl_Function InputValue1 = OutputValue1
   tl_Function InputValue2 = OutputValue2

-}

-- Let's say we have the given value-level and type-level types/values:
data Fruit
  = Apple
  | Orange
  | Banana
  | Blueberry
  | Cherry

data ZeroOrOne = Zero | One

data FruitKind
foreign import data AppleK     :: FruitKind
foreign import data OrangeK    :: FruitKind
foreign import data BananaK    :: FruitKind
foreign import data BlueberryK :: FruitKind
foreign import data CherryK    :: FruitKind

data ZeroOrOneKind
foreign import data ZeroK :: ZeroOrOneKind
foreign import data OneK  :: ZeroOrOneKind

-- To write pattern matches with a 'catch-all' underscore binding

fruitToInt :: Fruit -&gt; ZeroOrOne
fruitToInt Apple                    = Zero
fruitToInt _ {- Orange .. Cherry -} = One

-- we can use a feature called &quot;Type Class Instance Chains:&quot;

class FruitToInt :: FruitKind -&gt; ZeroOrOneKind -&gt; Constraint
class FruitToInt a i
  | a -&gt; i                                                                {-

  Notice that we have omitted this type signature because
  we don't know what to do when we know `i` but not `a`

  , i -&gt; a                                                                -}


instance FruitToInt AppleK ZeroK
else instance FruitToInt a OneK

{-
which is the same as writing...

  instance FruitToInt AppleK     ZeroK
  instance FruitToInt OrangeK    OneK
  instance FruitToInt BananaK    OneK
  instance FruitToInt BlueBerryK OneK
  instance FruitToInt CherryK     OneK
-}

{-
As of this writing, Purescript does not support all of the features
described in the paper below (i.e. backtracking), but it does work
for simpler use cases like above

Here's the related Purescript issue:
https://github.com/purescript/purescript/issues/2315

See the original paper here:
http://homepages.inf.ed.ac.uk/jmorri14/pubs/morris-icfp2010-instances.pdf
-}
</code></pre>
<h1><a class="header" href="#01-reflectionpurs" id="01-reflectionpurs">01-Reflection.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Reflection where

-- ignore this
import Prelude (class Show)

-- Reflection syntax
--  Converting a type-level value into a value-level value

-- This code...
----------------------------
type Value_Level_Type = String -- for easier readability

data CustomType = TypeValue

reflectVL :: CustomType -&gt; Value_Level_Type
reflectVL TypeValue = &quot;value-level value&quot;
----------------------------
-- ... converts to...
----------------------------
data CustomKind
foreign import data CustomKindValue :: CustomKind

data Proxy :: forall k. k -&gt; Type
data Proxy kind = Proxy

-- &quot;type-level value to value-level value&quot;
class TLI_to_VLI :: CustomKind -&gt; Constraint
class TLI_to_VLI customKind where
  reflectCustomKind :: Proxy customKind -&gt; Value_Level_Type

instance TLI_to_VLI CustomKindValue where {-
  reflectCustomKind Proxy = &quot;value-level value&quot; -}
  reflectCustomKind _     = &quot;value-level value&quot;
----------------------------

-- An example using the Boolean-like data type YesNo:
data YesNo = Yes | No

data YesNoKind
foreign import data YesK :: YesNoKind
foreign import data NoK  :: YesNoKind

{-
Read yesK and noK as:
  yesK = (YesNoProxyValue :: YesNoProxy Yes) - a value of type &quot;YesNoProxy Yes&quot;
  noK  = (YesNoProxyValue :: YesNoProxy No)  - a value of type &quot;YesNoProxy No&quot; -}
yesK :: Proxy YesK
yesK = Proxy

noK :: Proxy NoK
noK = Proxy

class IsYesNoKind :: YesNoKind -&gt; Constraint
class IsYesNoKind a where
  reflectYesNo :: Proxy a -&gt; YesNo

instance IsYesNoKind YesK where
-- reflectYesNo (Proxy :: Proxy Yes) = Yes
   reflectYesNo _                    = Yes

instance IsYesNoKind NoK where
-- reflectYesNo (Proxy :: Proxy No) = No
   reflectYesNo _                   = No


-- We can also use instance chains here to distinguish
-- one from another

class IsYes :: YesNoKind -&gt; Constraint
class IsYes a where
  isYes :: Proxy a -&gt; YesNo

instance IsYes YesK where
  isYes _ = Yes
else instance IsYes a where
  isYes _ = No

-- Using instance chains here is more convenient if we had
-- a lot more type-level values than just 2. In some cases,
-- it is needed in cases where a type-level type can have an
-- infinite number of values, such as a type-level String

-- Open a REPL, import this module, and then run this code:
--    reflectYesNo yesK
--    reflectYesNo noK
--    isYes yesK
--    isYes noK


-- necessary for not getting errors while trying the functions in the REPL

instance Show YesNo where
    show Yes = &quot;Yes&quot;
    show No  = &quot;No&quot;
</code></pre>
<h1><a class="header" href="#02-reificationpurs" id="02-reificationpurs">02-Reification.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Reification where

-- ignore this
import Prelude (class Show)

-- Reification = value-level value -&gt; type-level value

-- Given a yes/no data type
--
--  data YesNo = Yes | No

-- In value-level programming,
ignoreMe :: String
ignoreMe =
    -- we can write something like this...
    yesno_to_string_function   a_yesno_value_determined_at_runtime

{-
This function does not know which value of the YesNo type
(i.e. `Yes` or `No`) it will be when the program is executed.
However, since the function knows how to map both values
of the YesNo type into an value of a String type, it doesn't matter.

Similarly, for type-level programming, we won't always know which
value of the value-level type it will be. However, if we know how to
reify every value of that value-level type into an value of
a type-level type, it doesn't matter.

Reification works by using callback functions:
-}

-- Given the following code, which
--   - defines the type-Level YesNo and its two values
--   - defines a Proxy type and its two values
--   - defines the reflection function for both values ...
data YesNo = Yes | No

data YesNoKind
foreign import data YesK :: YesNoKind
foreign import data NoK  :: YesNoKind

data Proxy :: forall k. k -&gt; Type
data Proxy kind = Proxy

yesK :: Proxy YesK
yesK = Proxy

noK :: Proxy NoK
noK = Proxy

class IsYesNoKind :: YesNoKind -&gt; Constraint
class IsYesNoKind a where
  reflectYesNo :: Proxy a -&gt; YesNo

instance IsYesNoKind YesK where
  reflectYesNo _ = Yes

instance IsYesNoKind NoK where
  reflectYesNo _ = No

-- We can reify a YesNo by defining a callback function that receives
-- the corresponding type-level value as its only argument
-- (where we do type-level programming):

reifyYesNo :: forall returnType
            . YesNo
            -&gt; (forall b. IsYesNoKind b =&gt; Proxy b -&gt; returnType)
            -&gt; returnType
reifyYesNo Yes function = function yesK
reifyYesNo No  function = function noK

-- necessary for not getting errors while trying the functions in the REPL

instance Show YesNo where
    show Yes = &quot;Yes&quot;
    show No  = &quot;No&quot;

-- necessary to compile

yesno_to_string_function :: YesNo -&gt; String
yesno_to_string_function Yes = &quot;yes&quot;
yesno_to_string_function No  = &quot;no&quot;

a_yesno_value_determined_at_runtime :: YesNo
a_yesno_value_determined_at_runtime = Yes
</code></pre>
<h1><a class="header" href="#10-conventionspurs" id="10-conventionspurs">10-Conventions.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.Conventions where

-- This file shows the patterns and naming schemes used when writing
-- type-level programming code. Refer to this whenever you're lost.

-- Entities that have the comment &quot;NANS&quot; mean &quot;no apparent naming scheme&quot;.
-- In other words, there is not a naming scheme that people seem to follow.
-- So, name it however you want.

-- Entities that do seem to have naming scheme will have their explanation
-- above them in a comment.

type Value_Level_Type = String

data KindName
foreign import data Value :: KindName

data Proxy :: forall k. k -&gt; Type
data Proxy kind = Proxy

-- NANS
inst :: Proxy Value
inst = Proxy

-- The class name is usually &quot;Is[KindName]&quot;
class IsKindName :: KindName -&gt; Constraint
class IsKindName a where
  -- and the reflect function is usually &quot;reflect[KindName]&quot;
  reflectKindName :: Proxy a -&gt; Value_Level_Type

instance IsKindName Value where
  reflectKindName _ = &quot;value-level value&quot;

-- NANS
class IsKindName a &lt;= ConstrainedToKindName a

-- NANS
instance ConstrainedToKindName Value

-- Usually reify[KindName]
reifyKindName :: forall r
           . Value_Level_Type
          -&gt; (forall a. IsKindName a =&gt; Proxy a -&gt; r)
          -&gt; r
reifyKindName valueLevel function = function inst
</code></pre>
<h1><a class="header" href="#05-symbol-syntaxpurs" id="05-symbol-syntaxpurs">05-Symbol-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.SymbolSyntax where

vl_string :: String
vl_string = &quot;a value-level string!&quot;

-- `Symbols` are type-level strings

-- Compiler imports this automatically via the Prim module
data Symbol_

-- This proxy type is defined in the purescript-prelude package
data Proxy :: forall k. k -&gt; Type
data Proxy kind = Proxy

-- use literal string syntax
tl_literalString :: Proxy &quot;a type-level string!&quot;
tl_literalString = Proxy

-- use multi-line string syntax!
tl_multiLineString :: Proxy &quot;a type-level \
                             \string!&quot;
tl_multiLineString = Proxy

-- use triple-quote string syntax
tl_tripleQuoteStringSyntax :: Proxy &quot;&quot;&quot;triple-quote string syntax
 works as long as each new line is indented, so that the compiler
 doesn't think the string is the definition for
 the 'tl_tripleQuoteStringSyntax' function.

 The string will automatically escape special characters
 (e.g. '.', '*', '/').&quot;&quot;&quot;
tl_tripleQuoteStringSyntax = Proxy

{-
Symbol's other type-level programming constructs are in other modules
that must be imported to work:
  - purescript-prelude:
      - `IsSymbol` typeclass
      - `reifySymbol` function
  - prim (type-level functions)
      - Compare: &quot;a&quot; compare &quot;b&quot; == LT
      - Append:  &quot;hello&quot; append &quot;world&quot; == &quot;hello world&quot;
      - Cons:    &quot;a&quot; cons &quot;pple&quot; = &quot;apple&quot;
      - Uncons:  &quot;string&quot; = &quot;s&quot; append &quot;tring&quot;
-}
</code></pre>
<h1><a class="header" href="#06-row-syntaxpurs" id="06-row-syntaxpurs">06-Row-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.TypeLevel.RowSyntax where

-- &quot;row kinds&quot; look like &quot;Row k&quot; where 'k' is another kind.
-- Usually, it's used with the kind, `Type`, to make Records (e.g. &quot;Row Type&quot;)
-- You cannot find that much documentation on `Row` kinds because
-- they are built into the compiler.

type Example_of_an_Empty_Row :: forall k. Row k
type Example_of_an_Empty_Row = ()

type Example_of_a_Single_Row_of_Types = (fieldName :: ValueType)
type Example_of_a_Multiple_Row_of_Types = (first :: ValueType, second :: ValueType)

data Proxy :: forall k. k -&gt; Type
data Proxy kind = Proxy

one_Key_Value_Pair :: Proxy (key :: Int)
one_Key_Value_Pair = Proxy

two_Key_Value_Pairs :: Proxy (key1 :: Int, key2 :: Int)
two_Key_Value_Pairs = Proxy

many_Key_Value_Pair :: Proxy ( key1 :: Int
                              , key2 :: String
                           -- , ...
                              , keyN :: (Int -&gt; String)
                              )
many_Key_Value_Pair = Proxy

nested_Key_Value_Pair :: Proxy (outerKey :: Proxy (innerKey :: Int))
nested_Key_Value_Pair = Proxy

-- Since row kinds can be used with other kinds, one could also define
-- a row of Symbols:
type Example_of_a_Single_Row_of_Symbols = (a :: &quot;a symbol&quot;)
type Example_of_a_Multiple_Row_of_Symbols = (a :: &quot;a symbol&quot;, b :: &quot;another symbol&quot;)

-- These can also be used with the quoted-key syntax (explained previously in the
-- Records folder):
type Quoted_Key_Row_of_Symbols = (&quot;the key&quot; :: &quot;the symbol&quot;)

row_of_symbols_proxy :: Proxy ( firstField :: &quot;this is a symbol&quot;
                              , secondField :: &quot;this is another symbol&quot;
                              )
row_of_symbols_proxy = Proxy

{-
Just like Symbol, Row's other type-level programming constructs
are defined in the built-in `Prim` package and the `purescript-prelude` library.
-}

-- needed to compile
type ValueType = String
</code></pre>
<h1><a class="header" href="#rowlist" id="rowlist">RowList</a></h1>
<p>The final aspect of type-level programming to learn is <a href="https://pursuit.purescript.org/builtins/docs/Prim.RowList"><code>RowList</code></a>. This is where type-level programming often gets interesting because one can do interesting things with records at the type-level.</p>
<p>It is not covered in this folder. Rather, it is covered in <code>Hello World/Type Level Programming/src/RowList</code> because one needs to understand how <a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/5.0.1/docs/Data.Foldable#v:foldl"><code>Data.Foldable.foldl</code></a> works (which is explained in <code>Hello World/Collections and Loops</code>). Until one understands what a &quot;fold left&quot; is, understanding <code>RowList</code> will not make much sense either.</p>
<h1><a class="header" href="#module-syntax" id="module-syntax">Module Syntax</a></h1>
<p>Self-explanatory</p>
<p>Due to the compiler being efficient and not wanting to import unused values/functions/etc., compiling this folder will emit a lot of warnings. If the warnings look like either of these two messages, they can be ignored:</p>
<p>First</p>
<pre><code>Warning [current] of [total]:

  in module Syntax.Module.FullExample
  at src/11-Full-Module-Syntax.purs line 58, column 1 - line 58, column 37

    The import of module Module.SubModule.SubSubModule is redundant


  See https://github.com/purescript/documentation/blob/master/errors/UnusedImport.md for more information,
  or to contribute content related to this warning.
</code></pre>
<p>Second</p>
<pre><code>Warning [current] of [total]:

  in module Syntax.Module.Importing
  at src/03-Basic-Importing.purs line 29, column 1 - line 29, column 58

    There is an existing import of ModuleDataType, consider merging the import lists


  See https://github.com/purescript/documentation/blob/master/errors/DuplicateSelectiveImport.md for more information,
  or to contribute content related to this warning.
</code></pre>
<h2><a class="header" href="#file-location-conventions" id="file-location-conventions">File Location Conventions</a></h2>
<pre><code class="language-haskell">-- a module named...
module Module1 where
-- imports and source code

-- ... should be located in the file...
-- src/Module1.purs

-- whereas

-- a submodule named...
module Module.SubModule.SubSubModule where
-- imports and source code

-- ... should be located in the file...
-- src/Module/SubModule/SubSubModule.purs
</code></pre>
<h2><a class="header" href="#real-world-naming-conventions" id="real-world-naming-conventions">Real World Naming Conventions</a></h2>
<p>See <a href="https://github.com/purescript/documentation/blob/master/guides/Style-Guide.md#modules">the Style Guide's section on Module Names</a></p>
<h1><a class="header" href="#01-basic-syntaxpurs-1" id="01-basic-syntaxpurs-1">01-Basic-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Module.Basic
  (
  -- exports appear here
  exportedFunction
  ) where

-- imports must appear at the top or you'll get a compiler error
import Prelude

-- everything else in the module goes underneath it

exportedFunction :: String -&gt; String
exportedFunction x = x &lt;&gt; &quot;more stuff&quot;

-- an import cannot go here since we are no longer
-- in the &quot;import section&quot; of the file

notExportedValue :: Int
notExportedValue = 3
</code></pre>
<h1><a class="header" href="#02-basic-exportingpurs" id="02-basic-exportingpurs">02-Basic-Exporting.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Module.Exporting
  -- exports go here by just writing the name
  ( value

  , function, (&gt;@&gt;&gt;&gt;) -- aliases must be wrapped in parenthesis

  -- when exporting type classes, there are two rules:
  -- - you must precede the type class name with the keyword 'class'
  -- - you must also export the type class' function (or face compilation errors)
  , class TypeClass, tcFunction

  -- when exporting modules, you must precede the module name with
  -- the keyword 'module'
  , module ExportedModule

  -- The type is exported, but no one can create a value of it
  -- outside of this module
  , ExportDataType1_ButNotItsConstructors

  -- syntax sugar for 'all constructors'
  -- Either all or none of a type's constructors must be exported
  , ExportDataType2_AndAllOfItsConstructors(..)

  -- Type aliases can also be exported
  , ExportedTypeAlias

  -- When type aliases are aliased using infix notation, one must export
  -- both the type alias, and the infix notation where 'type' must precede
  -- the infix notation
  , ExportedTypeAlias_InfixNotation, type (&lt;|&lt;&gt;|&gt;)

  -- Data constructor alias; exporting the alias requires you
  -- to also export the constructor it aliases
  , ExportedDataType3_InfixNotation(Infix_Constructor), (&lt;||||&gt;)

  , ExportedKind
  , ExportedKindValue
  ) where

-- imports go here
import ExportedModule

value :: Int
value = 3

function :: String -&gt; String
function x = x

infix 4 function as &gt;@&gt;&gt;&gt;

class TypeClass a where
  tcFunction :: a -&gt; a -&gt; a

data ExportDataType1_ButNotItsConstructors = Constructor1A

data ExportDataType2_AndAllOfItsConstructors
  = Constructor2A
  | Constructor2B
  | Constructor2C

type ExportedTypeAlias = Int

data ExportedDataType3_InfixNotation = Infix_Constructor Int Int

infixr 4 Infix_Constructor as &lt;||||&gt;

type ExportedTypeAlias_InfixNotation = String

infixr 4 type ExportedTypeAlias_InfixNotation as &lt;|&lt;&gt;|&gt;

data ExportedKind

foreign import data ExportedKindValue :: ExportedKind
</code></pre>
<h1><a class="header" href="#03-basic-importingpurs" id="03-basic-importingpurs">03-Basic-Importing.purs</a></h1>
<pre><code class="language-haskell">-- For now, ignore the `module Exports` export
-- and the &quot;import Module (value) as Exports&quot; syntax
-- This will be explained later and is necessary now
-- to prevent the compiler from emitting lots of warnings.
module Syntax.Module.Importing (module Exports) where

-- One never just imports the entire module.
-- Rather, one must specify what is being imported.
-- The following import statements emit a compiler warning:
-- import Module
-- import Module.SubModule.SubSubModule

-- import values from a module
import ModuleValues (value1, value2) as Exports

-- imports functions from a module
import ModuleFunctions (function1, function2) as Exports

-- imports function alias from a module
import ModuleFunctionAliases ((/=), (===), (&gt;&gt;**&gt;&gt;)) as Exports

-- imports type class from the module
import ModuleTypeClass (class TypeClass) as Exports

-- import a type but none of its constructors
import ModuleDataType (DataType) as Exports

-- import a type and one of its constructors
import ModuleDataType (DataType(Constructor1)) as Exports

-- import a type and some of its constructors
import ModuleDataType (DataType(Constructor1, Constructor2)) as Exports

-- import a type and all of its constructors
import ModuleDataType (DataType(..)) as Exports

import ModuleKind (ImportedKind, ImportedKindValue) as Exports

-- To prevent warnings from being emitted during compilation
-- the above imports have to either be used here or
-- re-exported (explained later in this folder).
</code></pre>
<h1><a class="header" href="#04-resolving-naming-conflicts-using-keyword--hidingpurs" id="04-resolving-naming-conflicts-using-keyword--hidingpurs">04-Resolving-Naming-Conflicts-Using-Keyword--Hiding.purs</a></h1>
<pre><code class="language-haskell">-- There are situations where a function in one module
-- may be the same name as a function in another module

-- for example
-- module ModuleNameClash1 (sameFunctionName1) where -- ...
-- module ModuleNameClash2 (sameFunctionName1) where -- ...

-- In this file, how do we use both of them?
-- We can use the 'hiding' keyword
module Syntax.Module.ResolvingNamingConflicts.ViaHiding where

import ModuleNameClash1 (sameFunctionName1)
import ModuleNameClash2 hiding (sameFunctionName1)

-- now 'sameFunctionName1' refers to ModuleNameClash1's function,
-- not ModuleNameClash2's function
myFunction1 :: Int -&gt; Int
myFunction1 a = sameFunctionName1 a
</code></pre>
<h1><a class="header" href="#04-resolving-naming-conflicts-using-module-aliasespurs" id="04-resolving-naming-conflicts-using-module-aliasespurs">04-Resolving-Naming-Conflicts-Using-Module-Aliases.purs</a></h1>
<pre><code class="language-haskell">{-
There are situations where a function in one module
may be the same name as a function in another module

For example
  module ModuleNameClash1 (sameFunctionName1) where -- ...
  module ModuleNameClash2 (sameFunctionName1) where -- ...

This can also arise when data type share the same name:
  module ModuleNameClash1 (SameDataName(..)) where
  module ModuleNameClash2 (SameDataName(..)) where

In this file, how do we use both of them?
We can use Module aliases -}
module Syntax.Module.ResolvingNamingConflicts.ViaModuleAliases where

import ModuleNameClash1 as M1
import ModuleNameClash2 as M2

myFunction2 :: Int -&gt; Int
myFunction2 a = M1.sameFunctionName1 (M2.sameFunctionName1 a)

dataDifferences :: M1.SameDataName -&gt; M2.SameDataName -&gt; String
dataDifferences M1.Constructor M2.Constructor = &quot;code works despite name clash&quot;
</code></pre>
<h1><a class="header" href="#05-re-exporting-modules-or-submodulespurs" id="05-re-exporting-modules-or-submodulespurs">05-Re-exporting-Modules-or-Submodules.purs</a></h1>
<pre><code class="language-haskell">-- To get the &quot;import RootModule.SubModule.SubModule&quot; syntax
module Syntax.Module.ExportingModules
  ( module ModuleAlias
  ) where

-- We can use module alises to export multiple things
-- (e.g. types, constructors, functions, values)
-- from multiple modules conveniently

import Module1 (anInt1) as ModuleAlias
import Module2 (anInt2) as ModuleAlias
import Module3 (anInt3) as ModuleAlias

-- By convention, this is usually &quot;Exports&quot;
import Module4.SubModule1 (someFunction) as ModuleAlias

{-
This enables the syntax:
import Syntax.Module.ExportingModules (anInt, anInt2, anInt3, someFunction)

-- or we can use module aliases
import Syntax.Module.ExportingModules as EM

-- in code
EM.anInt
EM.someFunction
-}
</code></pre>
<h1><a class="header" href="#06-exporting-entire-current-modulepurs" id="06-exporting-entire-current-modulepurs">06-Exporting-Entire-Current-Module.purs</a></h1>
<pre><code class="language-haskell">{-
Let's say you have a module with A LOT of entities
and you want to export ALL of them. (This 'trick' doesn't
work if you want to export some but not all entities.)

Rather than typing all of the exports, you can use the
&quot;re-export module&quot; syntax to export the current module
-}
module Syntax.Module.ExportingEntireCurrentModule
  (
    -- By exporting the current module,
    -- we can export all of its entities at once.
    module Syntax.Module.ExportingEntireCurrentModule
  ) where

-- 14 entities in total
a :: String
a = &quot;a&quot;

b :: String
b = &quot;b&quot;

c :: String
c = &quot;c&quot;

d :: String
d = &quot;d&quot;

e :: String
e = &quot;e&quot;

f :: String
f = &quot;f&quot;

g :: String
g = &quot;g&quot;

h :: String
h = &quot;h&quot;

i :: String
i = &quot;i&quot;

j :: String
j = &quot;j&quot;

k :: String
k = &quot;k&quot;

l :: String
l = &quot;l&quot;

m :: String
m = &quot;m&quot;

n :: String
n = &quot;n&quot;
</code></pre>
<h1><a class="header" href="#11-full-module-syntaxpurs" id="11-full-module-syntaxpurs">11-Full-Module-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Module.FullExample
  -- exports go here by just writing the name
  ( value

  , function, (&gt;@&gt;&gt;&gt;) -- aliases must be wrapped in parenthesis

  -- when exporting type classes, there are two rules:
  -- - you must precede the type class name with the keyword 'class'
  -- - you must also export the type class' function (or face compilation errors)
  , class TypeClass, tcFunction

  -- when exporting modules, you must precede the module name with
  -- the keyword 'module'
  , module ExportedModule

  -- The type is exported, but no one can create a value of it
  -- outside of this module
  , ExportDataType1_ButNotItsConstructors

  -- syntax sugar for 'all constructors'
  -- Either all or none of a type's constructors must be exported
  , ExportDataType2_AndAllOfItsConstructors(..)

  -- Type aliases can also be exported
  , ExportedTypeAlias

  -- When type aliases are aliased using infix notation, one must export
  -- both the type alias, and the infix notation where 'type' must precede
  -- the infix notation
  , ExportedTypeAlias_InfixNotation, type (&lt;|&lt;&gt;|&gt;)

  -- Data constructor alias; exporting the alias requires you
  -- to also export the constructor it aliases
  , ExportedDataType3_InfixNotation(Infix_Constructor), (&lt;||||&gt;)

  , ExportedKind
  , ExportedKindValue
  ) where

-- imports go here

-- imports just the module
import Module

-- import a submodule
import Module.SubModule.SubSubModule

-- import values from a module
import ModuleValues (value1, value2)

-- imports functions from a module
import ModuleFunctions (function1, function2)

-- imports function alias from a module
import ModuleFunctionAliases ((/=), (===), (&gt;&gt;**&gt;&gt;))

-- imports type class from the module
import ModuleTypeClass (class TypeClass)

-- import a type but none of its constructors
import ModuleDataType (DataType)

-- import a type and one of its constructors
import ModuleDataType (DataType(Constructor1))

-- import a type and some of its constructors
import ModuleDataType (DataType(Constructor1, Constructor2))

-- import a type and all of its constructors
import ModuleDataType (DataType(..))

-- resolve name conflicts using &quot;hiding&quot; keyword
import ModuleNameClash1 (sameFunctionName1)
import ModuleNameClash2 hiding (sameFunctionName1)

-- resolve name conflicts using module aliases
import ModuleNameClash1 as M1
import ModuleNameClash2 as M2

-- Re-export modules
import Module1 (anInt1) as Exports
import Module2 (anInt2) as Exports
import Module3 (anInt3) as Exports
import Module4.SubModule1 (someFunction) as Exports

import ModuleKind (ImportedKind, ImportedKindValue) as Exports

import Prelude

import ExportedModule

-- To prevent warnings from being emitted during compilation
-- the above imports have to either be used here or
-- re-exported (explained later in this folder).

value :: Int
value = 3

function :: String -&gt; String
function x = x

infix 4 function as &gt;@&gt;&gt;&gt;

class TypeClass a where
  tcFunction :: a -&gt; a -&gt; a

-- now 'sameFunctionName1' refers to ModuleF1's function, not ModuleF2's function
myFunction1 :: Int -&gt; Int
myFunction1 a = sameFunctionName1 a

myFunction2 :: Int -&gt; Int
myFunction2 a = M1.sameFunctionName1 (M2.sameFunctionName1 a)

dataDifferences :: M1.SameDataName -&gt; M2.SameDataName -&gt; String
dataDifferences M1.Constructor M2.Constructor = &quot;code works despite name clash&quot;

data ExportDataType1_ButNotItsConstructors = Constructor1A

data ExportDataType2_AndAllOfItsConstructors
  = Constructor2A
  | Constructor2B
  | Constructor2C

type ExportedTypeAlias = Int

data ExportedDataType3_InfixNotation = Infix_Constructor Int Int

infixr 4 Infix_Constructor as &lt;||||&gt;

type ExportedTypeAlias_InfixNotation = String

infixr 4 type ExportedTypeAlias_InfixNotation as &lt;|&lt;&gt;|&gt;

data ExportedKind

foreign import data ExportedKindValue :: ExportedKind
</code></pre>
<h1><a class="header" href="#prelude-syntax" id="prelude-syntax">Prelude Syntax</a></h1>
<p>This folder documents the syntax that is enabled by importing <a href="https://pursuit.purescript.org/packages/purescript-prelude/">Prelude</a>.</p>
<p>Ignore this folder's contents until you are reading through the <code>Prelude</code> folder in the <code>Hello World</code> folder. When you are in that folder and you see unfamiliar syntax, you should probably return here:</p>
<ul>
<li>do notation</li>
<li>ado notation</li>
<li>Natural Transformations</li>
</ul>
<h1><a class="header" href="#discard" id="discard">Discard</a></h1>
<p>There is a type class in Prelude called <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Bind#t:Discard"><code>Discard</code></a> that does not appear in our diagram of Prelude's type classes. It is implemented only by <code>Unit</code>.:</p>
<pre><code class="language-haskell">-- Pseudo-Syntax: combines the class and its only instance into one block:
class Discard Unit where
  discard :: forall f b. Bind f =&gt; f Unit -&gt; (Unit -&gt; f b) -&gt; f b
  discard = bind
</code></pre>
<p>This seemingly pointless type class insures that you do not accidentally &quot;throw away&quot; the result of a computation when you did not intend to do so (covered next in 'do notation'). One should almost never implement it for another type, unless one knows what they are doing and they have a very rare use case for it.</p>
<h1><a class="header" href="#02-do-notationpurs" id="02-do-notationpurs">02-Do-Notation.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Prelude.Notation.Do where

import Prelude

{-
In imperative programming, one often writes some sequential code like:
  x = 4
  y = x + 4
  z = toString x
  print z

Since each line depends on the line before it,
  this implies sequential computation, or Monads. We have &quot;do&quot; notation
  to imitate this style of code

Recall the type signature of `bind`...
      bind :: m a -&gt; (a -&gt; m b) -&gt; m b
... and that &quot;&gt;&gt;=&quot; is an alias for `bind`

Thus, these two expressions are the same:
    bind computation (\result -&gt; newComputationUsing result)
    computation &gt;&gt;= (\result -&gt; newComputationUsing result)
-}

do1_bind :: Box Unit
do1_bind =
  bind get4 (\x -&gt;
    bind (add4To x) (\y -&gt;
      bind (toString y) (\z -&gt;
        print z
      )
    )
  )
-- which is better understood by replacing `bind` with &quot;&gt;&gt;=&quot; as
do1_alias :: Box Unit
do1_alias =
  get4 &gt;&gt;= (\x -&gt;
    -- only call `add4To x` if `get4` actually produces something
    add4To x &gt;&gt;= (\y -&gt;
      toString y &gt;&gt;= (\z -&gt;
        print z
      )
    )
  )
-- which is better understood and more readable as
do1_do_notation :: Box Unit
do1_do_notation = do
  x     &lt;- get4
  y     &lt;- add4To x
  z     &lt;- toString y
  -- last line in do notation must not end with `value &lt;- computation`
  -- but should just end in `computation`
  print z

-- Just like in regular functions, we could use 'let-in` syntax
do2_bind :: Box Unit
do2_bind =
  bind get4 (\x -&gt;
      let y = x + 4
      in bind (toString y) (\z -&gt; print z)
    )
-- which is better understood by replacing `bind` with &quot;&gt;&gt;=&quot; as
do2_alias :: Box Unit
do2_alias =
  get4 &gt;&gt;= (\x -&gt;
      -- While replacing 'bind' with '&gt;&gt;=' is better,
      -- this let-in syntax is still not very readable here...
      let y = x + 4
      in toString y &gt;&gt;= (\z -&gt; print z)
    )
-- but we can write it better as
do2_do_notation :: Box Unit
do2_do_notation = do
  x &lt;- get4
  let y = x + 4   -- no need to have a corresponding `in` statement
  z &lt;- toString y
  print z

do3_ignoreValue_bind :: Box Unit
do3_ignoreValue_bind =
  bind get4 (\x -&gt;
    bind (takeValueAndIgnoreResult x) (\_ {- this underscore is 'unit' -} -&gt;
      print x
    )
  )
-- which is better understood by replacing `bind` with &quot;&gt;&gt;=&quot; as in
do3_ignoreValue_alias :: Box Unit
do3_ignoreValue_alias =
  get4 &gt;&gt;= (\x -&gt; takeValueAndIgnoreResult x &gt;&gt;= (\_ -&gt; print x))
-- gets turned into...
do3_ignoreValue_do_notation :: Box Unit
do3_ignoreValue_do_notation = do
  x     &lt;- get4
  _     &lt;- takeValueAndIgnoreResult x

  print x

do4_discard_bind :: Box Unit
do4_discard_bind =
  bind (Box unit) (\unit_ -&gt;
    bind (Box unit) (\unit__ -&gt;
      print 5
    )
  )
-- which is better understood by replacing `bind` with &quot;&gt;&gt;=&quot; as in
do4_discard_alias :: Box Unit
do4_discard_alias =
  (Box unit) &gt;&gt;= (\unit_ -&gt;
    (Box unit) &gt;&gt;= (\unit__ -&gt;
        print 5
    )
  )
-- can be written as...
do4_discard_syntax :: Box Unit
do4_discard_syntax = do                                           {-
  When we omit the &quot;binding &lt;-&quot; syntax, as in

      four &lt;- Box 4   -- line 1
              Box a   -- line 2
      five &lt;- Box 5   -- line 3

  the compiler translates `line 2` to
      &quot;discard (Box a) (\_ -&gt; (Box 5) &gt;&gt;= (\five -&gt; ... ))&quot;

  This is fine if the argument to the next function would be Unit

      four &lt;- Box 4
      unit &lt;- Box unit  -- here, we could omit the &quot;unit &lt;-&quot; syntax
      five &lt;- Box 5
              Box unit -- same thing

  If we had accidentally written code that amounted to this...

      four &lt;- Box 4
              Box 10 -- notice how there is no &quot;10 &lt;-&quot; fragment
      five &lt;- Box 5

  ... the compiler would notify us that we had discarded a non-unit value
      (i.e. 10):
        &quot;Could not find instance of Discard for Int&quot;

  Why does it do this? To highlight that we have accidentally dropped the
  result of the computation. If you want to intentionally drop a result,
  use `void $ monad` or the &quot;_ &lt;- computation&quot; syntax                         -}
  x &lt;- (Box 5)
  (Box unit) -- since it returns unit, it's ok to use discard here

  -- rather than write this...
  map (\_ -&gt; unit) (Box 5)

  -- or even this...
  (\_ -&gt; unit) &lt;$&gt; (Box 5)

  -- we write this:
  void $ Box 5

  print 5

do_full_syntax :: Box Unit
do_full_syntax = do
  x &lt;- get4

  _ &lt;- takeValueAndIgnoreResult x

  (Box unit)
  void $ takeValueAndIgnoreResult x

  let y = x + 4
  z &lt;- toString y
  -- last line in do notation must NOT end with `value &lt;- expression`
  -- but should just end in `expression`
  print z

-- needed to make this file compile
data Box a = Box a

derive instance Functor Box

instance Apply Box where
  apply (Box f) (Box a) = Box (f a)

instance Applicative Box where
  pure a = Box a

instance Bind Box where
  bind (Box a) f = f a

get4 :: Box Int
get4 = Box 4

add4To :: Int -&gt; Box Int
add4To i = Box (i + 4)

toString :: Int -&gt; Box String
toString i = Box (show i)

takeValueAndIgnoreResult :: forall a. a -&gt; Box a
takeValueAndIgnoreResult a = Box a

print :: forall a. a -&gt; Box Unit
print _ = Box unit
</code></pre>
<h1><a class="header" href="#reading-do-notation-as-nested-binds" id="reading-do-notation-as-nested-binds">Reading Do Notation as Nested Binds</a></h1>
<p>Be aware of where the parenthesis appear when using multiple bind expressions (e.g. <code>m a &gt;&gt;= aToMB &gt;&gt;= bToMC</code>). Below provides a summary of the section called &quot;Do notation&quot; in <a href="https://sras.me/haskell/miscellaneous-enlightenments.html">this article</a>:</p>
<pre><code class="language-haskell">data Maybe a
  = Nothing
  | Just a

instance Bind Maybe where
  bind :: forall a b. Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
  -- when given a Nothing, stop all future computations and return immediately.
  bind Nothing _ = Nothing
  -- when given a Just, run the function on its contents
  bind (Just a) f = f a

half :: Int -&gt; Maybe Int
half x | x % 2 == 0 = Just (x / 2)
       | otherwise = Nothing

-- This statement
(Just 128) &gt;&gt;= half &gt;&gt;= half &gt;&gt;= half
-- desugars first to
(Just 128) &gt;&gt;= (\original -&gt; half original &gt;&gt;= half &gt;&gt;= half )
-- which can be better understood as
(Just 128) &gt;&gt;= aToMB
-- which can be better understood as
bind (Just 128) &gt;&gt;= aToMB
-- since the latter &quot;&gt;&gt;=&quot; calls are nested inside of the first one, one
-- should read the above computation as &quot;Only continue if the previous
--    `bind`/`&gt;&gt;=` call was successful.&quot;
-- In this situation, it is:
bind (Just 128) (\original -&gt; half original &gt;&gt;= half &gt;&gt;= half)
-- reduces to
(\128 -&gt; half 128 &gt;&gt;= half &gt;&gt;= half)
-- reduces to
half 128 &gt;&gt;= half &gt;&gt;= half
-- ... and so forth until we get the result:
Just 16


-- Similarly
Nothing    &gt;&gt;= half &gt;&gt;= half &gt;&gt;= half == Nothing
-- desguars first to
Nothing    &gt;&gt;= (\value -&gt; half value &gt;&gt;= half &gt;&gt;= half) == Nothing
-- which can be better understood as
Nothing    &gt;&gt;= aToMB == Nothing
-- which can be better understood as
bind Nothing aToMB == Nothing
-- and, looking at the instance of Bind above, reduces to Nothing
-- The other `half` computations are never executed.

-- Thus, given this function...
half3Times :: Maybe Int -&gt; Maybe Int
half3Times maybeI = do
  original &lt;- maybeI
  first &lt;- half original    -- ===
  second &lt;- half first      --  | a -&gt; m b
  third &lt;- half second      --  |
  pure third                -- ===
-- ... passing in `Nothing` doesn't compute anything
half3Times Nothing == Nothing

-- Likewise, passing in a bad starting value will also stop the computation
-- as soon as possible:
(Just 3) &gt;&gt;= half &gt;&gt;= (\thisWontRun -&gt; pure thisWontRun)
-- will desugar to
bind (Just 3) half =
-- will desugar to
half 3
-- which desugars to
half 3 | 3 % 2 == 0
       | otherwise = Nothing
-- which tests whether `3 % 2 == 0` (false) the 'otherwise path'
Nothing &gt;&gt;= (\thisWontRun -&gt; pure thisWontRun)
-- which desugars to
bind NOthing (\thisWontRun -&gt; pure thisWontRun)
-- which desugars to
Nothing
</code></pre>
<h1><a class="header" href="#04-ado-notationpurs" id="04-ado-notationpurs">04-Ado-Notation.purs</a></h1>
<pre><code class="language-haskell">{-
Link to original issue's comment
where this is fully explained:
https://github.com/purescript/purescript/pull/2889#issuecomment-301260299

Following the 'do' notation of Monads, the 'ado' notation is for Applicative
Since Applicative can be used for parellel computation, one **might**
   read the following code as
     &quot;produces some value at the same time it's producing another value&quot;
   rather than sequential computation, which is
     &quot;produces some value, and then uses that value to produce another value&quot;
It depends on whether parallel applicatives are used or not.
-}
module Syntax.Prelude.Notation.Ado where

import Prelude

data Box a = Box a

instance Functor Box where
  map :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box b
  map f (Box a) = Box (f a)
-- infixl 4 map as &lt;$&gt;

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box b
  apply (Box f) (Box a) = Box (f a)
-- infixl 4 apply as &lt;*&gt;

instance Applicative Box where
  pure :: forall a. a -&gt; Box a
  pure a = Box a
------------------------------
pure_no_sugar :: forall a b. (a -&gt; b) -&gt; a -&gt; Box b
pure_no_sugar f a = pure (f a)

pure_sugar :: forall a b. (a -&gt; b) -&gt; a -&gt; Box b
pure_sugar f a = ado
  in f a
------------------------------
map_no_sugar :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box b
map_no_sugar f g = (\x -&gt; f x) &lt;$&gt; g

map_sugar :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box b
map_sugar f g = ado
  x &lt;- g
  in f x
------------------------------
-- See `lift2` from Apply: https://pursuit.purescript.org/packages/purescript-prelude/4.1.0/docs/Control.Apply#v:lift2
liftN_no_sugar :: forall a b c. (a -&gt; b -&gt; c) -&gt; Box a -&gt; Box b -&gt; Box c
liftN_no_sugar f g h = (\x y -&gt; f x y) &lt;$&gt; g &lt;*&gt; h

liftN_sugar :: forall a b c. (a -&gt; b -&gt; c) -&gt; Box a -&gt; Box b -&gt; Box c
liftN_sugar f g h = ado
  x &lt;- g
  y &lt;- h
  in f x y
------------------------------
liftN_unit_no_sugar :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box Unit -&gt; Box b
liftN_unit_no_sugar f g h = (\x _ -&gt; f x) &lt;$&gt; g &lt;*&gt; h

liftN_unit_sugar :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box Unit -&gt; Box b
liftN_unit_sugar f g h = ado
  x &lt;- g
  h
  in f x
------------------------------
liftN_Let_no_sugar :: forall a. (Int -&gt; Int -&gt; a) -&gt; Box Int -&gt; Box Unit -&gt; Box a
liftN_Let_no_sugar f g h = (\x -&gt; let y = x + 1 in (\_ -&gt; f x y)) &lt;$&gt; g &lt;*&gt; h

liftN_Let_sugar :: forall a. (Int -&gt; Int -&gt; a) -&gt; Box Int -&gt; Box Unit -&gt; Box a
liftN_Let_sugar f g h = ado
  x &lt;- g
  let y = x + 1
  h
  in f x y
</code></pre>
<h1><a class="header" href="#05-natural-transformationpurs" id="05-natural-transformationpurs">05-Natural-Transformation.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Prelude.NaturalTransformations where

-- Given this code
data Box1 a = Box1 a
data Box2 a = Box2 a

-- This function's type signature...
box1_to_box2_noisy :: forall a. Box1 a -&gt; Box2 a
box1_to_box2_noisy (Box1 a) = Box2 a
-- ... has a lot of noise and could be re-written to something
-- that communicates our intent better via Natural Transformations...

-- Read: given an 'a' that is inside of a 'container' or 'context',
-- change the container F to container G.
-- I don't care what type 'a' is since it's irrelevant
type NaturalTransformation_ f g = forall a. f a -&gt; g a

infixr 4 type NaturalTransformation_ as ~&gt;

box1_to_box2 :: Box1 ~&gt; Box2 {- much less noisy than
box1_to_box2 :: forall a. Box1 a -&gt; Box2 a -}
box1_to_box2 (Box1 a) = Box2 a
</code></pre>
<h1><a class="header" href="#modifying-doado-syntax-sugar" id="modifying-doado-syntax-sugar">Modifying Do/Ado Syntax Sugar</a></h1>
<p>This folder documents how one can modify what occurs when using &quot;do notation&quot; and &quot;ado notation.&quot; You will likely not need to use these as a beginner. Over time, once you have learned more about FP, these features may be useful. Feel free to skip or skim through this on your first read.</p>
<h2><a class="header" href="#the-problem-1" id="the-problem-1">The Problem</a></h2>
<p>&quot;do notation&quot; and &quot;ado notation&quot; are purely syntax sugar. Rather than having to write some rather verbose code, we can use these two keywords to make the compiler do all of that for us.</p>
<p>It would be nice if one could modify how this syntax sugar gets desugared in some situations. For example...</p>
<ul>
<li>ado notation:
<ul>
<li>removing some of the boilerplate needed to use Applicatives to validate data.</li>
</ul>
</li>
<li>do notation:
<ul>
<li>using <code>IndexedMonad</code>-based computations (i.e. monads with phantom types that provide more context about what can/can't happen at that computation step) in the same way we would use <code>Monad</code>-based computations.</li>
</ul>
</li>
</ul>
<p>Presently, there are two ways to do this:</p>
<ul>
<li>Rebindable Do/Ado</li>
<li>Qualified Do/Ado (available since the <code>0.12.2</code> release)</li>
</ul>
<p>Each will be covered in the following folders. To keep it simple, we'll use the <code>Box</code> monad to explain how it works. Unfortunately, this monadic type isn't a good example as to why one would want to use this.</p>
<h1><a class="header" href="#01-rebindable-adopurs" id="01-rebindable-adopurs">01-Rebindable-Ado.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Modification.RebindableAdo where

-- I assume you are already familiar with how 'ado notation' desugars.
-- If not, go read through that explanation again.

import Prelude

-- We'll use a qualified import to make it easier to see
-- when we're referring to the REAL 'apply' and 'map' as defined
-- in Prelude and not our customized versions.
import Data.Functor as NormalMap
import Control.Apply as NormalApply

-- Given this monad (type class instances are at bottom of file)
data Box a = Box a

{-
&quot;ado notation&quot; works by
- desugaring the &quot;&lt;-&quot; notation via the &quot;apply&quot; function within scope
- desugaring the &quot;in &lt;function&gt;&quot; notation via the &quot;map&quot; function within scope

Thus, to change how these two things desugar, we change what 'apply' and 'map'
mean via a let binding or a where clause.

Note: rebinding 'ado' will produce the following compiler warnings:
&quot;Name `apply` was shadowed.&quot;
&quot;Name `map` was shadowed.&quot;
-}

-- This is how we would use &quot;rebindable syntax&quot; via a 'let binding'
-- to write normal &quot;ado notation&quot; (i.e. apply and map are unchanged)
normalApply_let_in :: Box Int
normalApply_let_in =
  let
    {-
    These do not work

    -- Compiler error: &quot;The value of apply is undefined here,
    -- so this reference is not allowed.&quot;
    -- The compiler thinks 'apply' is defined as itself.
    apply :: forall f a b. Apply f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
    apply = apply
    -}

    -- These do work.
    -- apply :: forall f a b. Apply f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
    apply = NormalApply.apply

    -- map :: forall f a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
    map = NormalMap.map
  in ado
    three &lt;- Box 3
    two &lt;- Box 2
    in three + two

-- Redefining them in a 'where' clause is more readable.
normalApply_where :: Box Int
normalApply_where = ado
  three &lt;- Box 3
  two &lt;- Box 2
  in three + two
  where
    apply :: forall f a b. Apply f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
    apply = NormalApply.apply

    map :: forall f a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
    map = NormalMap.map

-- Now, let's change how `&lt;-` gets desugared by actuallying changing how
-- `apply` is defined. Whenever `apply` gets called, it will add 1
-- to the result of apply by using `map (_ + 1)`.
plusApply_where :: Box Int
plusApply_where = ado
  three &lt;- Box 3
  two &lt;- Box 2
  in three + two
  where
    -- Our modified 'apply' will add 1 each time it gets called.
    -- To support this modification, we'll modify the type signature
    -- to force this to only work on boxes of Ints.
    apply :: forall f. Apply f =&gt; f (Int -&gt; Int) -&gt; f Int -&gt; f Int
    apply boxedF boxedArg =
      NormalMap.map (_ + 1) (NormalApply.apply boxedF boxedArg)         {-
                             ^ Warning: if we used `apply` here instead of
                               `NormalApply.apply`, we would have
                               created an infinite loop                  -}

    -- Since `map` isn't defined here, the closest &quot;in-scope&quot; definition
    -- is the `map` that is imported from Data.Functor in the 'import Prelude'
    -- line.

{-
Here's the graph reduction of the above `plus1Apply` code:
ado
  three &lt;- Box 3
  two &lt;- Box 2
  in three + two

((\three two -&gt; three + two)
  `NormalMap.map` Box 3)
  `apply` Box 2 -- i.e. our modified apply

(NormalMap.map (\three two -&gt; three + two) (Box 3)) `apply` Box 2

Box (\two -&gt; 3 + two) `apply` Box 2

apply (Box (\two -&gt; 3 + two)) (Box 2)

-- now reduces 'apply' with our modified definition
-- Note that &quot;&lt;*&gt;&quot; refers to the normal apply definition.

map (_ + 1) (NormalApply.apply (Box (\two -&gt; 3 + two)) (Box 2))
map (_ + 1) (                  (Box (\2   -&gt; 3 + 2  ))        )
map (_ + 1) (                  (Box (        5      ))        )
map (_ + 1) (Box 5)
Box 6
-}

-- Applicative types allow us to use things like `*&gt;` and `&lt;*`
-- Why not rebind ado notation to use that for apply?
realWorldExample :: Box Int
realWorldExample = ado
  three &lt;- Box 3
  two &lt;- Box 2
  in three + two
  where
    -- Our modified `apply` will run the normal computation
    -- and then return the result, Box 4, rather than the actual computation.
    -- A better example would be using &quot;ado notation&quot; to validate
    -- data and use something like, `boxedF &lt;*&gt; boxedArg &lt;* pure unit`,
    -- to reduce boilerplate.
    apply :: forall f. Applicative f =&gt; f (Int -&gt; Int) -&gt; f Int -&gt; f Int
    apply boxedF boxedArg = boxedF &lt;*&gt; boxedArg *&gt; pure 4

{-
The above graph reduction is:
ado
  three &lt;- Box 3
  two &lt;- Box 2
  in three + two

(\three two -&gt; three + two)
  `NormalMap.map` (Box 3)
  `apply` (Box 2)

NormalMap.map (\three two -&gt; three + two) (Box 3) `apply` (Box 2)

Box (\two -&gt; 3 + two) `apply` (Box 2)

-- here we use replace 'apply' with our modified definition

Box (\two -&gt; 3 + two) &lt;*&gt; (Box 2) *&gt; Box 4
NormalApply.apply (Box (\two -&gt; 3 + two)) &lt;*&gt; (Box 2) *&gt; Box 4
                  (Box (\    -&gt; 3 + 2  ))             *&gt; Box 4
                  (Box          5       )             *&gt; Box 4
                  applyRight (Box 5) (Box 4)

applyRight (Box 5) (Box 4)
(\left right -&gt; right) &lt;$&gt; (Box 5) &lt;*&gt; (Box 4)
Box 4
-}

-- I don't have an example of remapping `map` because I couldn't find a way
-- to do that without getting a compiler error.
-- Still, this file demonstrates how to do this.

{-
Lastly, one can change `apply` multiple times throughout the 'ado notation'
if one were to use lets. For example,

ado
  -- apply not set, so use normal definition
  a &lt;- someA
  let apply = definition -- apply now uses modified version
  b &lt;- someB
  c &lt;- someC
  let apply = definition2 -- apply now uses a second modified version
  d &lt;- someD
  in computation a b c d

For readability, this is not recommended. I only include it here to be
complete in this explanation.

-}

-- Type class instances

instance Functor Box where
  map :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box  b
  map f (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box  b
  apply (Box f) (Box a) = Box (f a)

instance Applicative Box where
  pure :: forall a. a -&gt; Box a
  pure a =  Box a

instance (Show a) =&gt; Show (Box a) where
  show (Box a) = &quot;Box(&quot; &lt;&gt; show a &lt;&gt; &quot;)&quot;
</code></pre>
<h1><a class="header" href="#01-rebindable-dopurs" id="01-rebindable-dopurs">01-Rebindable-Do.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Modification.RebindableDo where

-- I assume you are already familiar with how 'do notation' desugars.
-- If not, go read through that explanation again.

import Prelude

-- We'll use a qualified import to make it easier to see
-- when we're referring to the REAL 'bind` defined
-- in Prelude and not our customized version.
import Control.Bind as NormalBind

-- Given this monad (type class instances are at bottom of file)
data Box a = Box a

{-
&quot;do notation&quot; works by
- desugaring a line with the &quot;&lt;-&quot; notation via the &quot;bind&quot; function within scope
- desugaring a line without the &quot;&lt;-&quot; notation via the &quot;discard&quot; function within scope

Thus, to change how these two things desugar, we change what 'bind' and 'discard'
mean via a let binding or a where clause.
However, since `discard = void $ bind`, we almost never need to remap `discard`
to a different definition. While one could, I don't know why one would.

Note: rebinding 'do' will produce the following compiler warnings:
&quot;Name `bind` was shadowed.&quot;
&quot;Name `discard` was shadowed.&quot;
-}

-- While 'bind' has been imported above, we don't have to use that 'bind' explicitly
normalBind_let_in :: Box Int
normalBind_let_in =
  let
    bind = NormalBind.bind

    -- this isn't necessary, but we'll include it here anyway.
    discard = NormalBind.discard
  in do
    three &lt;- Box 3
    Box unit
    two &lt;- Box 2
    pure (three + two)


-- Redefining them in a where clause is more readable.
normalBind_where :: Box Int
normalBind_where = do
  three &lt;- Box 3
  two &lt;- Box 2
  pure (three + two)
  where
    bind = NormalBind.bind

    -- Again, this isn't necessary, but we'll include it here anyway.
    discard = NormalBind.discard

-- Similar to `ado notation`, we can rebind `do notation` to use a different
-- implementation than the default `bind`.
plusBind_where :: Box Int
plusBind_where = do
  three &lt;- Box 3
  two &lt;- Box 2
  pure (three + two)
  where
    bind boxedArg aToMB =
      NormalBind.bind boxedArg aToMB &gt;&gt;= \result -&gt; pure (result + 1)        {-
      ^ Warning: using `bind` here would lead to an infinite loop during
        runtime that will stack overflow. We need to refer to the normal
        bind using `NormalBind.bind` or `&gt;&gt;=`                                   -}

    -- discard is not included here because the next closest discard definition
    -- in scope is the one imported via &quot;import Prelude&quot;

{-
The above code's graph reduction is:
do
  three &lt;- Box 3
  two &lt;- Box 2
  pure (three + two)

bind (Box 3) (\three -&gt;
  bind (Box 2) (\three -&gt;
    pure (three + two)
  )
)

let firstBindResult = NormalBind.bind (Box 3) (\x -&gt; pure (x + 1))
in NormalBind.bind firstBindResult (\three -&gt;
  bind (Box 2) (\three -&gt;
    pure (three + two)
  )
)

let firstBindResult =                         (\3 -&gt; pure (3 + 1))
in NormalBind.bind firstBindResult (\three -&gt;
  bind (Box 2) (\three -&gt;
    pure (three + two)
  )
)

let firstBindResult =                         (      pure 4     )
in NormalBind.bind firstBindResult (\three -&gt;
  bind (Box 2) (\three -&gt;
    pure (three + two)
  )
)

let firstBindResult = Box 4
in NormalBind.bind firstBindResult (\three -&gt;
  bind (Box 2) (\three -&gt;
    pure (three + two)
  )
)

NormalBind.bind (Box 4) (\three -&gt;
  bind (Box 2) (\two -&gt;
    pure (three + two)
  )
)
                        (\4 -&gt;
  bind (Box 2) (\two -&gt;
    pure (4 + two)
  )
)

bind (Box 2) (\two -&gt;
  pure (4 + two)
)

let secondBindResult = NormalBind.bind (Box 2) (\y -&gt; pure (y + 1))
in NormalBind.bind secondBindResult (\two -&gt;
  pure (4 + two)
)

let secondBindResult =                         (\2 -&gt; pure (2 + 1))
in NormalBind.bind secondBindResult (\two -&gt;
  pure (4 + two)
)

let secondBindResult =                         (      pure 3      )
in NormalBind.bind secondBindResult (\two -&gt;
  pure (4 + two)
)

let secondBindResult = Box 3
in NormalBind.bind secondBindResult (\two -&gt;
  pure (4 + two)
)

NormalBind.bind (Box 3) (\two -&gt;
  pure (4 + two)
)

                        (\3 -&gt;
  pure (4 + 3)
)

pure (4 + 3)

Box 7

-}

{-
This example would require using a monad that supports MonadWriter.
One could rebind `bind` to log the argument before continuing the computation.

For example, someting like:
  bind computation aToMB =
    computation &gt;&gt;= (\result -&gt;
      -- log what the argument was here via `tell`
      tell result &gt;&gt;= (\_ -&gt;
        -- then continue the computation like normal
        aToMB result
      )
-}

-- Type class instances

instance Functor Box where
  map :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box  b
  map f (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box  b
  apply (Box f) (Box a) = Box (f a)

instance Bind Box where
  bind :: forall a b. Box a -&gt; (a -&gt; Box b) -&gt; Box b
  bind (Box a) f = f a

instance Applicative Box where
  pure :: forall a. a -&gt; Box a
  pure a =  Box a

instance Monad Box

instance (Show a) =&gt; Show (Box a) where
  show (Box a) = &quot;Box(&quot; &lt;&gt; show a &lt;&gt; &quot;)&quot;
</code></pre>
<h1><a class="header" href="#introducing-qualified-doado" id="introducing-qualified-doado">Introducing Qualified Do/Ado</a></h1>
<h2><a class="header" href="#possible-readability-issue-with-rebindable-doado-notation" id="possible-readability-issue-with-rebindable-doado-notation">Possible Readability Issue with Rebindable Do/Ado Notation</a></h2>
<p>When using Rebindable do/ado notation, I'd recommend using the <code>let ... in do/ado</code> aproach for rebinding function names. Let me give an example why. If we used the 'where' clause approach, it isn't immediately clear whether <code>do/ado notation</code> desugars to the standard functions or to some remapped version until the very end. For example,</p>
<pre><code class="language-haskell">-- Reader thinks, &quot;Oh hey! It's do notation.
-- It's just standard `bind` desugaring.&quot;
comp3 :: Box Int
comp3 = do
  a &lt;- Box 1
  b &lt;- Box 1
  c &lt;- Box 1
  d &lt;- Box 1
  e &lt;- Box 1
  f &lt;- Box 1
  g &lt;- Box 1
  h &lt;- Box 1
  i &lt;- Box 1
  j &lt;- Box 1
  k &lt;- Box 1
  l &lt;- Box 1
  m &lt;- Box 1
  n &lt;- Box 1
  o &lt;- Box 1
  p &lt;- Box 1
  q &lt;- Box 1
  r &lt;- Box 1
  pure 5
  where
    someValue = &quot;some really long boilerplate-y string...&quot;

    anotherComputation = case _ of
      Just x -&gt; Right $ foldl ((:)) Nil x
      Nothing -&gt; Left &quot;Not sure what went wrong here...&quot;

    -- Reader now thinks, &quot;Oh crap. My understanding is completely off
    -- now that I know `bind` really means the below definition...&quot;
    bind = -- my custom bind definition...
</code></pre>
<p>The above problem can be alleviated by bumping <code>bind</code> to the top using a let binding.</p>
<pre><code class="language-haskell">-- Reader thinks, &quot;Oh hey! It's do notation.
-- It's just standard `bind` desugaring.&quot;
comp3 :: Box Int
comp3 = do
  -- Reader thinks, &quot;Oh wait. It's using a custom bind definition.
  -- I'll need to read through this next part carefully...&quot;
  let bind = -- my custom bind definition...
  in do
    a &lt;- Box 1
    b &lt;- Box 1
    -- the rest of the code in the example above...
</code></pre>
<h2><a class="header" href="#problems-with-rebindable-doado-notation" id="problems-with-rebindable-doado-notation">Problems with Rebindable Do/Ado Notation</a></h2>
<p>There are generally two problems with Rebindable do/ado notation.</p>
<p>First, each function that uses this feature must rebind do/ado notation to the correct definition. If one was building a library where each function used this, it would get very tedious.</p>
<p>For example,</p>
<pre><code class="language-haskell">comp1 :: Box Int
comp1 = let bind = NormalBind.bind in do
  three &lt;- Box 3
  Box unit
  two &lt;- Box 2
  pure (three + two)

comp2 :: Box Int
comp2 = let bind = NormalBind.bind in do
  three &lt;- Box 3
  pure (three + two)

-- ok, this is really getting tedious...
comp3 :: Box Int
comp3 = let bind = NormalBind.bind in do
  three &lt;- Box 3
  Box unit
  two &lt;- Box 2
  pure (three + two)
</code></pre>
<p>Second, rebindable do/ado notation might not be easily redable when running computations in various monadic contexts. For example</p>
<pre><code class="language-haskell">someComputation :: Box Int
someComputation = let bind = NormalBind.bind in do
  -- Box monadic context... use standard bind here
  value1 &lt;- takesMonad1Argument (let bind = customBind in do
    -- Monad1 monadic context... use custom bind here
    value2 &lt;- runMonad1Computation
    takesMonad2Argument (let bind = NormalBind.bind in do
      -- Monad2 monadic context... use a different custom bind here...
      value3 &lt;- runMonad2Computation)
      pure (value3 + 5))
  pure (value1 + 8)
</code></pre>
<p>As can be seen, &quot;rebindable&quot; do/ado notation is good when functions do not use many lines and one is not switching back and forth between monadic contexts.</p>
<p>Still, Qualified Do/Ado helps &quot;solve&quot; each of these problems. What follows is the requirements one needs to implement before this feature will work. In this example, we'll use a more complicated example: IndexedMonad/<a href="https://pursuit.purescript.org/packages/purescript-indexed-monad/1.0.0/docs/Control.IxMonad#t:IxMonad">IxMonad</a>.</p>
<h1><a class="header" href="#12-monadliketypeclassespurs" id="12-monadliketypeclassespurs">12-MonadLikeTypeClasses.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Modification.MonadLikeTypeClasses
  ( class IxFunctor, imap, map
  , class IxApply, iapply, apply
  , class IxApplicative, ipure, pure
  , class IxBind, ibind, bind
  , class IxMonad
  , Box(..)
  ) where

import Data.Unit (Unit)
import Data.Show (class Show, show)
import Data.Semigroup ((&lt;&gt;))

-- Given a data type with instances for the IndexedMonad type class
-- hierarchy (type class instances are below each type class)
data Box :: forall k. k -&gt; k -&gt; Type -&gt; Type
data Box phantomInput phantomOutput storedValue = Box storedValue

instance (Show a) =&gt; Show (Box x x a) where
  show (Box a) = &quot;Box(&quot; &lt;&gt; show a &lt;&gt; &quot;)&quot;

-- Requirement 1: type classes that are similar to Functor to Monad hierarchy
--  - ado requirements: Functor, Apply, and Applicative
--  - do requirements: Functor, Apply, Applicative, Bind, and Monad

class IxFunctor :: forall k. (k -&gt; k -&gt; Type -&gt; Type) -&gt; Constraint
class IxFunctor f where
  imap :: forall a b x. (a -&gt; b) -&gt; f   x x a -&gt; f   x x b

instance IxFunctor Box where
  imap :: forall a b x. (a -&gt; b) -&gt; Box x x a -&gt; Box x x b
  imap f (Box a) = Box (f a)


class IxApply :: forall k. (k -&gt; k -&gt; Type -&gt; Type) -&gt; Constraint
class (IxFunctor f) &lt;= IxApply f where
  iapply :: forall a b x y z. f   x y (a -&gt; b) -&gt; f   y z a -&gt; f   x z b

instance IxApply Box where
  iapply :: forall a b x y z. Box x y (a -&gt; b) -&gt; Box y z a -&gt; Box x z b
  iapply (Box f) (Box a) = Box (f a)


class IxApplicative :: forall k. (k -&gt; k -&gt; Type -&gt; Type) -&gt; Constraint
class (IxApply f) &lt;= IxApplicative f where
  ipure :: forall a x. a -&gt; f   x x a

instance IxApplicative Box where
  ipure :: forall a x. a -&gt; Box x x a
  ipure a = Box a


class IxBind :: forall k. (k -&gt; k -&gt; Type -&gt; Type) -&gt; Constraint
class (IxApply m) &lt;= IxBind m where
  ibind :: forall a b x y z. m   x y a -&gt; (a -&gt; m   y z b) -&gt; m   x z b

instance IxBind Box where
  ibind :: forall a b x y z. Box x y a -&gt; (a -&gt; Box y z b) -&gt; Box x z b
  ibind (Box a) f =
    -- `f a` produces a value with the type, `Box y z b`, which is
    -- not the return type of this function, `Box x z b`.
    --
    -- So, we can either `unsafeCoerce` the result of `f a` or just
    -- rewrap the 'b' value in a new Box. We've chosen to take the
    -- latter option here for simplicity.
    case f a of Box b -&gt; Box b


class IxMonad :: forall k. (k -&gt; k -&gt; Type -&gt; Type) -&gt; Constraint
class (IxApplicative m, IxBind m) &lt;= IxMonad m

instance IxMonad Box

-- Requirement 2: define functions whose names correspond to the ones used
-- in the regular type classes: `map`, `apply`, 'pure', 'bind', and
-- 'discard' (for when bind returns 'unit')
map :: forall f a b x. IxFunctor f =&gt; (a -&gt; b) -&gt; f x x a -&gt; f x x b
map = imap

apply :: forall f a b x y z. IxApply f =&gt; f x y (a -&gt; b) -&gt; f y z a -&gt; f x z b
apply = iapply

pure :: forall f a x. IxApplicative f =&gt; a -&gt; f x x a
pure = ipure

bind :: forall m a b x y z. IxBind m =&gt; m x y a -&gt; (a -&gt; m y z b) -&gt; m x z b
bind = ibind

discard :: forall a x y z m. IxBind m =&gt; m x y a -&gt; (a -&gt; m y z Unit) -&gt; m x z Unit
discard = ibind
</code></pre>
<h1><a class="header" href="#13-qualified-dopurs" id="13-qualified-dopurs">13-Qualified-Do.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Modification.QualifiedDo where

-- we'll import Prelude so that the regular functions (e.g. &quot;pure&quot; &quot;bind&quot;)
-- are in scope to prove that they don't cause problems here.
import Prelude


-- Requirement 3: import the module using a module alias, making it possible
-- to use the same function names to refer to different &quot;bind&quot;-like functions
import Syntax.Modification.MonadLikeTypeClasses as I
import Syntax.Modification.MonadLikeTypeClasses (Box)

-- Requirement 4: When we want to use 'qualified do' syntax, we need to call
-- the separate functions above and constrain the types to use IxMonad
doExample :: forall input. Box input input String
doExample = I.do        -- signifies that we're using the &quot;bind&quot; and &quot;discard&quot;
                        --   functions defined in the &quot;MonadLikeTypeClasses&quot;
                        --   module to desugar &quot;&lt;-&quot; and lines that lack it
                        --   (i.e. discard)

  a &lt;- I.pure &quot;test1&quot;   -- signifies that we're using the &quot;pure&quot; function
                        --   defined in the &quot;MonadLikeTypeClasses&quot; module
  b &lt;- I.pure &quot;test2&quot;
  I.pure (a &lt;&gt; b)
</code></pre>
<h1><a class="header" href="#14-qualified-adopurs" id="14-qualified-adopurs">14-Qualified-Ado.purs</a></h1>
<pre><code class="language-haskell">module Syntax.Modification.QualifiedAdo where

-- we'll import Prelude so that the regular functions (e.g. &quot;map&quot; &quot;apply&quot;)
-- are in scope to prove that they don't cause problems here.
import Prelude


-- Requirement 3: import the module using a module alias, making it possible
-- to use the same function names to refer to different &quot;apply&quot;-like functions
import Syntax.Modification.MonadLikeTypeClasses as I
import Syntax.Modification.MonadLikeTypeClasses (Box)

-- Requirement 4: When we want to use 'qualified ado' syntax, we need to call the separate
-- function above and constrain the types to use IxApplicative
adoExample :: forall x. Box x x String
adoExample = I.ado       -- signifies that we're using the &quot;apply&quot; and &quot;map&quot;
                         --   functions defined in the &quot;MonadLikeTypeClasses&quot;
                         --   module to desugar &quot;&lt;-&quot; and &quot;in &lt;function&gt;&quot;
                         --   notation.

  a &lt;- I.pure &quot;test1&quot;    -- signifies that we're using the &quot;pure&quot; function
                         --   defined in the &quot;MonadLikeTypeClasses&quot; module
  b &lt;- I.pure &quot;test2&quot;
  in twoArgFunction a b

twoArgFunction :: String -&gt; String -&gt; String
twoArgFunction a b = a &lt;&gt; b

mixingAdosTogether :: String
mixingAdosTogether =
  &quot;&quot;&quot;
  I think &quot;qualified ado&quot; and &quot;unqualified ado&quot; can be mixed together,
  but I don't know of any examples
  &quot;&quot;&quot;
</code></pre>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<p>This folder will document everything necessary to create a simple console-based program in Purescript. It will explain:</p>
<ul>
<li>The philosophical foundations of FP programming</li>
<li>The Prelude library (including Functor, Apply, Applicative, Bind, and Monad explanations)</li>
<li>A simple &quot;Hello World&quot; program and other Effects</li>
<li>Custom Compiler Warnings/Errors</li>
<li>The difference between Local Mutable State vs Global Mutable State</li>
<li>How to test code</li>
<li>How to benchmark / profile code</li>
<li>How to structure an FP application</li>
<li>An overview of various type-level programming libraries</li>
<li>A few console-based games written in Purescript (putting it all together)</li>
</ul>
<p>While you may not be at the top of <a href="https://gist.github.com/graninas/833a9ff306338aefec7e543100c16ea1/86bcd2da3cd5d25073622316206b3fbfbd181b9e">this Haskell Competency Matrix</a> by the end of this repo, you will have taken a significant step towards that direction. This repo will not explain how to write algorithms in a performant way using an FP language. Consider reading <a href="https://www.amazon.com/Algorithm-Design-Haskell-Richard-Bird/dp/1108491618">Algorithm Design with Haskell</a> which does teach algorithms using an FP language.</p>
<p>In pursuing these goals, it will overview the following libraries:</p>
<ul>
<li>Basic
<ul>
<li>Prelude</li>
<li>Prim.TypeError</li>
</ul>
</li>
<li>Effects
<ul>
<li>Effect</li>
<li>Console</li>
<li>Random</li>
<li>Aff</li>
</ul>
</li>
<li>State
<ul>
<li>ST</li>
<li>Refs</li>
</ul>
</li>
<li>Testing
<ul>
<li>Spec</li>
<li>Quick Check</li>
<li>Quick Check Laws</li>
</ul>
</li>
<li>Benchmarking
<ul>
<li>Benchotron</li>
</ul>
</li>
<li>Advanced
<ul>
<li>Variant/VariantF</li>
<li>MTL</li>
<li>Free</li>
<li>Run</li>
</ul>
</li>
<li>UIs
<ul>
<li>Node ReadLine</li>
<li>Halogen</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#helpful-links" id="helpful-links">Helpful Links</a></h2>
<ul>
<li><a href="http://pursuit.purescript.org/">Pursuit - Docs for Purescript packages</a></li>
</ul>
<h2><a class="header" href="#other-learning-resources" id="other-learning-resources">Other Learning Resources</a></h2>
<p>Besides this repo, we have a few choices in terms of understanding functional programming. These are not necessarily &quot;either X or Y or Z&quot; choices but could be &quot;X supplemented by Y with a little bit of Z&quot;)</p>
<h3><a class="header" href="#purescript" id="purescript">Purescript</a></h3>
<ul>
<li>The <code>Purescript By Example</code> book. (See <code>ROOT_FOLDER/Getting Started/Other Important Info.md</code> for links and clarifications around it)</li>
<li><a href="https://purescript-resources.readthedocs.io/en/latest/index.html">Purescript Resources</a> - Justin Woo's Read the Docs (RTD) work</li>
</ul>
<h3><a class="header" href="#javascript" id="javascript">JavaScript</a></h3>
<p><a href="https://medium.com/@kelleyalex/index-make-the-leap-from-javascript-to-purescript-a1566d657e9c">Make the Leap from JavaScript to PureScript</a></p>
<h3><a class="header" href="#haskell" id="haskell">Haskell</a></h3>
<p>Since Purescript is heavily inspired by and very similar to Haskell, one can learn a lot about Purescript by learning from these Haskell learning resources. Note: the Haskell names and type classes do not always correspond to the Purescript versions.</p>
<table><thead><tr><th>Action</th><th>Pros</th><th>Cons</th></tr></thead><tbody>
<tr><td>Read the documentation and source code for a type class and a few data types' implementations of said type classes</td><td>Free</td><td>Takes a lot of time; requires intuition to understand type class' usefulness / relation to others.</td></tr>
<tr><td>Read through the articles on or pay for training from <a href="https://haskell.fpcomplete.com/">FP Complete's opinionated Haskell website</a></td><td>Free / Paid</td><td>(Haven't done it so I don't know)</td></tr>
<tr><td>Read through the intermediate-level Haskell articles in the <a href="https://github.com/fpco/applied-haskell#readme"><code>Applied Haskell 2018</code> GitHub Repo</a></td><td>Free</td><td>(Haven't done it so I don't know)</td></tr>
<tr><td>Read through some of the free course materials taught by someone well informed about Haskell <a href="https://github.com/bitemyapp/learnhaskell">here (you'll need to scroll towards the bottom)</a></td><td>Free; more principled explanations</td><td>Looking at just slides without hearing someone teach using them is not usually as clear as when someone does teach using them or reading through a textbook on the same matter.</td></tr>
<tr><td>Read through the extremely lengthy <a href="http://dev.stephendiehl.com/hask/">&quot;What I wish I knew when learning Haskell&quot;</a> site</td><td>Free; provides a better overview of basic to advanced topics</td><td>Very long; not necessarily deep and clear in its explanations</td></tr>
<tr><td>Read and do the exercises from <a href="http://haskellbook.com/">The Haskell Book</a></td><td>The &quot;standard&quot; for teaching Haskell and FP concepts in general: good explanations; good exercises; teaches &quot;programming in the small&quot;</td><td>Costs money; costs time; the exercises will stretch you</td></tr>
<tr><td>Read and do the exercises from <a href="https://leanpub.com/haskellcookbook">Haskell Cookbook</a>, and then its follow up book <a href="https://leanpub.com/haskellcookbook2">Haskell Cookbook 2</a></td><td>Free/Cheap; simpler than the Haskell book; gets to ideas faster; teaches &quot;programming in the large&quot;</td><td>May be harder for a new beginner (I haven't read it yet)</td></tr>
<tr><td>Watch the Intro to FP course on edX.org <a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0">here</a></td><td>Free (or paid)</td><td>(Haven't done it so I don't know)</td></tr>
<tr><td>Read the relevant chapters from <a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good</a></td><td>Free</td><td>I read elsewhere that it's &quot;outdated&quot;. See <a href="https://www.reddit.com/r/programming/comments/50m99l/new_edition_of_programming_in_haskell_now/d75pyxf/">this Reddit comment's warning about learning from LYAHH</a></td></tr>
</tbody></table>
<h3><a class="header" href="#miscellaneous-links" id="miscellaneous-links">Miscellaneous Links</a></h3>
<ul>
<li><a href="https://www.youtube.com/channel/UCEtohQeDqMSebi2yvLMUItg">LambdaConf YouTube Channel</a></li>
</ul>
<h1><a class="header" href="#prelude-ish" id="prelude-ish">Prelude-ish</a></h1>
<p>This folder will cover three things:</p>
<ul>
<li>Basic data types</li>
<li>The <code>Prelude</code> library</li>
<li>Two additional type classes: Foldable and Traversable</li>
</ul>
<h1><a class="header" href="#sum-and-product-types" id="sum-and-product-types">Sum and Product Types</a></h1>
<p>There are generally two data types in FP languages. These are otherwise known as Algebraic Data Types (ADTs):</p>
<ul>
<li>Sum types (corresponds to addition)</li>
<li>Product types (corresponds to multiplication)</li>
</ul>
<p>These are better explained <a href="https://youtu.be/Up7LcbGZFuo?t=19m8s">in this video</a> as to how they get their names.</p>
<p>The simplest form of them are <code>Either</code> and <code>Tuple</code></p>
<pre><code class="language-haskell">-- sum
data Either a b   -- a value of htis type is an `a` value OR  a `b` value
  = Left a
  | Right b

-- product        -- a value of htis type is an `a` value AND a `b` value
data Tuple a b
  = Tuple a b

-- both           --  a value of this type is one of the following:
data These a b
  = This a        --  - an `a` value
  | That b        --  - a `b` value
  | Both a b      --  - an `a` value AND a `b` value
</code></pre>
<p>However, these types can also be 'open' or 'closed':</p>
<table><thead><tr><th></th><th>Sum</th><th>Product</th><th>Sum and Product</th></tr></thead><tbody>
<tr><td>Closed</td><td><code>Either a b</code><br><br><code>Variant (a :: A, b :: B)</code></td><td><code>Tuple a b</code><br><br><code>Record (a :: A, b :: B)</code><br>(e.g. <code>{ a :: A, b :: B }</code></td><td><code>These a b</code></td></tr>
<tr><td>Open</td><td><code>Variant (a :: A | allOtherRows)</code></td><td><code>Record (a :: A | allOtherRows)</code><br>(e.g. <code>{ a :: b | allOtherRows }</code>)</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#what-does-open-mean" id="what-does-open-mean">What does 'Open' mean?</a></h2>
<p>Using this example from the Syntax folder...</p>
<pre><code class="language-haskell">-- the 'r' means, 'all other fields in the record'
function :: forall r. { fst :: String, snd :: String | r } -&gt; String
function record = record.fst &lt;&gt; record.snd

-- so calling the function with both record arguments below works
function { fst: &quot;hello&quot;, snd: &quot;world&quot; }
function { fst: &quot;hello&quot;, snd: &quot;world&quot;, unrelatedField: 0 } -- works!
-- If this function used Tuple instead of Record,
--    the first argument would work, but not the second one.
</code></pre>
<p>Here's another way to think about this:</p>
<ul>
<li><code>Record</code>s are 'nested <code>Tuple</code>s'</li>
<li><code>Variant</code>s are 'nested <code>Either</code>s'</li>
</ul>
<pre><code class="language-haskell">-- We could write
Tuple a (Tuple b (Tuple c (Tuple d e)))
-- or we could write
{ a :: A, b :: B, c :: C, d :: D, e :: E }
-- which desugars to
Record ( a :: A, b :: B, c :: C, d :: D, e :: E )

-- We could write
Either a (Either b (Either c (Either d e)))
-- or we could write
Variant ( a :: A, b :: B, c :: C, d :: D, e :: E)
</code></pre>
<p>Keep in mind that records/variants <strong>can be but do not necessarily have to be</strong> open. If we changed the above function's type signature to remove the <code>r</code>, it would restrict its arguments to a closed Record:</p>
<pre><code class="language-haskell">closed :: { fst :: String, snd :: String } -&gt; String
closed record = record.fst &lt;&gt; record.snd

closed { fst: &quot;hello&quot;, snd: &quot;world&quot; } -- compiles
closed { fst: &quot;hello&quot;, snd: &quot;world&quot;, unrelatedField: 0 } -- compiler error
</code></pre>
<h2><a class="header" href="#the-types" id="the-types">The Types</a></h2>
<h3><a class="header" href="#tuple" id="tuple">Tuple</a></h3>
<pre><code class="language-haskell">data Tuple a b = Tuple a b
</code></pre>
<table><thead><tr><th>Package</th><th>Type name</th><th>&quot;Plain English&quot; name</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-tuples/5.0.0">purescript-tuples</a></td><td><code>Tuple a b</code></td><td>2-value Box</td></tr>
</tbody></table>
<table><thead><tr><th>Usage</th><th>Values &amp; their Usage</th></tr></thead><tbody>
<tr><td>Stores two ordered unnamed values of the same/different types.<br>Can be used to return or pass in multiple unnamed values from or into a function.</td><td><code>Tuple a b</code></td></tr>
</tbody></table>
<h3><a class="header" href="#record" id="record">Record</a></h3>
<pre><code class="language-haskell">forall r. { a :: A, b :: B, {- ... -} | r } -- open record
          { a :: A, b :: B, {- ... -}     } -- closed record
</code></pre>
<table><thead><tr><th>Package</th><th>Type name</th><th>&quot;Plain English&quot; name</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#t:Record">prim</a></td><td><code>{ field :: ValueType }</code></td><td>an N-value Box</td></tr>
</tbody></table>
<table><thead><tr><th>Usage</th><th>Values &amp; their Usage</th></tr></thead><tbody>
<tr><td>Stores N ordered named values of the same/different types.<br>Can be used to return or pass in multiple unnamed values from or into a function.</td><td><code>{ field :: ValueType }</code></td></tr>
</tbody></table>
<h3><a class="header" href="#either" id="either">Either</a></h3>
<pre><code class="language-haskell">data Either a b
  = Left a
  | Right b
</code></pre>
<table><thead><tr><th>Package</th><th>Type name</th><th>&quot;Plain English&quot; name</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-either/4.0.0">purescript-either</a></td><td><code>Either a b</code></td><td>Choice of 2 types</td></tr>
</tbody></table>
<table><thead><tr><th>Usage</th><th>Values &amp; their Usage</th></tr></thead><tbody>
<tr><td>Used to indicate one type or a second type</td><td><ul><li><code>Left a</code> - a value of <code>a</code></li><li><code>Right b</code> - a value of <code>b</code></li></ul></td></tr>
<tr><td>Error handing (when we care about the error)</td><td><ul><li><code>Left a</code> - the error type that is returned when a computation fails</li><li><code>Right b</code> - the output type when a computation succeeds</li></ul></td></tr>
</tbody></table>
<h2><a class="header" href="#maybe" id="maybe">Maybe</a></h2>
<pre><code class="language-haskell">data Maybe a
  = Nothing
  | Just a
</code></pre>
<p><code>Maybe a</code> is the same as <code>Either unimportantType a</code></p>
<table><thead><tr><th>Package</th><th>Type name</th><th>&quot;Plain English&quot; name</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-maybe/4.0.0">purescript-maybe</a></td><td><code>Maybe a</code></td><td>A full or empty box</td></tr>
</tbody></table>
<table><thead><tr><th>Usage</th><th>Values' Representation</th></tr></thead><tbody>
<tr><td>Indicates an optional value</td><td><ul><li><code>Nothing</code> - value does not exist</li><li><code>Just a</code> - value does exist</li></ul></td></tr>
<tr><td>Used for error-handling when we don't care about the error (replaces <code>null</code>)</td><td><ul><li><code>Nothing</code> - An error occurred during computation</li><li><code>Just a</code> - successful computation returned output.</li></ul></td></tr>
</tbody></table>
<h3><a class="header" href="#variant" id="variant">Variant</a></h3>
<p>This is an advanced type that will be covered in the <code>Hello World/Application Structure</code> folder.</p>
<table><thead><tr><th>Package</th><th>Type name</th><th>&quot;Plain English&quot; name</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-variant/5.0.0">purescript-variant</a></td><td><code>Variant (a :: A, b :: B)</code></td><td>Choice of N types</td></tr>
</tbody></table>
<table><thead><tr><th>Usage</th><th>Values &amp; their Usage</th></tr></thead><tbody>
<tr><td>Used to indicate one type among many types</td><td>See docs</td></tr>
</tbody></table>
<h3><a class="header" href="#these" id="these">These</a></h3>
<pre><code class="language-haskell">data These a b
  = This a      -- Left  a
  | That b      -- Right b
  | Both a b    -- Tuple a b
</code></pre>
<table><thead><tr><th>Package</th><th>Type name</th><th>&quot;Plain English&quot; name</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-these/4.0.0">purescript-these</a></td><td><code>These a b</code></td><td>Same as <code>Either a (Either b (Tuple a b))</code></td></tr>
</tbody></table>
<h2><a class="header" href="#concluding-thoughts" id="concluding-thoughts">Concluding Thoughts</a></h2>
<p><strong>Performance-wise</strong>, it's generally better to use <code>Record</code> instead of <code>Tuple</code>, and it's definitely better to use <code>Record</code> instead of a nested <code>Tuple</code>.</p>
<p>Similarly, it's better to use <code>Variant</code> instead of a nested <code>Either</code>. However, sometimes <code>Either</code> is all one needs and <code>Variant</code> is overkill.</p>
<p>For people new to the language and algebraic data types (ADTs) in general, stick with <code>Tuple</code>, <code>Either</code>, and closed <code>Record</code>s.</p>
<h1><a class="header" href="#list" id="list">List</a></h1>
<p><code>List</code> is what FP programmers typically use to store a sequence of values because it is friendly to recursion. <code>Array</code> is what most mainstream languages use. Due to JavaScript's strict runtime (as opposed to Haskell's lazy runtime), most PureScript developers will use <code>Array</code> instead of <code>List</code>. However, explaining some FP concepts are easier to do using <code>List</code> rather than <code>Array</code>.</p>
<p>Understand the upcoming definition using this diagram:</p>
<pre><code>    List
   /   \
head   tail
      /  \
   head  tail
           \
           ....
          /  \
       head  Nil
</code></pre>
<pre><code class="language-haskell">-- Data.List.Types

data List a
  = Nil
  | Cons a (List a)

infixr 6 Cons as :

-- example
1 : 2 : Nil -- Cons 1 (Cons 2 Nil) -- [1, 2]
</code></pre>
<table><thead><tr><th>Package</th><th>Type name</th><th>&quot;Plain English&quot; name</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-lists/5.0.0">purescript-list</a></td><td><code>List a</code></td><td>Immutable strict singly-linked list</td></tr>
</tbody></table>
<table><thead><tr><th>Usage</th><th>Values &amp; their Usage</th></tr></thead><tbody>
<tr><td>Recursive-friendly, not-best-performant list type</td><td><ul><li><code>Nil</code> - Indicates the end of a List in pattern matching</li><li><code>Cons a (List a)</code> - stores one value of the list (head) and the tail, which is either the rest of the list (another <code>Cons</code>) or the end of the list (<code>Nil</code>).</li></ul></td></tr>
</tbody></table>
<h1><a class="header" href="#useful-types" id="useful-types">Useful Types</a></h1>
<p>The following is not an exact copy of the code, but accurate enough to get the idea across</p>
<h2><a class="header" href="#void" id="void">Void</a></h2>
<p>A type with no values that is useful for proving that a type can never exist or a computation path can never occur</p>
<pre><code class="language-haskell">-- Data.Void (Void, absurd)

newtype Void = Void Void

-- needed when one needs to refer to void
absurd :: forall a. Void -&gt; a

-- for example...
data Either a b
  = Left a
  | Right b

-- if this function compiles, it asserts that
-- only the `Right i` path is ever taken
function :: Either Void Int -&gt; Int
function Left v  = absurd v
function Right i = i
</code></pre>
<h2><a class="header" href="#unit" id="unit">Unit</a></h2>
<p>A type with 1 value, Unit, though most will see it used via <code>unit</code>. It usually indicates a &quot;side effect&quot;, mutation, or impure code.</p>
<pre><code class="language-haskell">-- Data.Unit (Unit, unit)

data Unit = Unit

unit :: Unit
unit = Unit
</code></pre>
<p>It's also used to indicate a <code>thunk</code>, a computation that we know how to do but have chosen to delay executing/evaluating until later:</p>
<pre><code class="language-haskell">type ComputationThatReturns a = (Unit -&gt; a)

thunk :: forall a. a -&gt; ComputationThatReturns a
thunk a = (\_ -&gt; a)

-- We run the pending computation (force the thunk) by passing
-- unit to it:
runPendingComputation :: ComputationThatReturns a -&gt; a
runPendingComputation thunk = thunk unit
</code></pre>
<h2><a class="header" href="#natural-transformations" id="natural-transformations">Natural Transformations</a></h2>
<p>Takes an <code>a</code> out of some <code>Box</code>-like type and puts it into another <code>Box</code>-like type</p>
<pre><code class="language-haskell">-- Data.NaturalTransformation (NaturalTransformation, (~&gt;))

-- Given this code
data Box1 a = Box1 a
data Box2 a = Box2 a

-- This function's type signature...
box1_to_box2 :: forall a. Box1 a -&gt; Box2 a
box1_to_box2 (Box1 a) = Box2 a
-- ... has a lot of noise and could be re-written to something
-- that communicates our intent better via Natural Transformations...

-- Read: change the container F to container G.
-- I don't care what type 'a' is since it's irrelevant
type NaturalTransformation f g = forall a. f a -&gt; g a

infixr 4 NaturalTransformation as ~&gt;

box1_to_box2 ::           Box1   ~&gt; Box2 {- much less noisy than
box1_to_box2 :: forall a. Box1 a -&gt; Box2 a -}
box1_to_box2             (Box1 a) = Box2 a
</code></pre>
<h1><a class="header" href="#useful-functions" id="useful-functions">Useful Functions</a></h1>
<p>These all come from <code>Data.Function</code> in Prelude.</p>
<h2><a class="header" href="#const" id="const">Const</a></h2>
<pre><code class="language-haskell">const :: forall a b. a -&gt; b -&gt; a
const x _ = x

-- Example
const 1 &quot;hello&quot; = 1
const 1 true    = 1
const 1 42      = 1
</code></pre>
<h2><a class="header" href="#flip" id="flip">Flip</a></h2>
<pre><code class="language-haskell">-- Flip the argument order
flip :: forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip twoArgFunction secondArg firstArg = twoArgFunction firstArg secondArg

-- example
     (append &quot;world!&quot; &quot;Hello &quot;) == &quot;world!Hello &quot;
(flip append &quot;world!&quot; &quot;Hello &quot;) == &quot;Hello world!&quot;
</code></pre>
<h2><a class="header" href="#apply" id="apply">Apply</a></h2>
<p>Forewarning: <code>apply</code> via <code>$</code> shows up EVERYWHERE! Bookmark this until you get it.</p>
<p>I read somewhere (I think <code>@garyb</code> mentioned this on the FP Slack, maybe...?) that <code>$</code> was chosen because it's two parenthesis with a line through it, symbolizing that it removes the need to use parenthesis.</p>
<pre><code class="language-haskell">-- Reduce the number of parenthesis needed
apply :: (a -&gt; b) -&gt; a -&gt; b
apply function arg = function arg

infix 0 apply as $

-- example
print (5 + 5) == print $ 5 + 5

print (append &quot;foo&quot; (4 + 4)) == print $ append &quot;foo&quot; $ 4 + 4
</code></pre>
<h2><a class="header" href="#other-less-used-functions" id="other-less-used-functions">Other Less-Used Functions</a></h2>
<pre><code class="language-haskell">-- apply with its arguments flipped
applyFlipped :: forall a b. a -&gt; (a -&gt; b) -&gt; b
applyFlipped = flip apply

infxl 1 applyFlipped as #

-- example
print (5 + 5) == 5 + 5 # print

-- apply a function with the given arg totalTimes
applyN :: forall a. (a -&gt; a) -&gt; Int -&gt; a -&gt; a
applyN function totalTimes arg = -- implementation
-- no infix

-- Example
applyN (+) 2 2       -- reduces to...
2 + (applyN (+) 1 2) -- reduces to...
2 + 2

-- When the desired function takes b, but you have 'a'.
-- So, we change 'a' to 'b' and then call the function
on :: forall a b c. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
on function changeAToB a1 a2 = function (changeAToB a1) (changeAToB a2)

-- Example

on (+) stringToInt &quot;4&quot; &quot;5&quot; == 9
</code></pre>
<h1><a class="header" href="#preludes-type-classes" id="preludes-type-classes">Prelude's Type Classes</a></h1>
<h2><a class="header" href="#relationships" id="relationships">Relationships</a></h2>
<p>Below is a dependency graph / type class categorization of the type classes found in Prelude. The usage frequency key is my current understanding and may be inaccurate for the &quot;somewhat&quot;/&quot;rare&quot; type classes:
<img src="content/21-Hello-World/01-Prelude-ish/./assets/Prelude-Type-Classes.svg" alt="prelude-typeclasses" title="Relationships and Categorization of Prelude's Type" /></p>
<h2><a class="header" href="#tricks-for-implementing-a-type-class-instance" id="tricks-for-implementing-a-type-class-instance">Tricks for Implementing a Type Class Instance</a></h2>
<p>Keep in mind that when implementing a type class, one does not always need to implement its function with a specific implementation for a given type. There are two situations in which this can occur:</p>
<p>First, this situation can arise when a type class defines two or more functions. Sometimes, a function in a type class can be defined using another function from that same type class. Take, for example, the <code>Eq</code> type class:</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean

  notEq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>Granted, an <code>Eq</code> instance can be derived by the compiler. However, assuming this wasn't the case, there are two ways we could implement it:</p>
<ol>
<li>We could implement only <code>eq</code> and implement <code>notEq</code> by inverting <code>eq</code>'s result.</li>
<li>We could implement only <code>notEq</code> and implement <code>eq</code> by inverting <code>notEq</code>'s result</li>
</ol>
<p>Second, sometimes, a function in a type class can be defined using a function from a required type class. Take, for example, the <code>Ord</code> type class:</p>
<pre><code class="language-haskell">data Ordering
  = LT
  | EQ
  | GT

class (Eq a) &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p>If we implement <code>compare</code>, we can also implement <code>eq</code>:</p>
<pre><code class="language-haskell">data ColoredBox
  = RedBox
  | GreenBox

instance Ord ColoredBox where
  compare RedBox GreenBox = LT
  compare GreenBox RedBox = GT
  compare _ _ = EQ {- which expands to...
  compare RedBox RedBox = EQ
  compare GreenBox GreenBox = EQ
  -}

instance Eq ColoredBox where
  eq a b = (compare a b) == EQ

  notEq a b = (compare a b) /= EQ
</code></pre>
<h1><a class="header" href="#laws" id="laws">Laws</a></h1>
<p>This is a cheatsheet for various terms used to describe laws. Not all of these will appear in Prelude and some may be explained in a type class' definition. Still, it helps to be aware of them:</p>
<table><thead><tr><th>Law</th><th>Definition</th><th>Example</th><th>Explanation of example</th></tr></thead><tbody>
<tr><td>reflexive</td><td>x function x == true</td><td><code>x &lt;= y</code></td><td><code>a &lt;= a</code> is true for any number <code>a</code> you pick</td></tr>
<tr><td>irreflexive</td><td>x function x == false</td><td><code>x &lt; y</code></td><td><code>a &lt; a</code> is false for any number <code>a</code> you pick</td></tr>
<tr><td>coreflexive</td><td>if (x function y) then (x == y)</td><td><code>(x &lt;= 15) &amp;&amp; (x == y)</code></td><td>given <code>(a &lt;= 15) &amp;&amp; (a == b)</code> , then <code>a == b</code><br>(the converse is not true, though!)</td></tr>
<tr><td>symmetric</td><td>if (x function y) then (y function x)</td><td><code>x == y</code></td><td>given <code>a == b</code>, then <code>b == a</code></td></tr>
<tr><td>antisymmetric</td><td>if (x function y &amp;&amp; y function x) then (x == y)</td><td><code>x &lt;= y</code></td><td>given <code>a &lt;= b &amp;&amp; b &lt;= a</code>, then <code>a == b</code></td></tr>
<tr><td>asymmetric</td><td>if (x function y) then (y function x == false)</td><td><code>x &lt; y</code></td><td>given <code>a &lt; b</code>, then <code>!(b &lt; a)</code><br>(asymmetric = anti-symmetric + irreflexive)</td></tr>
<tr><td>transitive</td><td>if (x function y &amp;&amp; y function z) then (x function z)</td><td><code>x == y</code>, <code>x &lt;= y</code></td><td>given <code>a == b &amp;&amp; b == c</code>, then <code>a == c</code> <br> given <code>a &lt;= b &amp;&amp; b &lt;= c</code>, then <code>a &lt;= c</code></td></tr>
</tbody></table>
<h1><a class="header" href="#objecty" id="objecty">Objecty</a></h1>
<p>In Java, every object has 3 functions:</p>
<ul>
<li>toString</li>
<li>equals</li>
<li>hashCode</li>
</ul>
<p>However, some types do not need these functions (e.g. singletons, lambda functions, etc.). Furthermore, <code>equals</code> should only work between objects of the same type (i.e. <code>4 == &quot;4&quot;</code> shouldn't compile).</p>
<p>In PureScript, we can only determine whether a value of type <code>A</code> is equal to another value of type <code>A</code> if it has an <code>Eq</code> instance. Similarly, values of a given type can only be &quot;ordered&quot; if the type has an instance of the <code>Ord</code> type class.</p>
<p>Whether a type implements a type class or not restricts or increases what one can do with it.</p>
<h2><a class="header" href="#show-eq-ord-bounded" id="show-eq-ord-bounded">Show, Eq, Ord, Bounded</a></h2>
<p>Since the documentation for these type classes are clear, we will redirect you to them instead of repeating them here:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Show">Show</a> converts a value into a String. Unfortunately, people out of convenience use it for multiple purposes. See <code>hdgarrood</code>'s <a href="https://harry.garrood.me/blog/down-with-show-part-1/">Down With Show</a> 3-part series as to why he thinks we should replace <code>Show</code> with something that better suits the purposes for which it is normally used.</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Eq">Eq</a> determines whether two values of the same type are equal. In this way, it avoids the problem that Java has above.</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Ordering">Ordering</a> is a data type for specifying whether something is less than (LT), equal to (EQ), or greater than (GT) something else.  <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Ord">Ord</a> takes two values of type, <code>a</code>, and returns an Ordering. Ord uses <code>total ordering</code>. There are a different kinds of ordering that require a different number and type of laws:
<ul>
<li><strong>Preorder</strong>: reflexive and transitive laws</li>
<li><strong>Parital order</strong>: reflexive, transitive, and antisymmetric</li>
<li><strong>Total order</strong>: reflexive, transitive, antisymmetric, and total (e.g. it can order every value of a given type)</li>
</ul>
</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Bounded">Bounded</a> just adds an upper and lower bound to Ord.</li>
</ul>
<h2><a class="header" href="#useful-derived-functions" id="useful-derived-functions">Useful Derived Functions</a></h2>
<p>Most of these come from <code>Ord</code>:</p>
<ul>
<li>min/max - self-explanatory</li>
<li>clamp - <code>clamp lowerBound upperBound value</code></li>
<li>between - <code>between lowerBound upperBound value</code></li>
</ul>
<h1><a class="header" href="#arrows" id="arrows">Arrows</a></h1>
<p>We'll explain this idea before <code>Control Flow</code>-related type classes so that you understand a notation we'll use in them.</p>
<h2><a class="header" href="#cleaner-function-notation" id="cleaner-function-notation">Cleaner Function Notation</a></h2>
<p>Let's say I have two functions:</p>
<pre><code class="language-haskell">(\x -&gt; x + 1)
(\y -&gt; y * 10)
</code></pre>
<p>If we want to apply an argument to the first and pass its output into the second, we would have to write something ugly-looking:</p>
<pre><code class="language-haskell">(\x -&gt; (\y -&gt; y * 10) (x + 1) )
</code></pre>
<p>What we mean is something like this</p>
<pre><code class="language-haskell">f = (\x -&gt; x + 1)
g = (\y -&gt; y * 10)

expression = (\arg -&gt; g (f arg))
</code></pre>
<p>We have just defined function composition, which can be written in such a way to reduce &quot;noise:&quot;</p>
<pre><code class="language-haskell">-- The arrow determines where the output goes
(\a -&gt; g (f a)) == (g &lt;&lt;&lt; f)
(\a -&gt; g (f a)) == (f &gt;&gt;&gt; g)
</code></pre>
<p>Moreover, sometimes we want a function that returns the input:</p>
<pre><code class="language-haskell">(\x -&gt; x)
-- so that we can use it like...
(\x -&gt; x) 4 == 4
</code></pre>
<p>We call this function, <code>identity</code>:</p>
<pre><code class="language-haskell">(\x -&gt; x) == identity
-- same thing
identity 4 == 4
</code></pre>
<h2><a class="header" href="#generalizing-to-more-types" id="generalizing-to-more-types">Generalizing to More Types</a></h2>
<p>To summarize...</p>
<table><thead><tr><th>Name</th><th>Meaning</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>compose</td><td><code>(\a -&gt; g (f a))</code></td><td><code>(g &lt;&lt;&lt; f)</code></td></tr>
<tr><td>composeFlipped</td><td><code>(\a -&gt; g (f a))</code></td><td><code>(f &gt;&gt;&gt; g)</code></td></tr>
<tr><td>identity</td><td><code>(\x -&gt; x) a</code></td><td><code>identity a</code></td></tr>
</tbody></table>
<p>If we were to turn <code>compose</code> into a function, it would appear with the type signature below:</p>
<pre><code class="language-haskell">compose :: forall a b c. (b -&gt; c)     -&gt; (a -&gt; b)     -&gt; (a -&gt; c)
-- However, &quot;-&gt;&quot; is just sugar syntax for Function:
compose :: forall a b c. Function b c -&gt; Function a c -&gt; Function a c
-- Notice that Function appears to be just another data structure.
-- If it works for that data structure, why not generalize it for any data structure?
compose :: forall f a b c. f b c -&gt; f a b -&gt; f a c

-- Let's rename our generics, so that it starts with `a` rather than `f`:
compose :: forall a b c d. a c d -&gt; a b c -&gt; a b d

-- We'll line up the types for easier reading:
compose :: forall a b c.           (b -&gt; c) -&gt;         (a -&gt; b) -&gt;         (a -&gt; c)

compose :: forall a b c.   Function b    c  -&gt; Function a    b  -&gt; Function a    c

compose :: forall f a b c. f        b    c  -&gt; f        a    b  -&gt; f        a    c

compose :: forall a b c d. a        c    d  -&gt; a        b    c  -&gt; a        b    d

-- We've now just defined the function `compose` for Semigroupoid:

class Semigroupoid a where
  compose :: forall b c d. a c d -&gt; a b c -&gt; a b d

-- Doing the same for identity is trivial:
identity :: forall a.            a -&gt; a

identity :: forall a.   Function a    a

identity :: forall f a. f        a    a

identity :: forall a b. a        b    b

class (Semigroupoid a) &lt;= Category a where
  -- we'll use 't' instead of 'b'
  identity :: forall t. a t t
</code></pre>
<p>Here's the docs. You likely won't be using these that often (unless perhaps you're designing a library), but it's good to know of them:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Semigroupoid#t:Semigroupoid">Semigroupoid</a> generalizes compose</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Category">Category</a> generalizes identity</li>
</ul>
<p>You will see <code>g &lt;&lt;&lt; g</code> or its flipped version <code>g &gt;&gt;&gt; f</code> a lot and we'll use it in the upcoming files.</p>
<h1><a class="header" href="#appendable-semigroup-to-monoid" id="appendable-semigroup-to-monoid">Appendable: Semigroup to Monoid</a></h1>
<p>This file will only cover the first two type classes in the type class hierarchy. The rest will be covered later.</p>
<p>These type classes often take two values of a given type and 'append' them into one new value. One could also think of this as 'reducing' two values into one value.</p>
<h2><a class="header" href="#semigroup" id="semigroup">Semigroup</a></h2>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a

infixr 5 append as &lt;&gt;
</code></pre>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<p>One example is <code>String</code>. Two String values can be 'appended/reduced' into one value by concatenating them together: <code>append &quot;hello &quot; &quot;world&quot; == &quot;hello world&quot;</code>.</p>
<p>Another example is <code>Boolean</code> (although its functions are not defined in this way as there is a better type class for them). Two Boolean values can be 'appended/reduced' into one value via the usual suspects:</p>
<ul>
<li><code>true &amp;&amp; true == true</code></li>
<li><code>false || true == true</code></li>
</ul>
<p>A third example is <code>Int</code>, which has two possible instances for 'appending/reducing' two values into one value. How? One could</p>
<ul>
<li>add them: <code>1 + 1</code></li>
<li>multiple them: <code>2 * 2</code></li>
</ul>
<p>A fourth is <code>List</code>. One can take two values of <code>List</code> and combine them together by putting both lists' elements into one new list.</p>
<h2><a class="header" href="#monoid" id="monoid">Monoid</a></h2>
<pre><code class="language-haskell">class Semigroup a &lt;= Monoid a where
  mempty :: a
</code></pre>
<p><code>mempty</code> is the &quot;identity&quot; value. In other words <code>mempty &lt;&gt; a == a</code> and <code>a &lt;&gt; mempty == a</code>. In some contexts, <code>mempty</code> acts like a &quot;default value.&quot;</p>
<p>The name, <code>mempty</code>, is used rather than <code>empty</code> because <code>empty</code> is the name of a function that a different but similar type class called <code>Plus</code> defines. We won't cover <code>Plus</code> here.</p>
<p>Using the same examples above,</p>
<table><thead><tr><th>Type</th><th><code>mempty</code> value</th><th>Example 1</th><th>Example 2</th></tr></thead><tbody>
<tr><td><code>String</code></td><td>&quot;&quot;</td><td>&quot;foo&quot; &lt;&gt; &quot;&quot; == &quot;foo&quot;</td><td>&quot;&quot; &lt;&gt; &quot;foo&quot; == &quot;foo&quot;</td></tr>
<tr><td><code>Boolean</code> (and)</td><td>true</td><td>x &amp;&amp; true == x</td><td>true &amp;&amp; x == x</td></tr>
<tr><td><code>Boolean</code> (or)</td><td>false</td><td>x `</td><td></td></tr>
<tr><td><code>Int</code> (plus)</td><td>0</td><td>x &lt;&gt; 0 == x</td><td>0 &lt;&gt; x == x</td></tr>
<tr><td><code>Int</code> (multiply)</td><td>1</td><td>x &lt;&gt; 0 == x</td><td>1 &lt;&gt; x == x</td></tr>
<tr><td><code>List</code></td><td>Nil</td><td>x &lt;&gt; Nil == X</td><td>Nil &lt;&gt; x == x</td></tr>
</tbody></table>
<h2><a class="header" href="#docs" id="docs">Docs</a></h2>
<p>Some of these type classes also specify specific helper types (sub bullets under a type class) that serve to reduce boilerplate:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Semigroup">Semigroup</a>.
<ul>
<li>When one wants to reduce two values down to one by ignoring the second value and taking the first value, one can use <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Semigroup.First">First</a></li>
<li>Or vice versa (ignore first, take second), via <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Semigroup.Last">Last</a></li>
</ul>
</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Monoid">Monoid</a>
<ul>
<li>When one wants to use <code>Semiring</code>'s <code>add</code>/<code>+</code> and <code>zero</code> as the meaning of <code>&lt;&gt;</code> and <code>mempty</code>, one can use <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Monoid.Additive">Additive</a>.</li>
<li>When one wants to use <code>Semiring</code>'s <code>mul</code>/<code>*</code> and <code>one</code> as the meaning of <code>&lt;&gt;</code> and <code>mempty</code>, one can use <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Monoid.Multiplicative">Multiplicative</a></li>
<li>When one wants to use <code>HeytingAlgebra</code>'s <code>conj</code>/<code>&amp;&amp;</code> and <code>tt</code> as the meaning of <code>&lt;&gt;</code> and <code>mempty</code>, one can use <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Monoid.Conj">Conj</a></li>
<li>When one wants to use <code>HeytingAlgebra</code>'s <code>disj</code>/<code>||</code> and <code>ff</code> as the meaning of <code>&lt;&gt;</code> and <code>mempty</code>, one can use <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Monoid.Disj">Disj</a></li>
<li>When one wants to use <code>Category</code>'s <code>compose</code>/<code>&lt;&lt;&lt;</code> and <code>identity</code> as the meaning of <code>&lt;&gt;</code> and <code>mempty</code>, one can use <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Monoid.Endo">Endo</a></li>
<li>When one wants to use <code>Category</code>'s <code>composeFlipped</code>/<code>&gt;&gt;&gt;</code> and <code>identity</code> as the meaning of <code>&lt;&gt;</code> and <code>mempty</code>, one can use <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Monoid.Dual">Dual</a></li>
</ul>
</li>
</ul>
<p>For derived functions (if any), see the type classes' docs.</p>
<h1><a class="header" href="#overview-1" id="overview-1">Overview</a></h1>
<p>There are type classes that control the flow of the program (e.g. whether the program should do X and then Y or should do X and Y at the same time).</p>
<h2><a class="header" href="#functor-apply-and-bind-type-classes-explained-in-pictures" id="functor-apply-and-bind-type-classes-explained-in-pictures">Functor, Apply, and Bind Type Classes Explained in Pictures</a></h2>
<p>We've linked to an article below that explains these abstract notions in a clear manner using pictures and the <code>Maybe a</code> data structure. However, since these concepts are explained in Haskell, which uses different terminology than Purescript, use the following table to <code>map</code> Haskell terminology to Purescript terminology:</p>
<table><thead><tr><th>Haskell Terminology</th><th>Purescript Terminology</th></tr></thead><tbody>
<tr><td><code>fmap</code> (function)</td><td><code>map</code> (function)</td></tr>
<tr><td><code>Applicative</code> (type class)</td><td><code>Apply</code> (type class)</td></tr>
<tr><td><code>Array</code>/<code>[]</code> (syntax sugar for <code>List a</code>)</td><td><code>List a</code></td></tr>
<tr><td><code>map</code> (Array function)</td><td>see <a href="content/21-Hello-World/01-Prelude-ish/08-Control-Flow-Typeclasses/index.html#lists-map-function-in-purescript">the implementation in Purescript</a></td></tr>
<tr><td><code>IO ()</code></td><td><code>Effect Unit</code>, which will be explained/used in a later part of this folder</td></tr>
</tbody></table>
<p>Here's the link: <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, and Monads in Pictures</a></p>
<h3><a class="header" href="#lists-map-function-in-purescript" id="lists-map-function-in-purescript">Lists' Map Function in Purescript</a></h3>
<p>Here's the <code>map</code> List function implemented in Purescript:</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)

instance Functor List where
  map :: forall a b. (a -&gt; b) -&gt; List a -&gt; List b
  map f Nil = Nil
  map f (Cons head tail) = Cons (f head) (map f tail)
</code></pre>
<h2><a class="header" href="#functor-apply-applicative-bind-monad" id="functor-apply-applicative-bind-monad">Functor, Apply, Applicative, Bind, Monad</a></h2>
<p>These will be covered at a slower and clearer pace in the upcoming files. This is just an overview of them.</p>
<table><thead><tr><th>Typeclass</th><th>&quot;Plain English&quot;</th><th>Function</th><th>Infix</th><th>Laws</th><th>Usage</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.Functor">Functor</a></td><td>Mappable</td><td><code>map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b</code></td><td><code>&lt;$&gt;</code> <br> (Left 4)</td><td><ul><li>identity: <code>map (\x -&gt; x) fa == fa</code></li><li>composition: <code>map (f &lt;&lt;&lt; g) = map f &lt;&lt;&lt; map g</code></li></ul></td><td>Change a value, <code>a</code>, that's currently stored in some box-like type, <code>f</code>, using a function, <code>(a -&gt; b)</code></td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Apply">Apply</a></td><td>Boxed Mappable</td><td><code>apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b</code></td><td><code>&lt;*&gt;</code> <br> (Left 4)</td><td><ul><li>Associative composition: <code>(&lt;&lt;&lt;) &lt;$&gt; f &lt;*&gt; g &lt;*&gt; h == f &lt;*&gt; (g &lt;*&gt; h)</code></li></ul></td><td>Same as <code>Functor</code> except the function is now inside of the same box-like type.</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Applicative">Applicative</a></td><td>Liftable <hr> Parallel Computation</td><td><code>pure :: forall a. a -&gt; f a</code></td><td></td><td><ul><li>identity: <code>(pure (\x -&gt; x) &lt;*&gt; v == v)</code></li><li>composition: <code>pure (&lt;&lt;&lt;) &lt;*&gt; f &lt;*&gt; g &lt;*&gt; h == f &lt;*&gt; (g &lt;*&gt; h)</code></li><li>Homomorphism: <code>(pure f) &lt;*&gt; (pure x) == pure (f x)</code></li><li>interchange: <code>u &lt;*&gt; (pure y) == (pure (_ $ y)) &lt;*&gt; u</code></li></ul></td><td>Put a value into a box <hr> Run code in parallel</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Bind">Bind</a></td><td>Sequential Computation</td><td><code>bind :: forall m a b. m a -&gt; (a -&gt; m b) -&gt; m b</code></td><td><code>&gt;&gt;=</code> <br> (Left 1)</td><td>Associativity: <code>(x &gt;&gt;= f) &gt;&gt;= g == x &gt;&gt;= (\x' -&gt; f x' &gt;&gt;= g)</code></td><td>Given an value of a box-like type, <code>m</code>, that contains a value, <code>a</code>, extract the <code>a</code> from <code>m</code>, and create a new <code>m</code> value that stores a new value, <code>b</code>. <br> Take <code>m a</code> and compute it via <code>bind</code>/<code>&gt;&gt;=</code> to produce a value, <code>a</code>. Then, use <code>a</code> to describe (but not run) a new computation, <code>m b</code>. When <code>m b</code> is computed (via a later <code>bind</code>/<code>&gt;&gt;=</code>), it will return <code>b</code>.</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Monad">Monad</a></td><td>FP Program</td><td></td><td></td><td><ul><li>Left Identity: <code>pure x &gt;&gt;= f = f x</code></li><li>Right Identity: <code>x &gt;&gt;= pure = x</code></li><li>Applicative Superclass: <code>apply = ap</code></li></ul></td><td>The data structure used to run FP programs by executing code line-by-line, function-by-function, etc.</td></tr>
</tbody></table>
<h2><a class="header" href="#simplest-monad-implementation" id="simplest-monad-implementation">Simplest Monad Implementation</a></h2>
<pre><code class="language-haskell">data Box a = Box a

instance Functor Box where
  map        f  (Box a) = Box (f a)

instance Apply Box where
  apply (Box f) (Box a) = Box (f a)

instance Bind Box where
  bind  (Box a) f       = f a

instance Applicative Box where
  pure a = Box a

instance Monad Box
</code></pre>
<h2><a class="header" href="#function-reduction" id="function-reduction">Function Reduction</a></h2>
<p>In these files, we will &quot;evaluate&quot; functions by using graph reductions: replacing the left-hand side (LHS) of the <code>=</code> sign (the function's call signature) with the right-hand side (RHS) of the <code>=</code> sign (the function's implementation / body). In other words...</p>
<pre><code class="language-haskell">someFunction arg1 arg2 arg3 = bodyOfFunction
| call signature (LHS)    | = | body (RHS) |
</code></pre>
<h1><a class="header" href="#functor-mappable" id="functor-mappable">Functor: Mappable</a></h1>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<pre><code>Change a value, `a`,
  that's currently stored in some box-like type, `f`,
into `b`
  using a function, `(a -&gt; b)`.
</code></pre>
<h2><a class="header" href="#definition-1" id="definition-1">Definition</a></h2>
<p>See its docs: <a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.Functor">Functor</a></p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

infixl 4 map as &lt;$&gt;

data Box a = Box a

instance Functor Box where
  map :: forall a b. (a -&gt; b) -&gt; Box a -&gt;  Box  b
  map                 f         (Box a) =  Box (f a)
</code></pre>
<p>Put differently, <code>Functor</code> solves a specific problem. If I have a function of type <code>(a -&gt; b)</code>, I cannot use that function on values of <code>a</code> if they are stored in a box-like type:</p>
<pre><code class="language-haskell">function :: Int -&gt; String
function 0 = &quot;0&quot;
function _ = &quot;1&quot;

function 5 -- This works!
function (Box 5) -- compiler error! Oh noes!
</code></pre>
<p>One could also see <code>map</code> as &quot;transforming&quot; a function, so that it also operates on Box-like types. This is often described as &quot;lifting&quot; a function into a Box-like type:</p>
<pre><code class="language-haskell">map :: forall a b. (a -&gt; b) -&gt; (Box a -&gt; Box b)
map f = (\(Box a) -&gt; Box (f b))
</code></pre>
<h2><a class="header" href="#laws-1" id="laws-1">Laws</a></h2>
<h3><a class="header" href="#identity" id="identity">Identity</a></h3>
<p>Definition: <code>(\x -&gt; x) &lt;$&gt; fa == fa</code></p>
<pre><code class="language-haskell">-- Start!
(\a -&gt; a) &lt;$&gt; (Box 4)
-- De-infix &quot;&lt;$&gt;&quot; to map
map (\a -&gt; a) (Box 4)
-- Replace map's &quot;call signature&quot; with its &quot;body&quot;
Box ((\a -&gt; a) 4)
-- Apply argument by replacing '\a' with its argument '4'
Box ((\4 -&gt; 4)  )
-- Keep only the body of function
Box ((      4)  )
-- Remove parenthesis and whitespace
Box 4
-- Check whether left-hand side (LHS) equals right-hand side (RHS)
(Box 4) == (Box 4)
-- Law met!
true
</code></pre>
<h3><a class="header" href="#composition" id="composition">Composition</a></h3>
<p>(Remember, <code>g &lt;&lt;&lt; f</code> means <code>(\a -&gt; g (f a))</code>)</p>
<p>Definition: <code>map (g &lt;&lt;&lt; f) = (map g) &lt;&lt;&lt; (map f)</code></p>
<pre><code class="language-haskell">-- # Reduce left side of the law #

-- Start!
map ((\y -&gt; y * 10) &lt;&lt;&lt; (\x -&gt; x + 1)) (Box 4)
-- Remember that `f &lt;&lt;&lt; g` means `(\a -&gt; f (g a))`
-- Reduce the &quot;&lt;&lt;&lt;&quot; into one function
map (\x -&gt; 10 * (x + 1)) (Box 4)
-- Replace map's &quot;call signature&quot; with its &quot;body&quot;
Box ((\x -&gt; 10 * (x + 1)) 4)
-- Apply argument by replacing '\x' with its argument '4'
Box ((\4 -&gt; 10 * (4 + 1))  )
-- Keep only the body of function
Box ((      10 * (4 + 1))  )
-- Reduce the body of function to its end result:
Box ((      10 * (5    ))  )
Box ((      10 *  5     )  )
Box ((      50          )  )
-- Remove parenthesis and whitespace
Box 50

-- # Reduce right side of the law #

-- Start!
(map (\y -&gt; y * 10)) &lt;&lt;&lt; (map (\x -&gt; x + 1)) (Box 4)
-- Reduce &quot;&lt;&lt;&lt;&quot; into one function
(\box4    -&gt; map (\y -&gt; y * 10) ( map (\x -&gt; x + 1)  box4  ) ) (Box4)
-- Apply argument
(\(Box 4) -&gt; map (\y -&gt; y * 10) ( map (\x -&gt; x + 1) (Box 4)) )
-- Keep only the body of function
(            map (\y -&gt; y * 10) ( map (\x -&gt; x + 1) (Box 4)) )
-- Replace 2nd map &quot;call signature&quot; with its &quot;body&quot;
(            map (\y -&gt; y * 10) ( Box (\x -&gt; x + 1) 4) )
-- Apply the argument
(            map (\y -&gt; y * 10) ( Box (\4 -&gt; 4 + 1)  ) )
-- Keep only the body of the function
(            map (\y -&gt; y * 10) ( Box (      4 + 1)  ) )
-- Calculate the function
(            map (\y -&gt; y * 10) ( Box (      5    )  ) )
-- Remove unneeded parenthesis
(            map (\y -&gt; y * 10)   Box        5         )
-- Remove unneeded whitespace
(            map (\y -&gt; y * 10) Box 5                  )
-- Replace map's &quot;call signature&quot; with its &quot;body&quot;
(                               Box ((\y -&gt; y * 10) 5) )
-- Apply the argument
(                               Box ((\5 -&gt; 5 * 10)  ) )
-- Keep only the function
(                               Box ((      5 * 10)  ) )
-- Calculate the function
(                               Box ((      50    )  ) )
-- Remove unneeded parenthesis
                                Box         50
-- Shift everything left
Box 50

-- Test if LHS equals RHS
(Box 50) == (Box 50)
-- Law met!
true
</code></pre>
<h2><a class="header" href="#derived-functions" id="derived-functions">Derived Functions</a></h2>
<p>See the docs above for their definitions and read through the source code:</p>
<ul>
<li>Ignore the <code>a</code> value and just replace it with
<ul>
<li>the value towards which the arrow points...
<ul>
<li>(<code>voidLeft</code> / <code>$&gt;</code>): <code>(Box 4) $&gt; &quot;a&quot; == (Box &quot;a&quot;)</code></li>
<li>(<code>voidRight</code> / <code>&lt;$</code>): <code>&quot;a&quot; &lt;$ (Box 4) == (Box &quot;a&quot;)</code></li>
</ul>
</li>
<li><code>Unit</code> (<code>void</code>): <code>void (Box 4) == (Box unit)</code>
<ul>
<li><strong>Note:</strong> <code>void</code> is used heavily to make it work with the <code>Discard</code> type class in <code>do</code> notation.</li>
</ul>
</li>
</ul>
</li>
<li>Flip the order of map's arguments (<code>mapFlipped</code> / <code>&lt;#&gt;</code>)</li>
<li>Generalize <code>flip</code>, so that it works for all types (<code>flap</code> / <code>&lt;@&gt;</code>)</li>
</ul>
<h1><a class="header" href="#apply-1" id="apply-1">Apply</a></h1>
<h2><a class="header" href="#usage-1" id="usage-1">Usage</a></h2>
<p>Shorter: Same as <code>Functor</code>, but the function is also in the box-like type, <code>f</code>.</p>
<p>Longer:</p>
<pre><code>Change a value, `a`,
  that's currently stored in some box-like type, `f`,
into `b`
  using a function, `(a -&gt; b)`,
    that is also stored in the same box-like type, `f`.
</code></pre>
<h2><a class="header" href="#definition-2" id="definition-2">Definition</a></h2>
<p>See its docs: <a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Apply">Apply</a></p>
<pre><code class="language-haskell">class (Functor f) &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b

infixl 4 apply as &lt;*&gt;

data Box a = Box a

instance Functor Box where
  map :: forall a b.       (a -&gt; b) -&gt; Box a -&gt; Box  b
  map                       f         (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box  b
  apply               (Box  f     )   (Box a) = Box (f a)
</code></pre>
<p>Put differently, <code>Apply</code> solves a problem that occurs when using <code>Functor</code>. If I have a function of type <code>(a -&gt; b -&gt; c)</code>, I can use <code>Functor</code>'s <code>map</code>/<code>&lt;$&gt;</code> to lift that function into a Box-like type as before....</p>
<pre><code class="language-haskell">mapResult :: Box (Int -&gt; Int)
mapResult = map (\first second -&gt; first + second) (Box 1)
</code></pre>
<p>However, the resulting value stored in that Box-like type is a function. In other words, <code>mapResult == Box (\second -&gt; 1 + second)</code>. <code>Functor</code>'s <code>map</code> only works if the function takes only one argument. If it takes 2+ arguments, <code>map</code> will return a function stored in a <code>Box</code>.</p>
<p>This is where <code>Apply</code> comes to the rescue. We can continue to apply boxed arguments to that function until we eventually get a Box with a value in it:</p>
<pre><code class="language-haskell">finalResult :: Box Int
finalResult =
  apply mapResult (Box 2)                                 {-

  ...which is the same as...
  Box ((\second -&gt; 1 + second) 2)
  Box ((\2      -&gt; 1 + 2     )  )
  Box ((           3         )  )
  Box 3                                                   -}
</code></pre>
<p>Thus, <code>map</code> lifts functions that take <code>n</code>-many arguments into a Box-like type, and <code>Apply</code>'s <code>apply</code>/<code>&lt;*&gt;</code> continues to pass <code>n-1</code>-many boxed arguments into that function until the function executes.</p>
<h2><a class="header" href="#laws-2" id="laws-2">Laws</a></h2>
<h3><a class="header" href="#associative-composition" id="associative-composition">Associative Composition</a></h3>
<p>Definition: <code>(&lt;&lt;&lt;) &lt;$&gt; f &lt;*&gt; g &lt;*&gt; h == f &lt;*&gt; (g &lt;*&gt; h)</code></p>
<p>TODO: prove the above law using <code>Box</code> (a lot of work, so ignoring for now...)</p>
<h2><a class="header" href="#derived-functions-1" id="derived-functions-1">Derived Functions</a></h2>
<ul>
<li>Do two computations, but only return...
<ul>
<li>the first: <code>applyFirst</code> / <code>&lt;*</code></li>
<li>the second: <code>applySecond</code> / <code>*&gt;</code></li>
</ul>
</li>
<li><code>liftN</code> is explained below:</li>
</ul>
<h3><a class="header" href="#liftn-notation" id="liftn-notation">LiftN Notation</a></h3>
<p>Let's rename that <code>Functor</code>'s <code>map</code> function to <code>lift1</code>:</p>
<pre><code class="language-haskell">{-
map   (\oneArg -&gt; doStuffWith oneArg) (Box 4) -}
lift1 (\oneArg -&gt; doStuffWith oneArg) (Box 4)
</code></pre>
<p>This function can only take one arg. What if want to take two args? We should call it <code>lift2</code>:</p>
<pre><code class="language-haskell">lift2 (\arg1 arg2 -&gt; andThen (doStuffWith arg1) arg2) (Box 4) (Box 4)
</code></pre>
<p>That works, but we could also write it:</p>
<pre><code class="language-haskell">(\arg1 arg2 -&gt; andThen (doStuffWith arg1) arg2) &lt;$&gt; (Box 4) &lt;*&gt; (Box 4)
</code></pre>
<p>Using meta-language</p>
<pre><code class="language-haskell">function_NotInBox_takes_n_args &lt;$&gt; boxedArg1 &lt;*&gt; boxedArg2 -- &lt;*&gt; boxedArgN ...
</code></pre>
<h1><a class="header" href="#applicative" id="applicative">Applicative</a></h1>
<h2><a class="header" href="#usage-2" id="usage-2">Usage</a></h2>
<ul>
<li>Lift any value/function/etc. into a box-like type, <code>f</code></li>
<li>Parallel Computation: Do all three simultaneously: X, Y, and Z.</li>
</ul>
<p>(<strong>Note:</strong> Javascript is currently single-threaded, so this isn't entirely true. If it gets multi-thread support, that will change.)</p>
<h2><a class="header" href="#definition-3" id="definition-3">Definition</a></h2>
<p>See its docs: <a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Applicative">Applicative</a></p>
<pre><code class="language-haskell">class (Apply f) &lt;= Applicative f where
  pure :: forall a. a -&gt; f a

data Box a = Box a

instance Functor Box where
  map :: forall a b.       (a -&gt; b) -&gt; Box a -&gt; Box  b
  map                       f         (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box  b
  apply               (Box  f     )   (Box a) = Box (f a)

instance Applicative Box where
  pure :: forall a. a -&gt; Box a
  pure              a =  Box a
</code></pre>
<h2><a class="header" href="#laws-3" id="laws-3">Laws</a></h2>
<h3><a class="header" href="#identity-1" id="identity-1">Identity</a></h3>
<p>Definition: <code>(pure (\x -&gt; x) &lt;*&gt; v == v)</code></p>
<pre><code class="language-haskell">-- Start: 'v' == (Box 4)
(pure (\x -&gt; x)) &lt;*&gt; (Box 4)
-- Replace pure call signature with body
( Box (\x -&gt; x)) &lt;*&gt; (Box 4)
-- De-infix &lt;*&gt; to apply
apply (Box (\x -&gt; x)) (Box 4)
-- Replace apply call signature with body
Box (\x -&gt; x) 4)
-- Apply argument by replacing all 'x' with '4'
Box (\4 -&gt; 4)  )
-- Keep body of function
Box (      4)  )
-- Remove whitespace and parenthesis
Box 4
-- Check law
(Box 4) == (Box 4)
-- Law met!
true
</code></pre>
<h3><a class="header" href="#composition-1" id="composition-1">Composition</a></h3>
<p>Definition: <code>pure (&lt;&lt;&lt;) &lt;*&gt; f &lt;*&gt; g &lt;*&gt; h == f &lt;*&gt; (g &lt;*&gt; h)</code></p>
<p>TODO: prove the above law using <code>Box</code> (a lot of work, so ignoring for now...)</p>
<h3><a class="header" href="#homomorphism" id="homomorphism">Homomorphism</a></h3>
<p>Definition: <code>(pure f) &lt;*&gt; (pure x) == pure (f x)</code></p>
<p>TODO: prove the above law using <code>Box</code> (a lot of work, so ignoring for now...)</p>
<h3><a class="header" href="#interchange" id="interchange">Interchange</a></h3>
<p>Definition: <code>u &lt;*&gt; (pure y) == (pure (_ $ y)) &lt;*&gt; u</code></p>
<p>TODO: prove the above law using <code>Box</code> (a lot of work, so ignoring for now...)</p>
<h2><a class="header" href="#derived-functions-2" id="derived-functions-2">Derived Functions</a></h2>
<ul>
<li>Define an instance of <code>Apply</code> and <code>Applicative</code> and you get a <code>Functor</code> implementation for free!: <code>liftA1</code></li>
<li>Do a computation...
<ul>
<li>if some condition is true: <code>when</code></li>
<li>if some condition is false: <code>unless</code></li>
</ul>
</li>
</ul>
<p>Note: <code>when</code>/<code>unless</code> is strict. For a lazy version, see <a href="https://github.com/natefaubion/purescript-call-by-name">purescript-call-by-name</a></p>
<h1><a class="header" href="#bind" id="bind">Bind</a></h1>
<h2><a class="header" href="#usage-3" id="usage-3">Usage</a></h2>
<p>Short:</p>
<ul>
<li>Sequential Computation: do X, and once finished do Y, and once finished do Z</li>
</ul>
<p>Long:</p>
<ol>
<li>Given a value, <code>a</code>, that is stored in a box-like type, <code>m</code></li>
<li>Extract the <code>a</code> from the box, <code>m</code></li>
<li>Pass it into a function, <code>(a -&gt; m b)</code>
<ul>
<li>The function uses the value <code>a</code> to compute a new value, <code>b</code>.</li>
<li>The function wraps the new value <code>b</code> into the same box-like type, <code>m</code>.</li>
<li>The function returns a box, <code>m</code>, that stores the new value, <code>b</code>.</li>
</ul>
</li>
<li>Refer to the <code>b</code> value as <code>a</code> and repeat <code>Steps 1-3</code> until we run out of functions</li>
<li>The last function returns the final <code>b</code> value that is stored in the same box-like type, <code>m</code>.</li>
</ol>
<h2><a class="header" href="#definition-4" id="definition-4">Definition</a></h2>
<p>See its docs: <a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Bind">Bind</a></p>
<p>Below, we'll show two instances for <code>Bind</code>:</p>
<ol>
<li>A flipped version of bind that shows how it relates to <code>Functor</code> and <code>Apply</code></li>
<li>The correct version:</li>
</ol>
<pre><code class="language-haskell">-- in real definition, 'f' (functor) is really 'm' (monad)
class (Appy f) &lt;= Bind f where
  bind :: forall a b. f a -&gt; (a -&gt; f b) -&gt; f b

infixl 1 bind as &gt;&gt;=

data Box a = Box a

instance Functor Box where
  map :: forall a b.         (a -&gt;     b) -&gt; Box a -&gt; Box  b
  map                         f             (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b.   Box (a -&gt;     b) -&gt; Box a -&gt; Box  b
  apply                 (Box  f         )   (Box a) = Box (f a)

-- Wrong: Flipped order of two args!
instance Bind_ Box where
  bindFlipped :: forall a b. (a -&gt; Box b) -&gt; Box a -&gt; Box  b
  bindFlipped                 f             (Box a) = f a

-- Correct order of args
instance Bind Box where
  bind :: forall a b.  Box a -&gt; (a -&gt; Box b) -&gt; Box b
  bind                (Box a)    f            = f a
</code></pre>
<p><code>bind</code>'s type signature is weird. How did we ever come up with that? To understand it (and understand why we have the below 'derived functions'), watch <a href="https://youtu.be/gHiyzctYqZ0?t=725">Category Theory 10.1: Monads</a> and refer to the code below for help in understanding it:</p>
<pre><code class="language-haskell">-- &gt;=&gt; the &quot;fish operator&quot; is
-- called &quot;composeKleisli&quot;
infix composeKleisli 6 &gt;=&gt;

-- see &quot;(a -&gt; m b)&quot; as the definition
-- of `pure` from the `Applicative` type class.
composeKleisli :: forall m a b c. Functor f =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)
composeKleisli f g =
  \a -&gt;
    let mb = f a
    in (bind mb g)

  where
    bind :: m b -&gt; (b -&gt; m c) -&gt; m c
    bind functor function = join (map function functor)

    join :: m (m a) -&gt; m a
    join = -- implementation
</code></pre>
<h2><a class="header" href="#laws-4" id="laws-4">Laws</a></h2>
<h3><a class="header" href="#associativity" id="associativity">Associativity</a></h3>
<p>(This law enables &quot;do notation&quot;, which we'll explain soon.)</p>
<p>Definition: <code>(x &gt;&gt;= f) &gt;&gt;= g == x &gt;&gt;= (\x' -&gt; f x' &gt;&gt;= g)</code></p>
<p>TODO: prove the above law using <code>Box</code> (a lot of work, so ignoring for now...)</p>
<h2><a class="header" href="#derived-functions-3" id="derived-functions-3">Derived Functions</a></h2>
<ul>
<li>If you have nested boxes and need to remove the outer one (<code>join</code>):
<ul>
<li><code>join (Box (Box a)) == Box a</code></li>
</ul>
</li>
<li>Make chained multiple <code>aToMB</code> functions easier to read...
<ul>
<li>going forwards (<code>composeKleisli</code>/<code>&gt;=&gt;</code>):
<ul>
<li><code>ma &gt;=&gt; aToMB &gt;=&gt; bToMC &gt;=&gt; ...</code></li>
</ul>
</li>
<li>going backwards (<code>composeKleisliFlipped</code>/<code>&lt;=&lt;</code>):
<ul>
<li><code>... &lt;=&lt; bToMC &lt;=&lt; aToMB &lt;=&lt; ma</code></li>
</ul>
</li>
</ul>
</li>
<li><code>if computeCondition then truePathComputation else falsePathComputation</code> (<code>ifM</code>)</li>
<li>If you want <code>bind</code>/<code>&gt;&gt;=</code> to go in the opposite direction (<code>bindFlipped</code>/<code>=&lt;&lt;</code>):
<ul>
<li><code>ma &gt;&gt;= aToMB == aToMB =&lt;&lt; ma</code></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#monad" id="monad">Monad</a></h1>
<h2><a class="header" href="#usage-4" id="usage-4">Usage</a></h2>
<p>Monad = Sequential Computation (<code>Bind</code>) + Lift a Value/Function into Box-like Type (<code>Applicative</code>)</p>
<h2><a class="header" href="#definition-5" id="definition-5">Definition</a></h2>
<p>See its docs: <a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Control.Monad">Monad</a></p>
<pre><code class="language-haskell">class (Applicative m, Bind m) &lt;= Monad m

data Box a = Box a

instance Functor Box where
  map :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box  b
  map f (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box  b
  apply (Box f) (Box a) = Box (f a)

instance Bind Box where
  bind :: forall a b. Box a -&gt; (a -&gt; Box b) -&gt; Box b
  bind (Box a) f = f a

instance Applicative Box where
  pure :: forall a. a -&gt; Box a
  pure a =  Box a

instance Monad Box
</code></pre>
<h2><a class="header" href="#laws-5" id="laws-5">Laws</a></h2>
<h3><a class="header" href="#unofficial" id="unofficial">Unofficial</a></h3>
<p>Taken from <a href="https://youtu.be/EoJ9xnzG76M?t=7m9s">this slide in this YouTube video</a>, here's an &quot;unofficial&quot; but clearer way to understand the laws for Monad by comparing them to a Function:</p>
<pre><code class="language-haskell">-- Recall: `identity a == (\x -&gt; x) a`

-- Given a function whose type signature is...
(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
(aToMB &gt;=&gt; bToMC) a = (aToMB a) &gt;&gt;= (\b -&gt; bToMC b)

-- ... Monad could be defined by these laws:
-- 1a. Function's identity law
(function &gt;&gt;&gt; identity) a == function a
 aToMB    &gt;=&gt; pure        == aToMB

-- 1b. its inverse
(identity &gt;&gt;&gt; f)        a == f a
 pure     &gt;=&gt; f           == f

-- 2. Function Composition
f &gt;&gt;&gt; (g &gt;&gt;&gt; h) == (f &gt;&gt;&gt; g) &gt;&gt;&gt; h
f &gt;=&gt; (g &gt;=&gt; h) == (f &gt;=&gt; g) &gt;=&gt; h
</code></pre>
<h3><a class="header" href="#official" id="official">Official</a></h3>
<h4><a class="header" href="#identity-2" id="identity-2">Identity</a></h4>
<p>Definition (left) : <code>pure x &gt;&gt;= f = f x</code></p>
<pre><code class="language-haskell">-- start
pure x  &gt;&gt;= f
-- replace call signature with body
(Box x) &gt;&gt;= f
-- de-infix `&gt;&gt;=` to `bind`
bind (Box x) f
-- replace call signature with body
f x
-- check LHS with RHS
f x == f x
-- Law met!
true
</code></pre>
<p>Definition (right): <code>x &gt;&gt;= pure = x</code></p>
<h4><a class="header" href="#applicative-superclass" id="applicative-superclass">Applicative Superclass</a></h4>
<p>Definition: <code>apply = ap</code> (where <code>ap</code> is a derived function)</p>
<h2><a class="header" href="#derived-functions-4" id="derived-functions-4">Derived Functions</a></h2>
<ul>
<li>Define an instance of <code>Applicative</code>, <code>Bind</code>, and <code>Monad</code> and...
<ul>
<li>you get a <code>Functor</code> implementation for free!: <code>liftM1</code></li>
<li>you get an <code>Apply</code> implementation for free!: <code>ap</code></li>
</ul>
</li>
<li>Do a computation...
<ul>
<li>if some condition is true: <code>whenM</code></li>
<li>if some condition is false: <code>unlessM</code></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#how-the-computer-executes-fp-programs" id="how-the-computer-executes-fp-programs">How the Computer Executes FP Programs</a></h1>
<p>Or &quot;What does sequential computation look like using Monads&quot;</p>
<p>Below, we'll be defining a long chain of nested functions. Since functions usually place their argument on the right of the body like this...</p>
<pre><code>(\x -&gt; body) actualArgument
</code></pre>
<p>... we'll be putting it on the left using <code>#</code></p>
<pre><code>actualArgument # (\x -&gt; body)
</code></pre>
<p>In other words...</p>
<pre><code class="language-haskell">function      arg == arg # function
(\x -&gt; x + 1) arg == arg # (\x -&gt; x + 1)
</code></pre>
<p>This will help the upcoming examples be much clearer and more understandable.</p>
<p>Using this type and its instance...</p>
<pre><code class="language-haskell">data Box a = Box a

instance Functor Box where
  map :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box  b
  map f (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box  b
  apply (Box f) (Box a) = Box (f a)

instance Bind Box where
  bind :: forall a b. Box a -&gt; (a -&gt; Box b) -&gt; Box b
  bind (Box a) f = f a

instance Applicative Box where
  pure :: forall a. a -&gt; Box a
  pure a =  Box a
</code></pre>
<p>... we will translate the Javascript &quot;program&quot; below...</p>
<pre><code class="language-javascript">const four = 4
const five = 1 + four
const five_string = toString(five); // or whatever the function called
print(five_string); // print the String to the console, which returns nothing
</code></pre>
<p>... into its corresponding Purescript &quot;program&quot; (next).</p>
<p>In the following snippet of code, you will need to scroll to the right, so that the a previous reduction aligns with the next reduction. <strong>Note: Read through this and practice writing it out multiple times until you get sick of it as this is at the heart of FP programming! Failure to understand this == Failure to write FP code.</strong> Here's the code:</p>
<pre><code class="language-haskell">unsafePerformEffect :: forall a. Box a -&gt; a
unsafePerformEffect (Box a) = a

-- Compute what the final Box value is in `main`
-- and then call `unsafePerformEffect` on the final Box
runProgram :: Unit
runProgram = unsafePerformEffect main

main :: Box Unit
main =
  (Box 4) &gt;&gt;= (\four -&gt; Box (1 + four) &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string)))

-- Step 1: De-infix the first '&gt;&gt;=' alias back to bind
  bind (Box 4)  (\four -&gt; Box (1 + four) &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string)))

-- Step 2: Look up Box's bind implementation...
--   ...and replace the left-hand side with the right-hand side
            4 # (\four -&gt; Box (1 + four) &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string)))

            -- Step 3: Apply the arg to the function (i.e. replace &quot;four&quot; with 4)
                (\4    -&gt; Box (1 + 4   ) &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string)))

                -- Step 4: Reduce the function to its body
                          Box (1 + 4   ) &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string))

                          -- Step 5: Reduce the argument in &quot;Box (1 + 4)&quot; to &quot;Box 5&quot;
                          Box (5       ) &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string))

                          -- Step 6: Remove the parenthesis
                          Box  5         &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string))

                          -- Step 7: Remove the extra whitespace and push right
                                   Box 5 &gt;&gt;= (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string))

                                   -- Step 8: Repeat Steps 1-7 for the next &quot;&gt;&gt;=&quot;
                                   bind (Box 5)  (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string))

                                             5 # (\five -&gt; Box (show five) &gt;&gt;= (\five_string -&gt; print five_string))

                                                 (\5    -&gt; Box (show 5   ) &gt;&gt;= (\five_string -&gt; print five_string))

                                                           Box (show 5   ) &gt;&gt;= (\five_string -&gt; print five_string)

                                                           Box (&quot;5&quot;      ) &gt;&gt;= (\five_string -&gt; print five_string)

                                                           Box  &quot;5&quot;        &gt;&gt;= (\five_string -&gt; print five_string)

                                                                   Box &quot;5&quot; &gt;&gt;= (\five_string -&gt; print five_string)

                                                                   -- Step 8: Repeat Steps 1-6 for the next &quot;&gt;&gt;=&quot;
                                                                   bind (Box &quot;5&quot;)  (\five_string -&gt; print five_string)

                                                                             &quot;5&quot; # (\five_string -&gt; print five_string)

                                                                                   (\&quot;5&quot;         -&gt; print &quot;5&quot;)

                                                                                                    print &quot;5&quot;

                                                                  -- Step 9: Look up `print`'s definition
                                                                  --
                                                                  --   print :: forall a. a -&gt; Box Unit
                                                                  --   print a =
                                                                  --      -- Assume that 'a' is printed to the console
                                                                  --      Box unit
                                                                  --
                                                                  -- ... and replace the LHS with RHS

                                                                                                     Box unit

                                                                  -- Step 10a: Shift everything to the left again
-- 10b) ... and re-expose the 'main' function:
main :: Unit
main = Box unit -- after all the earlier computations...

-- Step 12: call `unsafePerformEffect` to get the final Box's value
runProgram :: Unit
runProgram = unsafePerformEffect (Box unit)
-- becomes
runProgram :: Unit
runProgram = unit
</code></pre>
<p>Now go read the code snippet above again and write it out!</p>
<h2><a class="header" href="#do-and-ado-notation" id="do-and-ado-notation">Do and Ado Notation</a></h2>
<p>At this point, you should look back at the <code>Syntax/Prelude-Syntax</code> folder and read through its files. Feel free to ignore the <code>Qualified Do/Ado Explained</code> file and those that follow.</p>
<p>Once finished, read the next file.</p>
<h1><a class="header" href="#useful-monads" id="useful-monads">Useful Monads</a></h1>
<p><strong>Note:</strong> This file's contents assumes you have read through and are somewhat familiar with the contents of the file, <code>Syntax/Prelude Syntax/Reading Do as Nested Binds.md</code>.</p>
<p>So far, we have only shown you the <code>Box</code> monad to help you get used to the syntax and see the logic for how <code>Monad</code> and <code>bind</code>/<code>&gt;&gt;=</code> works. (The <code>Box</code> type is a learner-friendly name for the <code>Identity</code> monad, which we'll cover later in the <code>Application Structure</code> folder.)</p>
<p>However, <code>Monads</code> are used to compose two or more computations that occur within the same context (where context refers to the monadic type being used). Whereas the monadic type, <code>Box</code>/<code>Identity</code>, only has one possible value, the below types have two possible values. Functions that produce two possible outputs don't typically compose. However, the <code>Monad</code> type class enables us to compose them using &quot;railway-oriented programming&quot; (~Scott Wlaschin).</p>
<p>When we compose different monadic types, we get different control flows. The <code>do</code> notation helps us avoid the <a href="https://www.wikiwand.com/en/Pyramid_of_doom_(programming)">Pyramid of Doom</a> boilerplate code and emphasizes developer intent.</p>
<h2><a class="header" href="#the-maybe-monad" id="the-maybe-monad">The Maybe Monad</a></h2>
<h3><a class="header" href="#javascript-code" id="javascript-code">JavaScript Code</a></h3>
<p>In JavaScript, we might write this code:</p>
<pre><code class="language-javascript">let a = computation();
if (a == null) {
  return null;
} else {
  let b = compute1(a);
  if (b == null) {
    return null;
  } else {
    let c = compute2(b);
    if (c == null) {
      return null;
    } else {
      return compute3(c);
    }
  }
}
</code></pre>
<h3><a class="header" href="#purescript-code-non-idiomatic" id="purescript-code-non-idiomatic">PureScript Code (non-idiomatic)</a></h3>
<p>In PureScript, we <em>could</em> write the following <strong>non-idiomatic</strong> code that repeats this Pyramid of Doom:</p>
<pre><code class="language-haskell">data Maybe a
  = Nothing
  | Just a

someComputation :: Maybe Unit
someComputation =
  case computation of
    Nothing -&gt; Nothing
    Just a -&gt; case compute1 a of
      Nothing -&gt; Nothing
      Just b -&gt; case compute2 b of
        Nothing -&gt; Nothing
        Just c -&gt; compute3 c
  where
    computation :: Maybe a
    compute1 :: a -&gt; Maybe b
    compute2 :: b -&gt; Maybe c
    compute3 :: c -&gt; Maybe Unit
</code></pre>
<h3><a class="header" href="#purescript-code-idiomatic" id="purescript-code-idiomatic">PureScript Code (idiomatic)</a></h3>
<p>Or, we could use <code>Maybe</code>'s <code>Monad</code> instance via <code>do notation</code> to write <strong>idiomatic</strong> PureScript code:</p>
<pre><code class="language-haskell">data Maybe a
  = Nothing
  | Just a

instance Bind Maybe where
  bind :: forall a b. Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
  -- when given a Nothing, stop all possible future computations
  -- and return immediately.
  bind Nothing _ = Nothing
  -- when given a Just, run the function on its contents
  -- and continue any Monadic computations
  bind (Just a) f = f a

someComputation :: Maybe ReturnValue
someComputation = do
  a &lt;- computation
  b &lt;- compute1 1
  c &lt;- compute2 b
  compute3 c
  where
    computation :: Maybe a
    compute1 :: a -&gt; Maybe b
    compute2 :: b -&gt; Maybe c
    compute3 :: c -&gt; Maybe Unit
</code></pre>
<p>If a <code>Nothing</code> value is given at any point in the nested-<code>bind</code> computations, it will short-circuit and return immediately.</p>
<p>What is a real-world example of using the Maybe monad? One often writes monadic code using Maybe as the Monad to lookup values in some structure (e.g. <code>Map</code>, <code>Array</code>, <code>List</code>, or <code>Tree</code>). Often, this control flow reads like this: &quot;Try to get value X. If it exists, try to get value Y. If that exists, do something with both. If either one of them does not exist, stop and return immediately.&quot; In other words...</p>
<pre><code class="language-haskell">example :: Maybe String
example = do
  x &lt;- index 4 array
  y &lt;- lookup &quot;fooKey&quot; map
  pure (x + y)
</code></pre>
<h2><a class="header" href="#the-either-monad" id="the-either-monad">The Either Monad</a></h2>
<h3><a class="header" href="#javascript-code-1" id="javascript-code-1">JavaScript Code</a></h3>
<p>In JavaScript, we might write this code:</p>
<pre><code class="language-javascript">let a = computation();
if (isError(a)) {
  return a;
} else {
  let b = compute1(a);
  if (isError(b)) {
    retun b;
  } else {
    let c = compute2(b);
    if (isError(c)) {
      return c;
    } else {
      return compute3(c);
    }
  }
}
</code></pre>
<h3><a class="header" href="#purescript-code-non-idiomatic-1" id="purescript-code-non-idiomatic-1">PureScript Code (non-idiomatic)</a></h3>
<pre><code class="language-haskell">data Either a b
  = Left a
  | Right b

someComputation :: Either ErrorType ReturnValue
someComputation = do
  case computation of
    Left err -&gt; Left err
    Right a -&gt; case compute1 a of
      Left err -&gt; Left err
      Right b -&gt; case compute2 b of
        Left err -&gt; Left err
        Right c -&gt; compute3 c
  where
    computation :: Either ErrorType a
    compute1 :: a -&gt; Either ErrorType b
    compute2 :: b -&gt; Either ErrorType c
    compute3 :: c -&gt; Either ErrorType Unit
</code></pre>
<h3><a class="header" href="#purescript-code-idiomatic-1" id="purescript-code-idiomatic-1">PureScript Code (idiomatic)</a></h3>
<p>Or, we could use <code>Either</code>'s <code>Monad</code> instance via <code>do notation</code> to write <strong>idiomatic</strong> PureScript code:</p>
<pre><code class="language-haskell">data Either a b
  = Left a
  | Right b

instance Bind (Either a) where
  bind :: forall b c. Either a b -&gt; (b -&gt; Either a c) -&gt; Either a c
  -- when given a Left, stop all possible future computations
  -- and return immediately.
  bind l@(Left _) _ = l
  -- when given a Right, run the function on its contents
  -- and continue any Monadic computations
  bind (Right a) f = f a

someComputation :: Either ErrorType ReturnValue
someComputation = do
  a &lt;- computation
  b &lt;- compute1 1
  c &lt;- compute2 b
  compute3 c
</code></pre>
<p>If a <code>Left</code> value is given at any point in the nested-<code>bind</code> computations, it will short-circuit and return immediately.</p>
<p>What is a real-world example of using the Either monad? One often uses it to validate that some data is correct. It reads like, &quot;Try to parse the given <code>String</code> into an <code>Int</code>. If it fails, stop. Otherwise, try to parse the given <code>String</code> into a <code>Foo</code>. If it fails, stop. Otherwise, take the <code>Int</code> and the <code>Foo</code> and do something with them.&quot;</p>
<pre><code class="language-haskell">example :: String -&gt; Either String ValidatedData
example string = do
  intValue &lt;- parseString string
  fooValue &lt;- parseNextPart
  doSomethingWith intValue fooValue
</code></pre>
<h2><a class="header" href="#the-list--array-monad" id="the-list--array-monad">The List / Array Monad</a></h2>
<p>We use the <code>List</code> type below in our examples. However, the <code>Array</code> type works exactly the same way.</p>
<h2><a class="header" href="#javascript-code-2" id="javascript-code-2">JavaScript Code</a></h2>
<p>In JavaScript, we would might write this code:</p>
<pre><code class="language-javascript">let list1 = [1, 2, 3];
let list2 = [2, 3, 4];
let list3 = [3, 4, 5];
var finalList = [];

for (i of list1) {
  for (h of list2) {
    for (j of list3) {
      finalList.push(i + h + j);
    }
  }
}
return finalList;
</code></pre>
<h2><a class="header" href="#purescript-code-idiomatic-2" id="purescript-code-idiomatic-2">PureScript Code (idiomatic)</a></h2>
<p>The non-idiomatic version of the PureScript code below is complicated because it uses a lot of recusion. Thus, I do not show it here. Rather, we'll only show the idiomatic version:</p>
<pre><code class="language-haskell">data List a
  = Nil
  | Cons a (List a)

-- bind implementation not shown here
instance Bind List where
  bind :: forall a b. List a -&gt; (a -&gt; List b) -&gt; List b
  -- when given a Nil (end of list), stop all potential future computations and return immediately.
  bind Nil _ = Nil
  -- when given a non-empty list, run the future computations on the head
  -- and then prepend it to the rest of the computations on the tail.
  bind (head : tail) f = append (f head) (bind tail f)

append :: List x -&gt; List x -&gt; List x
append =
  -- implementation not shown here, but the result will be
  -- append (1 : 2 : Nil) (3 : 4 : Nil) == (1 : 2 : 3 : 4 : Nil)

someComputation :: List Int
someComputation = do
  a &lt;- (1 : 2 : 3 : Nil)
  b &lt;- (2 : 3 : 4 : Nil)
  c &lt;- (3 : 4 : 5 : Nil)
  pure (a + b + c)
</code></pre>
<p>which outputs:</p>
<pre><code class="language-haskell">-- a = 1, b = 2
( 6 : 7 : 8
-- a = 1, b = 3
: 7 : 8 : 9
-- a = 1, b = 4
: 8 : 9 : 10

-- a = 2, b = 2
: 7 : 8 : 9
-- a = 2, b = 3
: 8 : 9 : 10
-- a = 2, b = 4
: 9 : 10 : 11

-- a = 3, b = 2
: 8 : 9 : 10
-- a = 3, b = 3
: 9 : 10 : 11
-- a = 3, b = 4
: 10 : 11 : 12

: Nil)
</code></pre>
<h2><a class="header" href="#concluding-thoughts-1" id="concluding-thoughts-1">Concluding Thoughts</a></h2>
<p>Different monadic types lead to different control flow statements. We've only shown a few here.</p>
<p>We will see more control flow options in the <code>Application Structure</code> folder, but there's more ground-work to cover before it'll make sense.</p>
<h1><a class="header" href="#monoids-reconsidered" id="monoids-reconsidered">Monoids Reconsidered</a></h1>
<p>The below table is a summarized version of something <code>cvlad</code> explained in the FP Slack channel.</p>
<table><thead><tr><th>When we want to compose...</th><th>...and we don't need &quot;empty&quot; value, we use</th><th>...and we do need &quot;empty&quot; value, we use</th></tr></thead><tbody>
<tr><td>two values of same type</td><td>Semigroup</td><td>Monoid</td></tr>
<tr><td>two values of different types where the second value DOES NOT have a runtime dependency on the first value</td><td>Apply</td><td>Applicative</td></tr>
<tr><td>two values of different types where the second value DOES have a runtime dependency on the first value</td><td>Bind</td><td>Monad</td></tr>
</tbody></table>
<p>What was <code>@cvlad</code> explaining? The meaning to this famous quote (in category theory terms):</p>
<blockquote>
<p>A Monad is just a Monoid in the category of Endofunctors</p>
</blockquote>
<p>To understand the quote more, see this link's 2-minute concise summary, which was also provided by <code>cvlad</code>: https://twitter.com/kenscambler/status/955441793465696257</p>
<h1><a class="header" href="#one-monadic-type-per-monadic-context" id="one-monadic-type-per-monadic-context">One Monadic Type Per Monadic Context</a></h1>
<p>Before we can continue further, we must understand one of the implications of the <code>bind</code> function.</p>
<h2><a class="header" href="#defining-the-problem" id="defining-the-problem">Defining the Problem</a></h2>
<p>Let's look at the type signature for the <code>bind</code> function.</p>
<pre><code class="language-haskell">class Apply boxLike &lt;= Bind boxLike where
  bind :: forall a b. boxLike a -&gt; (a -&gt; boxLike b) -&gt; boxLike b
</code></pre>
<p>If we ignore the <code>(a -&gt; boxLike b)</code> argument, we can summarize it like this:</p>
<blockquote>
<p>If you give me a &quot;box-like&quot; type, I will output the <strong>same</strong> &quot;box-like&quot; type.</p>
</blockquote>
<p>In other words, once we use <code>bind</code> in a given computation (e.g. <code>do notation</code>), we restrict all usages of <code>bind</code> within that same computation to the same &quot;box-like&quot; type we originally passed in. This restriction is a good thing. There are ways to workaround the limitation. We'll cover one workaround below, but the other workarounds will be covered in the <code>Application Structure</code> folder.</p>
<p>Throughout this work, we will refer to this restriction as the &quot;<code>bind</code> outputs the same box-like type it receives&quot; restriction.</p>
<p>For now, let's provide an example of this problem.</p>
<h2><a class="header" href="#example-of-the-problem" id="example-of-the-problem">Example of the Problem</a></h2>
<p>Let's say we have two <code>Box</code> types. They differ only in their name. Each implements the <code>Functor</code>, <code>Apply</code>, and <code>Bind</code> instances in the exact same way. Below, we will only show the <code>Bind</code> instance, but assume they have implemented the other type classes:</p>
<pre><code class="language-haskell">data Box1 a = Box1 a
data Box2 a = Box2 a

class Apply m &lt;= Bind m where
  bind :: forall a b. m    a -&gt; (a -&gt; m    b) -&gt; m    b

instance Bind Box1 where
  bind :: forall a b. Box1 a -&gt; (a -&gt; Box1 b) -&gt; Box1 b
  bind               (Box1 a)   f              = f a
instance Bind Box2 where
  bind :: forall a b. Box2 a -&gt; (a -&gt; Box2 b) -&gt; Box2 b
  bind               (Box2 a)   f              = f a
</code></pre>
<p>Recall that <code>do notation</code> desugars into multiple <code>bind</code> calls:</p>
<pre><code class="language-haskell">example :: Box1 int
example = do
  u &lt;- Box unit
  five &lt;- Box 5
  pure (five + 1)

-- desugars to
example =
  bind (Box unit) \u -&gt;
    bind (Box 5) \five -&gt;
      pure (five + 1)
</code></pre>
<p>The below <code>Box1</code> computation compiles fine.</p>
<pre><code class="language-haskell">box1Computation :: Box1 Unit
box1Computation = Box1 unit
</code></pre>
<p>The below <code>Box2</code> computation compiles fine:</p>
<pre><code class="language-haskell">box2Computation :: Box2 Unit
box2Computation = Box2 unit
</code></pre>
<p>If I write the following code, which (if any) will compile?</p>
<pre><code class="language-haskell">box1ThenBox2 :: Box2 Unit
box1ThenBox2 = do
  box1Computation
  box2Computation

box2ThenBox1 :: Box1 Unit
box2ThenBox1 = do
  box2Computation
  box1Computation
</code></pre>
<p>Neither will compile. In <code>box1ThenBox2</code>, the first computation is <code>box1Computation</code>. Thus, this computation should eventually output a value of the <code>Box1 someOutput</code> type. However, we attempt to run a computation that uses a different monad (i.e. <code>Box2</code>) within the <code>Box1</code> monadic context. Since <code>Box2</code> isn't <code>Box1</code>, we get a compiler error. This same error occurs when you attempt to compile <code>box2ThenBox1</code>.</p>
<h2><a class="header" href="#the-first-workaround-lifting-one-monad-into-another" id="the-first-workaround-lifting-one-monad-into-another">The First Workaround: Lifting One Monad into Another</a></h2>
<p>Sometimes, this restriction actually helps us write safer code. Other times, this restriction is problematic and we need to get around it.</p>
<p>To help develop the necessary foundation for later understanding, we'll show a general approach to workaround this restriction. We use a type class that follows this idea:</p>
<pre><code class="language-haskell">class LiftSourceIntoTargetMonad sourceMonad targetMonad where {-
  liftSourceMonad :: forall a. sourceMonad a -&gt; targetMonad a -}
  liftSourceMonad ::           sourceMonad   ~&gt; targetMonad

-- Note: instances of this idea might be more complicated than this one
instance LiftSourceIntoTargetMonad Box2 Box1 where {-
  liftSourceMonad :: forall a. Box2 a -&gt; Box1 a                      -}
  liftSourceMonad ::           Box2   ~&gt; Box1
  liftSourceMonad (Box2 a) = Box1 a
</code></pre>
<p>This enables something like the following. It can be pasted into the REPL and one can try it out by calling <code>bindAttempt</code>:</p>
<pre><code class="language-haskell">import Prelude -- for the (+) and (~&gt;) function aliases

data Box1 a = Box1 a
data Box2 a = Box2 a

class LiftSourceIntoTargetMonad sourceMonad targetMonad where                 {-
  liftSourceMonad :: forall a. sourceMonad a -&gt; targetMonad a                 -}
  liftSourceMonad ::           sourceMonad   ~&gt; targetMonad

instance LiftSourceIntoTargetMonad Box2 Box1 where
  liftSourceMonad :: Box2 ~&gt; Box1
  liftSourceMonad (Box2 a) = Box1 a

bindAttempt :: Box1 Int
bindAttempt = do
  four &lt;- Box1 4
  six &lt;- liftSourceMonad $ Box2 6
  pure $ four + six

-- type class instances for Monad hierarchy

instance Functor Box1 where
  map :: forall a b. (a -&gt; b) -&gt; Box1 a -&gt; Box1  b
  map f (Box1 a) = Box1 (f a)

instance Apply Box1 where
  apply :: forall a b. Box1 (a -&gt; b) -&gt; Box1 a -&gt; Box1  b
  apply (Box1 f) (Box1 a) = Box1 (f a)

instance Bind Box1 where
  bind :: forall a b. Box1 a -&gt; (a -&gt; Box1 b) -&gt; Box1 b
  bind (Box1 a) f = f a

instance Applicative Box1 where
  pure :: forall a. a -&gt; Box1 a
  pure a =  Box1 a

instance Monad Box1

-- Needed to print the result to the console in the REPL session

instance (Show a) =&gt; Show (Box1 a) where
  show (Box1 a) = show a
</code></pre>
<h1><a class="header" href="#appendable-numeric-hierarchy" id="appendable-numeric-hierarchy">Appendable: Numeric Hierarchy</a></h1>
<p>After Semigroup and Monoid, the rest of PureScript's Numeric type classes (e.g. <code>Semiring</code>, <code>Ring</code>, etc.) and all the mathematical notations they use are very clearly explained elsewhere in <a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">hdgarrood's Numeric Hierarchy Overview</a>.</p>
<p>Once one finishes reading it, be sure to check out <a href="https://harry.garrood.me/numeric-hierarchy-overview/">his full-screen cheatsheet</a> and <a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/appendix/purescript-impls.html">his overview of PureScript's numeric types</a></p>
<p>Another resource that might be helpful is <a href="https://argumatronic.com/posts/2019-06-21-algebra-cheatsheet.html">A Brief Guide to A Few Algebraic Data Structures</a>. However, this is more of a reference material than a tutorial like Harry's above overview.</p>
<h2><a class="header" href="#docs-1" id="docs-1">Docs</a></h2>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Semiring">Semigring</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Ring">Ring</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.CommutativeRing">CommutativeRing</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.EuclideanRing">EuclideanRing</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.DivisionRing">DivisionRing</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Field">Field</a></li>
</ul>
<p>For derived functions (if any), see the type classes' docs.</p>
<h1><a class="header" href="#effect-and-aff" id="effect-and-aff">Effect and Aff</a></h1>
<p>This folder accomplishes the following goals:</p>
<ul>
<li>An explanation of what &quot;native side-effects&quot; are and how this is modeled via <code>Effect</code>.</li>
<li>A demonstration of how to write the infamous &quot;Hello World&quot; app in Purescript</li>
<li>A demonstration of the various <code>Effect</code> types out there and their usage.</li>
<li>An overview of <code>Aff</code> and how to use some of its API.</li>
<li>An explanation and example of using the first workaround to the &quot;<code>bind</code> outputs the same box-like type it receives&quot; restriction.</li>
<li>A how-to guide for dealing with &quot;callback hell&quot; via <code>Aff</code> and using <code>Node.ReadLine</code> as an example.</li>
</ul>
<p>These examples are compilable, enabling the reader to do two things.</p>
<h2><a class="header" href="#repl" id="repl">REPL</a></h2>
<p>First, one can interact with the code in this folder by using the REPL via the command, <code>spago repl</code>. Once initialized, one can import a module into the REPL and play with the code from there (e.g. run <code>main</code>).</p>
<p>For example, one might input the following command sequence:</p>
<pre><code class="language-bash">spago repl
import HelloWorld
main
</code></pre>
<p><strong>Note: some of the code in this folder will not work properly when used with the REPL. When it doesn't, use the second approach below.</strong></p>
<h2><a class="header" href="#compilation" id="compilation">Compilation</a></h2>
<p>Second, one can compile the examples into their resulting JavaScript files. One can view just the module (i.e. the JavaScript code generated from a single PS file) or the entire program as an executable file (i.e. the JavaScript code generated from a call to file's <code>main</code> function). The latter can be run using <code>Node</code>:</p>
<table><thead><tr><th></th><th>Single Module</th><th>Entire Program</th></tr></thead><tbody>
<tr><td>Command</td><td><code>spago make-module --main [moduleName] --to dist/module.js</code></td><td><code>spago bundle-app --main [moduleName] --to dist/app.js</code></td></tr>
<tr><td>Javascript files' location</td><td><code>dist/module.js</code></td><td><code>dist/app.js</code></td></tr>
</tbody></table>
<h3><a class="header" href="#effect-folder" id="effect-folder">Effect Folder</a></h3>
<p>To run each program in the <code>Effect</code> folder, use these commands:</p>
<pre><code class="language-bash"># Syntax
# spago run --main Module.Path.To.Main.Module

spago run --main HelloWorld
spago run --main HelloNumber
spago run --main HelloDoNotation
spago run --main RandomNumber
spago run --main CurrentDateAndTime
spago run --main TimeoutAndInterval
spago run --main MutableState.Global
spago run --main MutableState.Local
</code></pre>
<h3><a class="header" href="#aff-folder" id="aff-folder">Aff Folder</a></h3>
<p>To run each program in the <code>Aff</code> folder, use these commands:</p>
<pre><code class="language-bash">spago run -m AffBasics.LaunchAff
spago run -m AffBasics.Delay
spago run -m AffBasics.ForkJoin
spago run -m AffBasics.SuspendJoin
spago run -m AffBasics.CachedJoin
spago run -m AffBasics.SwitchingContexts
spago run -m TimeoutAndInterval.Aff
</code></pre>
<p>The following examples must be compiled first and then run by <code>node</code>:</p>
<pre><code class="language-haskell">spago bundle-app -m ConsoleLessons.ReadLine.Effect -t dist/readline-effect.js &amp;&amp; node dist/readline-effect.js

spago bundle-app -m ConsoleLessons.ReadLine.Aff -t dist/readline-aff.js &amp;&amp; node dist/readline-aff.js
</code></pre>
<h2><a class="header" href="#the-effect-monad" id="the-effect-monad">The Effect Monad</a></h2>
<p>(The following section is copied from <a href="https://github.com/purescript/documentation/blob/master/guides/Eff.md">here</a> and slightly edited. I would add the license for that here, but it's not listed. Since the documentation is supposed to be public anyways, I doubt this is an issue.)</p>
<p>When we talk about side-effects, we are referring to two possible meanings. The first are &quot;non-native&quot; side-effects that we can emulate using pure functions (e.g. state manipulation on immutable data structures, returning additional output from a computation, etc.). The second are &quot;native side-effects&quot;, which are effects provided by the RunTime System (RTS) and which can't be emulated by pure functions.</p>
<p>Some examples of native effects are:</p>
<ul>
<li>Shared
<ul>
<li>Random number generation</li>
<li>Exceptions</li>
<li>Rendering content to the screen</li>
</ul>
</li>
<li>Node only:
<ul>
<li>User input via the terminal</li>
<li>Interacting with the File System</li>
</ul>
</li>
<li>Browser only:
<ul>
<li>DOM manipulation</li>
<li>XMLHttpRequest / AJAX calls</li>
<li>Interacting with a websocket</li>
<li>Interacting with Cookies</li>
</ul>
</li>
</ul>
<p>PureScript's <a href="https://pursuit.purescript.org/packages/purescript-effect/"><code>purescript-effect</code></a> package defines a monad called <code>Effect</code>, which is used to handle native effects. The goal of the <code>Effect</code> monad is to provide a typed API for effectful computations, while at the same time generating efficient Javascript.</p>
<p>(The remainder of this article is my own work.)</p>
<h2><a class="header" href="#understanding-the-effect-monad" id="understanding-the-effect-monad">Understanding the Effect Monad</a></h2>
<p>The following code is not necessarily how <code>Effect</code> is implemented, but it does help one quickly understand it by analogy:</p>
<pre><code class="language-haskell">data Unit = Unit

unit :: Unit
unit = Unit

-- | A computation that will only be run when passed in a `unit`
type PendingComputation a = (Unit -&gt; a)

-- | A data structure that stores a pending computation.
data Effect a = Box (PendingComputation a -&gt; a)

-- | This unwraps the data structure to get the
-- | pending computation, uses it to compute a value,
-- | and returns its result.
unsafePerformEffect :: Effect a -&gt; a
unsafePerformEffect (Box pendingComputation) = pendingComputation unit
</code></pre>
<p>Some readers may realize that this is similar to the idea we introduced back in <code>ROOT_FOLDER/Hello-World/Prelude/Control-Flow--Functor-to-Monad.md</code> when we showed how an FP program does sequential computation using Monads. If you replace <code>Box</code> from that example with <code>Effect</code>, you would have a working FP program.</p>
<p>The whole idea of <code>Effect</code> is to use <code>unsafePerformEffect</code> as little as possible and ideally only once as the program's main entry point, explained next.</p>
<h2><a class="header" href="#main-a-programs-entry-point" id="main-a-programs-entry-point">Main: A Program's Entry Point</a></h2>
<p>The entry point into each program written in Purescript is the <code>main</code> function. It's type signature must be: <code>main :: Effect Unit</code>.</p>
<p>The following explanation is not what happens in practice, but understanding it this way will help one understand the concepts it represents:</p>
<blockquote>
<p>When one executes the command <code>spago bundle-app</code>, one could say that, conceptually, spago will compile <code>unsafePerformEffect main</code> into Javascript and the resulting Javascript is what gets run by the RunTime System (RTS) when the program is executed.</p>
</blockquote>
<p>In other words, spago &quot;creates&quot; a function called <code>runProgram</code> and tells the RunTime System (RTS) to execute it</p>
<pre><code class="language-haskell">runProgram :: Unit
runProgram = unsafePerformEffect main
</code></pre>
<p>This limits our impure code as much as possible to the program's start. Hopefully, everything else in our code is pure.</p>
<p>However, one might still call <code>unsafePerformEffect</code> in otherwise pure code in situations where they know what they are doing. In other words, they know the pros &amp; cons, costs &amp; benefits of doing so, and are willing to pay for those costs to achieve their benefits.</p>
<h1><a class="header" href="#02-hello-worldpurs" id="02-hello-worldpurs">02-Hello-World.purs</a></h1>
<pre><code class="language-haskell">-- This is the infamous &quot;Hello World&quot; app in Purescript.
module HelloWorld where

import Prelude  -- imports Unit

-- new imports
import Effect (Effect)
import Effect.Console (log) -- log :: String -&gt; Effect Unit

-- | Describes but does not run a computation until RTS &quot;calls unsafePerformEffect&quot;.
-- | The type signature of `log` is `String -&gt; Effect Unit`. Thus, by applying
-- | a value of type `String` as an argument to `log`,
-- | `log &quot;Hello World!&quot;` has the type signature `Effect Unit`.
-- | Thus, it can be used as a main entry point into a program.
main :: Effect Unit
main = log &quot;Hello world!&quot;
</code></pre>
<h1><a class="header" href="#03-hello-numberpurs" id="03-hello-numberpurs">03-Hello-Number.purs</a></h1>
<pre><code class="language-haskell">module HelloNumber where

import Prelude
import Effect (Effect)

-- new imports

-- logShow :: forall a. Show a =&gt; a -&gt; Effect Unit
-- logShow arg = log $ show arg
import Effect.Console (logShow)

main :: Effect Unit
main = logShow 5
</code></pre>
<h1><a class="header" href="#04-hello-do-notationpurs" id="04-hello-do-notationpurs">04-Hello-Do-Notation.purs</a></h1>
<pre><code class="language-haskell">module HelloDoNotation where

import Prelude
import Effect (Effect)
import Effect.Console (log)

-- A refresher on 'do-notation'

-- This chain of functions via log
main' :: Effect Unit
main' = (log &quot;This is outputted first&quot;) &gt;&gt;= (\_ -&gt;
          (log &quot;This is outputted second&quot;) &gt;&gt;= (\_ -&gt;
            log &quot;This is outputted third&quot;
          )
        )

-- can become more readable using sugar syntax (do-notation):
main :: Effect Unit
main = do
  log &quot;This is outputted first&quot;
  log &quot;This is outputted second&quot;
  log &quot;This is outputted third&quot;
</code></pre>
<h1><a class="header" href="#01-random-numberpurs" id="01-random-numberpurs">01-Random-Number.purs</a></h1>
<pre><code class="language-haskell">module RandomNumber where

import Prelude
import Effect (Effect)
import Effect.Console (log)

-- new import
import Effect.Random (random)
-- random :: Effect Number

main :: Effect Unit
main = do
  n &lt;- random
  log $ &quot;A random number between 0.0 and 1.0: &quot; &lt;&gt; show n

  -- The above two lines could also be combined into one
  --   if we resort to using bind-notation again:
  random &gt;&gt;= (\n2 -&gt; log $ &quot;Another random number: &quot; &lt;&gt; show n2)

  -- The above line still works because `log` returns `Effect Unit`
</code></pre>
<h1><a class="header" href="#02-current-date-and-timepurs" id="02-current-date-and-timepurs">02-Current-Date-and-Time.purs</a></h1>
<pre><code class="language-haskell">module CurrentDateAndTime where

import Prelude
import Effect (Effect)
import Effect.Console (log, logShow)

-- new import
import Effect.Now as Now

main :: Effect Unit
main = do
  dateAndTime &lt;- Now.nowDateTime
  logShow dateAndTime

  log &quot;------------&quot;

  -- To reduce the above to one line, we'll combine the two using bind-notation.
  -- Since `logShow` has the type signature `Effect Unit`, the do-notation
  -- still works.

  Now.nowDate &gt;&gt;= (\x -&gt; logShow x)
  Now.nowTime &gt;&gt;= (\x -&gt; logShow x)

  -- We could make the above even shorter by removing the 'x' argument
  Now.nowDate &gt;&gt;= logShow
  Now.nowTime &gt;&gt;= logShow
</code></pre>
<h1><a class="header" href="#03-timeout-and-intervalpurs" id="03-timeout-and-intervalpurs">03-Timeout-and-Interval.purs</a></h1>
<pre><code class="language-haskell">module TimeoutAndInterval where

import Prelude
import Effect (Effect)
import Effect.Console (log)

-- new import
import Effect.Timer as T

-- Unfortunately, the code below won't work as expected because
-- the callbacks never run. Not enough time passes before they get triggered.
-- We'll see how to fix this using the `Aff` monad later in this folder.
main :: Effect Unit
main = do
  timeoutID &lt;- T.setTimeout 1000 (log &quot;This will run after 1 second&quot;)
  intervalID &lt;- T.setInterval 10 (log &quot;Interval ran!&quot;)

  log &quot;Doing some other things....&quot;
  log (evaluate 10 20)
  log &quot;... Finished.&quot;

  log &quot;Now cancelling interval&quot;
  T.clearInterval intervalID

  log &quot;Now cancelling timeout&quot;
  T.clearTimeout timeoutID

  log &quot;Program is done!&quot;

evaluate :: Int -&gt; Int -&gt; String
evaluate x y | x &lt; y = show x &lt;&gt; &quot; is less than &quot; &lt;&gt; show y
             | x &gt; y = show x &lt;&gt; &quot; is greater than &quot; &lt;&gt; show y
             | otherwise = show x &lt;&gt; &quot; is equal to &quot; &lt;&gt; show y
</code></pre>
<h1><a class="header" href="#mutable-state-global-vs-local" id="mutable-state-global-vs-local">Mutable State: Global vs Local</a></h1>
<p>There are two types of mutable state:</p>
<table><thead><tr><th></th><th>Global</th><th>Local</th></tr></thead><tbody>
<tr><td>Creatable in...</td><td>Anywhere</td><td>Local scope</td></tr>
<tr><td>Readable from...</td><td>Anywhere that has its reference</td><td>Local Scope</td></tr>
<tr><td>Writable to...</td><td>Anywhere that has its reference</td><td>Local Scope</td></tr>
<tr><td>Destroyed when...</td><td>Program Exits?</td><td>Exit Local Scope</td></tr>
</tbody></table>
<p>Using JavaScript as an example...</p>
<pre><code class="language-javascript">var global_state = &quot;some state&quot;;
var doStuffUsingLocalState() = {
  var local_state = &quot;some value&quot;;
  local_state = local_state + &quot;some other string&quot;;
  return local_state.length();
}
var example1() {
  // change global state
  global_state = &quot;first change!&quot;;
  // localState changed during the execution of the below
  // function, but we can't change it outside of that function.
  doStuffUsingLocalState();
}
example1();
var example2() {
  global_state = &quot;second change!&quot;;
  return;
}
example2();
</code></pre>
<h1><a class="header" href="#01-globalpurs" id="01-globalpurs">01-Global.purs</a></h1>
<pre><code class="language-haskell">module MutableState.Global where

import Prelude
import Effect (Effect)
import Effect.Console (log)

-- new import
import Effect.Ref as Ref

main :: Effect Unit
main = do
  box &lt;- Ref.new 0

  x0 &lt;- Ref.read box
  log $ &quot;x0 should be 0: &quot; &lt;&gt; show x0

  Ref.write 5 box
  Ref.read box &gt;&gt;= (\x1 -&gt; log $ &quot;x1 should be 5: &quot; &lt;&gt; show x1)

  Ref.modify_ (\oldState -&gt; oldState + 1) box
  x2 &lt;- Ref.read box
  log $ &quot;x2 should be 6: &quot; &lt;&gt; show x2

  newState &lt;- Ref.modify (\oldState -&gt; oldState + 1) box
  x3 &lt;- Ref.read box
  log $ &quot;x3 should be 7: &quot; &lt;&gt; show x3 &lt;&gt; &quot; | newState should be 7: &quot; &lt;&gt; show newState

  value &lt;- Ref.modify' (\oldState -&gt; { state: oldState * 10, value: 30 }) box
  x4 &lt;- Ref.read box
  log $ &quot;value should be 30: &quot; &lt;&gt; show value
  log $ &quot;x4 should be 70: &quot; &lt;&gt; show x4

  let loop 0 = Ref.read box
      loop n = do
        _ &lt;- Ref.modify (_ + 1) box
        loop (n - 1)
  _ &lt;- loop 20
  log &quot;Finished&quot;
</code></pre>
<h1><a class="header" href="#02-localpurs" id="02-localpurs">02-Local.purs</a></h1>
<pre><code class="language-haskell">module MutableState.Local where

import Prelude

import Control.Monad.ST as ST
import Control.Monad.ST.Ref as STRef
import Effect (Effect)
import Effect.Console (log)

main :: Effect Unit
main = do
  log &quot;We will run some modifications on some local state \
      \and then try to modify it out of scope.&quot;
  let result = ST.run do
        {-
        At this level of indentation, we are in the ST monadic context.
        Since `log` returns an `Effect a`, we can't use it here.

        At this point in our understanding, we don't currently have a way
        to print the values of the local state to the console.

        We'll explain why this is a good thing later on in the `Debugging` folder.
        -}

        box &lt;- STRef.new 0
        x0 &lt;- STRef.read box

        _ &lt;- STRef.write 5 box
        x1 &lt;- STRef.read box

        newState &lt;- STRef.modify (\oldState -&gt; oldState + 1) box
        x3 &lt;- STRef.read box

        value &lt;- STRef.modify' (\oldState -&gt; { state: oldState * 10, value: 30 }) box
        x4 &lt;- STRef.read box

        let loop 0 = STRef.read box
            loop n = do
              _ &lt;- STRef.modify (_ + 1) box
              loop (n - 1)

        loop 20

  log $ &quot;Result of computation that used local state was: &quot; &lt;&gt; show result

  log &quot;Attempting to access `box` in this monadic context will result \
      \in a compiler error.&quot;
</code></pre>
<h2><a class="header" href="#summary-of-effect-libraries" id="summary-of-effect-libraries">Summary of Effect Libraries</a></h2>
<p>Since the <code>spago.dhall</code> file does not allow me to explain what each dependency does, I've offloaded that to the table below. These are not all of the Effects that exist. For example, I did not cover <code>Avar</code>, <code>Aff</code>, and others (see the full list on Pursuit <a href="https://pursuit.purescript.org/search?q=Effect">here</a>. Not all of the <code>Effects</code> found on there are truly <code>Effect</code>s as they might be newtypes for something else). Rather, they give you something to use as you learn more and more of Purescript and FP concepts:</p>
<table><thead><tr><th>Library</th><th>Included Module</th><th>Usage</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-effect/2.0.0">purescript-effect</a></td><td><code>Effect</code></td><td>Provides the <code>Effect</code> type itself.</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-console/4.1.0">purescript-console</a></td><td><code>Effect.Console</code></td><td>Provides bindings to the Console</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-random/4.0.0">purescript-random</a></td><td><code>Effect.Random</code></td><td>Type used to create random values</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-now/4.0.0/docs/Effect.Now">purescript-now</a></td><td><code>Effect.Now</code></td><td>Get current Date/Time from machine. (Note: see the <a href="https://pursuit.purescript.org/packages/purescript-datetime/4.0.0">date-time</a> repo for additional related functions)</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-js-timers/4.0.1">purescript-js-timers</a></td><td><code>Effect.Timer</code></td><td>Bindings to low-level JS API: <code>set/clearTimeout</code> and <code>set/clearInterval</code></td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-refs/4.1.0/docs/Effect.Ref">purscript-refs</a></td><td><code>Effect.Ref</code></td><td>Global mutable state</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-st/4.0.0/docs/Control.Monad.ST">purscript-st</a></td><td><code>Control.Monad.ST</code></td><td>Local mutable state</td></tr>
</tbody></table>
<h1><a class="header" href="#effect-eff-and-aff" id="effect-eff-and-aff">Effect, Eff, and Aff</a></h1>
<h2><a class="header" href="#some-history" id="some-history">Some History</a></h2>
<p>Before the <code>0.12.0</code> release, the <code>Effect</code> monad used to be called <code>Eff</code>.</p>
<p>In short, the decision was made to drop <code>Eff</code>'s &quot;extensible effects&quot;. Presumably, to prevent code breakage, <code>Eff</code> and package location in imports was unchanged. Rather, it can now be found in the <a href="https://pursuit.purescript.org/packages/purescript-eff/3.2.1">purescript-eff</a> package. Its replacement was called <code>Effect</code>.</p>
<p>(You can read more about the decision making process <a href="https://purescript-resources.readthedocs.io/en/latest/eff-to-effect.html">here</a>. If one is curious about <code>Eff</code>, read through <a href="https://book.purescript.org/chapter8.html#the-effect-monad-1">the related section</a> in the &quot;Purescript by Example&quot; book as it won't be covered here.)</p>
<h2><a class="header" href="#aff" id="aff">Aff</a></h2>
<p>The <code>Aff</code> monad was introduced and in use before this decision was made. Thus, history explains the naming behind <code>Aff</code>: if <code>Eff</code> was for synchronous <strong>eff</strong>ects, then <code>Aff</code> is for <strong>a</strong>sychronous e<strong>ff</strong>ects.</p>
<p><code>Aff</code> will be covered in more depth in the upcoming files.</p>
<h1><a class="header" href="#aff-1" id="aff-1">Aff</a></h1>
<p>If you're writing an application (as opposed to a library), you should almost always use <code>Aff</code> to run your native side-effectful computations rather than <code>Effect</code>. Here are some of its advantages:</p>
<ul>
<li>prevents &quot;callback hell&quot; for which Node.js is well-known.</li>
<li>enables concurrent programming (but not parallel programming as JavaScript is single-threaded).</li>
<li>is a stack-safe monad (<code>Effect</code> is not currently stack-safe).</li>
</ul>
<p><code>Aff</code> is basically what one would get if one implemented JavaScript Promises as a Monad.</p>
<p><strong>Before continuing one with this folder's contents, watch <a href="https://www.youtube.com/watch?v=dbM72ap30TE">Async Programming in PureScript</a> to learn what problem <code>Aff</code> solves and a tour of its API for how to use it</strong> (actual video on YouTube is titled: &quot;LA PureScript Meetup 12/05/17&quot;).</p>
<p>If, after watching the above video, you are tempted to figure out how <code>Aff</code> works internally, let me strongly recommend against that. The JavaScript code used to implement <code>Aff</code> is difficult to understand. Your time would be better invested elsewhere. Rather, I'd recommend looking at it when you have a better grasp of FP concepts.</p>
<h2><a class="header" href="#folders-contents" id="folders-contents">Folder's Contents</a></h2>
<p>First, we'll overview some of <code>Aff</code>s API via some working examples that one can play with. Since all programs must be run in <code>Effect</code>, this will show the simplest way to start running computations in the <code>Aff</code> monad: <code>launchAff_</code></p>
<p>Second, we'll show <em>one</em> way for making it possible to run an <code>Effect</code>-based computations in an <code>Aff</code> monadic context. (Note: this solution won't work for the <code>ST</code> monadic context in the <code>Effect</code> folder's <code>Local-State.purs</code> example.) Then, we'll show how to fix the issue we experienced in our the <code>Effect</code> folder's <code>Timeout-and-Interval.purs</code> file.</p>
<p>Third, we'll use the <code>Node.ReadLine</code> library to show how to convert <code>Effect</code>-based computations that require callbacks into <code>Aff</code>-based computations via <code>makeAff</code>. We'll also show the more complicated way to run a computation in the <code>Aff</code> monad, but which exposes all of <code>Aff</code>'s features: <code>runAff</code>.</p>
<p>Finally, we'll link to other <code>Aff</code>-based libraries that one will likely find helpful.</p>
<h1><a class="header" href="#aff-basics" id="aff-basics">Aff Basics</a></h1>
<p>This folder shows some of the API of <code>Aff</code>. As stated before, all applications (not libraries) must be started in the <code>Effect</code> monad (or <code>Eff</code> if that's what you're using instead). An <code>Aff</code>-based computation can be converted into an <code>Effect</code>-based on by using <code>launchAff</code>/<code>launchAff_</code>.</p>
<p>So far, we've been printing values to the screen via <code>log</code>. That function's type signature is <code>String -&gt; Effect Unit</code>. Since the &quot;<code>bind</code> outputs the same box-like type it receives&quot; restriction exists, we normally would not be able to use/compute in a different monadic context. For the time being, we will work around that problem by using a special function called <code>specialLog</code>. We'll explain how that's possible in the next folder, <code>Lifting Monads</code>, but for now just read it like you would <code>log</code>.</p>
<p>API not covered here (though it shouldn't be that hard to figure out how it works after reading through these examples and watching Nate's video)</p>
<ul>
<li><code>supervisor</code></li>
<li><code>bracket</code></li>
<li><code>killFiber</code></li>
</ul>
<h1><a class="header" href="#01-launching-affpurs" id="01-launching-affpurs">01-Launching-Aff.purs</a></h1>
<pre><code class="language-haskell">module AffBasics.LaunchAff where

import Prelude

import Effect (Effect)
import Effect.Aff (launchAff, launchAff_)
import Effect.Console (log)
import SpecialLog (specialLog)

main :: Effect Unit
main = do
  log &quot;This is an Effect computation (Effect monadic context).\n&quot;

  void $ launchAff do
    specialLog &quot;This is an Aff computation (Aff monadic context).&quot;

    specialLog &quot;Aff provides the `launchAff` function that enables an \
               \Aff computation to run inside an Effect monadic context.\n&quot;

  launchAff_ do
    specialLog &quot;`launchAff_` is just `void $ launchAff`.\n&quot;

  log &quot;Program finished.&quot;
</code></pre>
<h1><a class="header" href="#02-delaypurs" id="02-delaypurs">02-Delay.purs</a></h1>
<pre><code class="language-haskell">module AffBasics.Delay where

import Prelude

import Effect (Effect)
import Effect.Aff (Milliseconds(..), delay, launchAff_)
import SpecialLog (specialLog)

main :: Effect Unit
main = launchAff_ do
  specialLog &quot;Let's print something to the console and then \
             \wait 1 second before printing another thing.&quot;

  delay $ Milliseconds 1000.0 -- 1 second

  specialLog &quot;1 second has passed.&quot;
  specialLog &quot;Program finished.&quot;
</code></pre>
<h1><a class="header" href="#03-fork-joinpurs" id="03-fork-joinpurs">03-Fork-Join.purs</a></h1>
<pre><code class="language-haskell">module AffBasics.ForkJoin where

import Prelude

import Effect (Effect)
import Effect.Aff (Milliseconds(..), delay, forkAff, joinFiber, launchAff_)
import SpecialLog (specialLog)

main :: Effect Unit
main = launchAff_ do
  let
    fiber1 = &quot;Fiber 1&quot;
    fiber2 = &quot;Fiber 2&quot;
    fiber3 = &quot;Fiber 3&quot;

  specialLog &quot;Let's run multiple computations concurrently. Then, \
             \we'll use `joinFiber` to ensure all computations have \
             \finished before we do another computation.&quot;

  firstFiber &lt;- forkAff do
    specialLog $ fiber1 &lt;&gt; &quot;: Waiting for 1 second until completion.&quot;
    delay $ Milliseconds 1000.0
    specialLog $ fiber1 &lt;&gt; &quot;: Finished computation.&quot;

  secondFiber &lt;- forkAff do
    specialLog $ fiber2 &lt;&gt; &quot;: Computation 1 (takes 300 ms).&quot;
    delay $ Milliseconds 300.0

    specialLog $ fiber2 &lt;&gt; &quot;: Computation 2 (takes 300 ms).&quot;
    delay $ Milliseconds 300.0

    specialLog $ fiber2 &lt;&gt; &quot;: Computation 3 (takes 500 ms).&quot;
    delay $ Milliseconds 500.0
    specialLog $ fiber2 &lt;&gt; &quot;: Finished computation.&quot;

  thirdFiber &lt;- forkAff do
    specialLog $ fiber3 &lt;&gt; &quot;: Nothing to do. Just return immediately.&quot;
    specialLog $ fiber3 &lt;&gt; &quot;: Finished computation.&quot;

  joinFiber firstFiber
  specialLog $ fiber1 &lt;&gt; &quot; has finished. Now joining on &quot; &lt;&gt; fiber2

  joinFiber secondFiber
  specialLog $ fiber3 &lt;&gt; &quot; has finished. Now joining on &quot; &lt;&gt; fiber3

  joinFiber thirdFiber
  specialLog $ fiber3 &lt;&gt; &quot; has finished. All fibers have finished their \
                         \computation.&quot;

  specialLog &quot;Program finished.&quot;
</code></pre>
<h1><a class="header" href="#04-suspend-joinpurs" id="04-suspend-joinpurs">04-Suspend-Join.purs</a></h1>
<pre><code class="language-haskell">module AffBasics.SuspendJoin where

import Prelude

import Effect (Effect)
import Effect.Aff (Milliseconds(..), delay, joinFiber, launchAff_, suspendAff)
import SpecialLog (specialLog)

main :: Effect Unit
main = launchAff_ do
  let
    fiber1 = &quot;Fiber 1&quot;
    fiber2 = &quot;Fiber 2&quot;
    fiber3 = &quot;Fiber 3&quot;

  specialLog &quot;Let's setup multiple computations. Then, we'll use \
             \`joinFiber` to actually run the computations for the first time. \
             \When they run, they will block until finished.\n&quot;

  specialLog &quot;Setting up the first fiber, but not yet running its computation.&quot;
  firstFiber &lt;- suspendAff do
    specialLog $ fiber1 &lt;&gt; &quot;: Waiting for 1 second until completion.&quot;
    delay $ Milliseconds 1000.0
    specialLog $ fiber1 &lt;&gt; &quot;: Finished computation.&quot;

  specialLog &quot;Setting up the second fiber, but not yet running its computation.&quot;
  secondFiber &lt;- suspendAff do
    specialLog $ fiber2 &lt;&gt; &quot;: Computation 1 (takes 300 ms).&quot;
    delay $ Milliseconds 300.0

    specialLog $ fiber2 &lt;&gt; &quot;: Computation 2 (takes 300 ms).&quot;
    delay $ Milliseconds 300.0

    specialLog $ fiber2 &lt;&gt; &quot;: Computation 3 (takes 500 ms).&quot;
    delay $ Milliseconds 500.0
    specialLog $ fiber2 &lt;&gt; &quot;: Finished computation.&quot;

  specialLog &quot;Setting up the third fiber, but not yet running its computation.&quot;
  thirdFiber &lt;- suspendAff do
    specialLog $ fiber3 &lt;&gt; &quot;: Nothing to do. Just return immediately.&quot;
    specialLog $ fiber3 &lt;&gt; &quot;: Finished computation.&quot;

  delay $ Milliseconds 1000.0

  specialLog &quot;Now running the first fiber's computation and blocking \
             \until it finishes.&quot;
  joinFiber firstFiber

  specialLog &quot;Now running the second fiber's computation and blocking \
             \until it finishes.&quot;
  joinFiber secondFiber

  specialLog &quot;Now running the third fiber's computation and blocking \
             \until it finishes.&quot;
  joinFiber thirdFiber

  specialLog $ &quot;All fibers have finished their computation.&quot;

  specialLog &quot;Program finished.&quot;
</code></pre>
<h1><a class="header" href="#05-cached-joinpurs" id="05-cached-joinpurs">05-Cached-Join.purs</a></h1>
<pre><code class="language-haskell">module AffBasics.CachedJoin where

import Prelude

import Effect (Effect)
import Effect.Aff (Milliseconds(..), delay, forkAff, joinFiber, launchAff_, suspendAff)
import SpecialLog (specialLog)

main :: Effect Unit
main = launchAff_ do
  let
    fiber1 = &quot;Fiber 1&quot;
    fiber2 = &quot;Fiber 2&quot;

  specialLog &quot;Let's compute multiple computations. Then, we'll refer to the \
             \value they produced multiple times to see that the result is \
             \cached.\n&quot;

  firstFiber &lt;- forkAff do
    specialLog $ fiber1 &lt;&gt; &quot;: You will only see this message once!&quot;
    delay $ Milliseconds 1000.0
    pure 10

  secondFiber &lt;- suspendAff do
    specialLog $ fiber2 &lt;&gt; &quot;: You will only see this message once!&quot;
    delay $ Milliseconds 1000.0
    pure 50

  result1 &lt;- joinFiber firstFiber
  result2 &lt;- joinFiber secondFiber

  specialLog &quot;Finished joining fibers. After small pause, will join again \
             \to see whether their computations are rerun.&quot;
  delay $ Milliseconds 2000.0

  specialLog &quot;Rejoining fibers!&quot;
  result1_again &lt;- joinFiber firstFiber
  result2_again &lt;- joinFiber secondFiber
  specialLog &quot;Finished joining fibers again.&quot;

  specialLog $ &quot;Result 1 is the same? &quot; &lt;&gt; show (result1 == result1_again)
  specialLog $ &quot;Result 2 is the same? &quot; &lt;&gt; show (result2 == result2_again)

  specialLog &quot;Program finished.&quot;
</code></pre>
<h1><a class="header" href="#06-switching-contextspurs" id="06-switching-contextspurs">06-Switching-Contexts.purs</a></h1>
<pre><code class="language-haskell">module AffBasics.SwitchingContexts where

import Prelude

import Effect (Effect)
import Effect.Aff (Milliseconds(..), delay, joinFiber, launchAff, launchAff_, launchSuspendedAff)
import Effect.Console (log)
import SpecialLog (specialLog)

-- This example was created to show what happens when `launchSuspendedAff`
-- is used and its requirement to be run in another Aff computation later.
--
-- It also shows the unpredictability of switching
-- between the synchronous Effect and asychronous Aff in this way.
main :: Effect Unit
main = do
  let
    fiber1 = &quot;Fiber 1&quot;
    fiber2 = &quot;Fiber 2&quot;

  log &quot;This is an Effect computation (Effect monadic context).\n&quot;

  -- Runs an Aff computation and returns the fiber that, when joined,
  -- will produce the computed value. It must be joined in a new
  -- `Aff` computation.
  firstFiber &lt;- launchAff do
    specialLog $ fiber1 &lt;&gt; &quot;: You will only see this message once!&quot;
    delay $ Milliseconds 1000.0
    pure 10

  -- Creates an Aff computation, but does not run it. Rather, returns
  -- the fiber that, when joined, will start and finish the computation,
  -- returning the computed value when done. It must be joined in a new
  -- `Aff` computation.
  secondFiber &lt;- launchSuspendedAff do
    specialLog $ fiber2 &lt;&gt; &quot;: You will only see this message once!&quot;
    delay $ Milliseconds 1000.0
    pure 50

  log &quot;\nJust some other stuff we need to do in the Effect monadic context...\n&quot;

  launchAff_ do
    specialLog &quot;Back inside an Aff monadic context. Let's see what those \
               \fibers did!\n&quot;

    result1 &lt;- joinFiber firstFiber
    result2 &lt;- joinFiber secondFiber

    specialLog &quot;Finished joining fibers. After small pause, will join again \
               \to see whether their computations are rerun.&quot;
    delay $ Milliseconds 2000.0

    specialLog &quot;Rejoining fibers!&quot;
    result1_again &lt;- joinFiber firstFiber
    result2_again &lt;- joinFiber secondFiber
    specialLog &quot;Finished joining fibers again.&quot;

    specialLog $ &quot;Result 1 is the same? &quot; &lt;&gt; show (result1 == result1_again)
    specialLog $ &quot;Result 2 is the same? &quot; &lt;&gt; show (result2 == result2_again)

  log &quot;Back outside. Now in the Effect monadic context.&quot;
  log &quot;=======================\n\
      \The end of our code, but not the end of our program.\n\
      \=======================\n&quot;
</code></pre>
<h1><a class="header" href="#monadeffect" id="monadeffect">MonadEffect</a></h1>
<p>In the previous folder, we saw that we could print content to the console using <code>specialLog</code>. Underneath, we're using <code>log</code>, the function with the type, <code>String -&gt; Effect Unit</code>. Since &quot;<code>bind</code> outputs the same box-like type it receives,&quot; how was this possible?</p>
<p>In this file, we'll show one way to workaround this limitation. This solution will be used frequently in real code wherever the <code>Effect</code> monad is used. However, <em>this solution doesn't necessarily work for other monads</em>. Still, it is conceptually easy to understand and creates scaffolding. That scaffolding will make it easier to understand other workarounds to this restriction that we'll discuss in the <code>Application Structure</code> folder.</p>
<h2><a class="header" href="#reviewing-a-previous-workaround-lifting-one-monad-into-another" id="reviewing-a-previous-workaround-lifting-one-monad-into-another">Reviewing a Previous Workaround: Lifting one Monad into another</a></h2>
<p>When overviewing the &quot;&quot;<code>bind</code> outputs the same box-like type it receives&quot; restriction, we described the previous workaround:</p>
<pre><code class="language-haskell">import Prelude -- for the (+) and (~&gt;) function aliases

data Box1 a = Box1 a
data Box2 a = Box2 a

class LiftSourceIntoTargetMonad sourceMonad targetMonad where                 {-
  liftSourceMonad :: forall a. sourceMonad a -&gt; targetMonad a                 -}
  liftSourceMonad ::           sourceMonad   ~&gt; targetMonad

instance LiftSourceIntoTargetMonad Box2 Box1 where
  liftSourceMonad :: Box2 ~&gt; Box1
  liftSourceMonad (Box2 a) = Box1 a

bindAttempt :: Box1 Int
bindAttempt = do
  four &lt;- Box1 4
  six &lt;- liftSourceMonad $ Box2 6
  pure $ four + six

-- type class instances for Monad hierarchy

instance Functor Box1 where
  map :: forall a b. (a -&gt; b) -&gt; Box1 a -&gt; Box1  b
  map f (Box1 a) = Box1 (f a)

instance Apply Box1 where
  apply :: forall a b. Box1 (a -&gt; b) -&gt; Box1 a -&gt; Box1  b
  apply (Box1 f) (Box1 a) = Box1 (f a)

instance Bind Box1 where
  bind :: forall a b. Box1 a -&gt; (a -&gt; Box1 b) -&gt; Box1 b
  bind (Box1 a) f = f a

instance Applicative Box1 where
  pure :: forall a. a -&gt; Box1 a
  pure a =  Box1 a

instance Monad Box1

-- Needed to print the result to the console in the REPL session

instance (Show a) =&gt; Show (Box1 a) where
  show (Box1 a) = show a
</code></pre>
<h2><a class="header" href="#monadeffect-1" id="monadeffect-1">MonadEffect</a></h2>
<p>When we have an <code>Effect</code>-based computation that we want to run in some other monadic context, we can use <code>liftEffect</code> from <a href="https://pursuit.purescript.org/packages/purescript-effect/2.0.0/docs/Effect.Class#v:liftEffect">MonadEffect</a> <strong>if the target monad has an instance for <code>MonadEffect</code></strong>:</p>
<pre><code class="language-haskell">class (Monad m) &lt;= MonadEffect m where
  liftEffect :: Effect ~&gt; m
</code></pre>
<p><code>Aff</code> has an instance for <code>MonadEffect</code>, so we can lift <code>Effect</code>-based computations into an <code>Aff</code> monadic context. Below was how we defined <code>specialLog</code>. You can see it in the next file:</p>
<pre><code class="language-haskell">specialLog :: String -&gt; Aff Unit
specialLog message = liftEffect $ log message
</code></pre>
<p>Referring back to our previous &quot;local state&quot; example, the <code>ST</code> monad does not have an instance for <code>MonadEffect</code>. This decision is intentional: state manipulation of that kind should be pure and not have any side-effects. That's why it exists inside of its own monadic context: to ensure that those who attempt to do so get compiler errors. This is a safety precaution, not a &quot;we wanted to be jerks who frustrate you&quot; decision.</p>
<p>As we saw previously in the <code>Switching-Context.purs</code> file, running multiple <code>Aff</code> computations in an <code>Effect</code> monadic context doesn't always lead to a predictable output. However, running multiple <code>Effect</code>-based computations in an <code>Aff</code> monadic context is much more predictable.</p>
<h1><a class="header" href="#02-speciallogpurs" id="02-speciallogpurs">02-SpecialLog.purs</a></h1>
<pre><code class="language-haskell">module SpecialLog (specialLog) where

import Prelude

import Effect.Aff (Aff)
import Effect.Class (liftEffect)
import Effect.Console (log)

specialLog :: String -&gt; Aff Unit
specialLog msg = liftEffect $ log msg
</code></pre>
<h1><a class="header" href="#03-timeout-and-intervalpurs-1" id="03-timeout-and-intervalpurs-1">03-Timeout-and-Interval.purs</a></h1>
<pre><code class="language-haskell">module TimeoutAndInterval.Aff where

import Prelude

import Effect (Effect)
import Effect.Aff (Milliseconds(..), delay, launchAff_)
import Effect.Class (liftEffect)
import Effect.Console (log)
import Effect.Timer as T

main :: Effect Unit
main = launchAff_ do
  timeoutID &lt;- liftEffect $ T.setTimeout 1000 (log &quot;This will run after 1 second&quot;)
  intervalID &lt;- liftEffect $ T.setInterval 10 (log &quot;Interval ran!&quot;)

  liftEffect do
    -- Since these three log calls use `bind` to sequence them into
    -- a single `Effect Unit` computation, we can reduce verbosity
    -- by lifting all of them using one `liftEffect`.
    log &quot;Doing some other things....&quot;
    log (evaluate 10 20)
    log &quot;... Finished.&quot;

  liftEffect do
    log &quot;Now cancelling interval&quot;
    T.clearInterval intervalID

  -- Here, we'll delay the computation long enough to ensure the
  -- above timeout callback actually runs.
  delay (Milliseconds 1300.0)
  liftEffect do
    log &quot;Now cancelling timeout&quot;
    T.clearTimeout timeoutID

    log &quot;Program is done!&quot;

evaluate :: Int -&gt; Int -&gt; String
evaluate x y | x &lt; y = show x &lt;&gt; &quot; is less than &quot; &lt;&gt; show y
             | x &gt; y = show x &lt;&gt; &quot; is greater than &quot; &lt;&gt; show y
             | otherwise = show x &lt;&gt; &quot; is equal to &quot; &lt;&gt; show y
</code></pre>
<h1><a class="header" href="#node-readline-api" id="node-readline-api">Node ReadLine API</a></h1>
<p>Node's ReadLine API docs are <a href="https://nodejs.org/api/readline.html">here</a>. In this folder, we'll use the following Purescript bindings of the API (The Pursuit docs are outdated as they only show docs for an earlier release. So, either run <code>spago docs</code> and look at the <code>Node.ReadLine</code> module's docs, or look at the <a href="https://github.com/purescript-node/purescript-node-readline/blob/master/src/Node/ReadLine.purs">source code</a> to see all of what is supported.</p>
<p>Below, I cover some of the API (some of the functions below had their 'foreign import' part removed to shorten the type signature):</p>
<pre><code class="language-haskell">-- Copyright is at the end of this file
foreign import data Interface :: Type

-- | A function which performs tab completion.
type Completer
  = String
  -&gt; Effect
      { completions :: Array String
      , matched :: String
      }

-- | A completion function which offers no completions.
noCompletion :: Completer
noCompletion s = -- implementation

-- | Create an interface with the specified completion function.
createConsoleInterface :: Completer -&gt; Effect Interface
createConsoleInterface compl = -- implementation

-- | Writes a message to the output and adds a listener to the
-- | interface that invokes the callback function when an
-- | event occurs (i.e. user inputs some text and presses Enter).
question :: String -&gt; (String -&gt; Effect Unit) -&gt; Interface -&gt; Effect Unit
question message handleUserInput interface = -- implementation

-- | Closes the specified `Interface` and cleans up resources.
close :: Interface -&gt; Effect Unit
close interface = -- implementation
</code></pre>
<hr>
<p>Copyright for above code:</p>
<pre><code>The MIT License (MIT)

Copyright (c) 2014 PureScript

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the &quot;Software&quot;), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>
<h1><a class="header" href="#02-readline-effectpurs" id="02-readline-effectpurs">02-ReadLine-Effect.purs</a></h1>
<pre><code class="language-haskell">module ConsoleLessons.ReadLine.Effect where

import Prelude
import Effect (Effect)
import Effect.Console (log)

{-
This file will demonstrate why using `Effect` to work with `Node.ReadLine`
creates the Pyramid of Doom.

Look through the code and then use the command in the folder's
ReadMe.md file to run it using Node (not Spago) to see what happens.
-}

-- new imports
import Node.ReadLine ( createConsoleInterface, noCompletion
                     , question, close)


type UseAnswer = (String -&gt; Effect Unit)

main :: Effect Unit
main = do
  log &quot;\n\n&quot; -- separate output from program output

  log &quot;Creating interface...&quot;
  interface &lt;- createConsoleInterface noCompletion
  log &quot;Created!\n&quot;

  log &quot;Requesting user input...&quot;
  interface # question &quot;Type something here (1): &quot; \answer1 -&gt; do
    log $ &quot;You typed: '&quot; &lt;&gt; answer1 &lt;&gt; &quot;'\n&quot;
    interface # question &quot;Type something here (2): &quot; \answer2 -&gt; do
      log $ &quot;You typed: '&quot; &lt;&gt; answer2 &lt;&gt; &quot;'\n&quot;
      interface # question &quot;Type something here (3): &quot; \answer3 -&gt; do
        log $ &quot;You typed: '&quot; &lt;&gt; answer3 &lt;&gt; &quot;'\n&quot;
        interface # question &quot;Type something here (4): &quot; \answer4 -&gt; do
          log $ &quot;You typed: '&quot; &lt;&gt; answer4 &lt;&gt; &quot;'\n&quot;
          interface # question &quot;Type something here (5): &quot; \answer5 -&gt; do
            log $ &quot;You typed: '&quot; &lt;&gt; answer5 &lt;&gt; &quot;'\n&quot;

            log &quot;Now closing interface&quot;
            close interface
            log &quot;Finished!&quot;

          log &quot;This will print as we wait for your 5th answer.&quot;
        log &quot;This will print as we wait for your 4th answer.&quot;
      log &quot;This will print as we wait for your 3rd answer.&quot;
    log &quot;This will print as we wait for your 2nd answer.&quot;
  log &quot;This will print as we wait for your 1st answer.&quot;
</code></pre>
<h1><a class="header" href="#basic-aff-functions" id="basic-aff-functions">Basic Aff Functions</a></h1>
<p>In this file, we'll show the second way to run an <code>Aff</code> computation called <code>runAff</code> and how to convert <code>Node.ReadLine</code>'s <code>question</code> function (i.e. an <code>Effect</code>-based function that requires a callback) into an <code>Aff</code>-based computation using <code>makeAff</code>.</p>
<h2><a class="header" href="#aff-overview" id="aff-overview">Aff Overview</a></h2>
<p>Let's first overview some of <code>Aff</code>'s concepts, so that the upcoming code is easier to understand. To be a truly asynchronous effect monad, <code>Aff</code> must support the following features:</p>
<ul>
<li>handles errors that may arise during its computation</li>
<li>returns some computation's output</li>
<li>can be cancelled if it's no longer needed</li>
</ul>
<p>To model the possibility for a computation to return an error or actual output, we can use <code>Either a b</code>. Handling errors and output implies a function. <code>Aff</code> uses the type signature, <code>Either errorType outputType -&gt; Effect Unit</code>, for that.</p>
<p>Lastly, cancelling implies what to do when the computation is either no longer needed or it has failed (but we aren't using the function just discussed above). As an example, one will use <code>Canceler</code>s to clean up resources (e.g. <code>clearTimeout</code>).</p>
<pre><code class="language-haskell">newtype Canceler = Canceler (Error -&gt; Aff Unit)
</code></pre>
<p>Since our present interests do not require cancellation, we can use a no-op <code>Canceler</code>: <code>nonCanceler</code></p>
<h2><a class="header" href="#understanding-runaff" id="understanding-runaff">Understanding <code>runAff</code></a></h2>
<p>For our purposes, we need an <code>Aff</code> to run inside of an <code>Effect</code> monadic context. If one looks through <code>Aff</code>'s docs, the only one that does this besides <code>launchAff</code> and its variants is <code>runAff_</code>:</p>
<pre><code class="language-haskell">runAff_ :: forall a.
           (Either Error a -&gt; Effect Unit) -&gt;  -- arg 1
           Aff a -&gt;                            -- arg 2
           Effect Unit                         -- outputted value
</code></pre>
<p>Breaking this down, <code>runAff_</code> takes two arguments (explained in reverse):</p>
<ul>
<li>an <code>Aff</code> computation to run</li>
<li>a function for handling a possible asynchronous <code>Error</code> if the computation fails or the computation's output, <code>a</code>, if it succeeds.</li>
</ul>
<p>Using it should look something like:</p>
<pre><code class="language-haskell">runAff_ (\either -&gt; case either of
    Left error -&gt; log $ show error
    Right a -&gt; -- do something with 'a' or run cleanup code
  )
  affValue
</code></pre>
<p>We could make the code somewhat easier by using <code>Data.Either (either)</code></p>
<pre><code class="language-haskell">runAff_ (either
          (\error -&gt; log $ show error   ) -- Left value
          (\a -&gt; {- usage or cleanup -} ) -- Right value
  )
  affValue
</code></pre>
<h2><a class="header" href="#understanding-makeaff" id="understanding-makeaff">Understanding <code>makeAff</code></a></h2>
<p>Next, we need to convert <code>question</code> from an <code>Effect</code>-based computation into an <code>Aff</code>-based one. Looking through Pursuit again, <code>makeAff</code> is the only function that does this:</p>
<pre><code class="language-haskell">makeAff :: forall a. ((Either Error a -&gt; Effect Unit) -&gt; Effect Canceler) -&gt; Aff a
</code></pre>
<p>Breaking this down, <code>makeAff</code> takes only one argument. However, the argument is a bit quirky since it takes a function as its argument. We should read it as...</p>
<pre><code>  Given a function
    that returns an `Effect Canceler`
    by using the function that `runAff_` requires
      (i.e. `(Either Error a -&gt; Effect Unit)`),
output an `Aff` computation that produces a value of type `a` when `bind`ed
</code></pre>
<p>To create this type signature, we'll write something like this:</p>
<pre><code class="language-haskell">affValue :: Aff String
affValue = makeAff go
  where
  go :: (Either Error a -&gt; Effect Unit) -&gt; Effect Canceler
  go runAff_RequiredFunction = -- implementation
</code></pre>
<p>Since the implementation will need to return an <code>Effect Canceler</code>, we can do one of two things:</p>
<ol>
<li>Lift a canceller into <code>Effect</code> via <code>pure</code>. This is pointless because then our <code>Aff</code> wouldn't do anything.</li>
<li>Create an <code>Effect a</code> and use Functor's dervied function, <code>voidRight</code> (<code>&lt;$</code>), with <code>nonCanceler</code></li>
</ol>
<pre><code class="language-haskell">-- for a refresher on voidRight
2 `voidRight` (Box 1) == 2 &lt;$ (Box 1) == (Box 2)

-- alias is: &quot;&lt;$&quot;
voidRight :: forall f a b. Functor f =&gt; b -&gt; f a -&gt; f b
voidRight b box = (\_ -&gt; b) &lt;$&gt; box

-- or ignore the monad's inner 'a' and replace it with 'b'
</code></pre>
<p>Updating our code to use these two ideas, we now have:</p>
<pre><code class="language-haskell">affValue :: Aff String
affValue = makeAff go
  where
  go :: (Either Error a -&gt; Effect Unit) -&gt; Effect Canceler
  go runAff_RequiredFunction = nonCanceler &lt;$ (effectBox runAff_RequiredFunction)

  effectBox :: (Either Error a -&gt; Effect Unit) -&gt; Effect Unit
  effectBox runAffFunction = -- implementation
</code></pre>
<p>We want to use <code>question</code> to print something to the console, get the user's input, and return that value. It's type signature is:</p>
<pre><code class="language-haskell">question :: String -&gt; (String -&gt; Effect Unit) -&gt; Interface -&gt; Effect String
question message handleUserInput interface = -- Node binding implementation
</code></pre>
<p>The only place we could insert <code>runAffFunction</code> is in <code>(String -&gt; Effect Unit)</code>. Thus, we come up with this function:</p>
<pre><code class="language-haskell">effectBox :: (Either Error String -&gt; Effect Unit) -&gt; Effect Unit
effectBox runAffFunction =
  question message (\userInput -&gt; runAffFunction (Right userInput)) interface
                              -- (runAffFunction &lt;&lt;&lt; Right) -- less verbose; same thing
</code></pre>
<p>Putting it all together and excluding the required arguments, we get:</p>
<pre><code class="language-haskell">affValue :: Aff String
affValue = makeAff go
  where
  go :: (Either Error a -&gt; Effect Unit) -&gt; Effect Canceler
  go runAff_RequiredFunction = nonCanceler &lt;$ (effectBox runAff_RequiredFunction)

  effectBox :: (Either Error a -&gt; Effect Unit) -&gt; Effect Unit
  effectBox runAffFunction = question message (runAffFunction &lt;&lt;&lt; Right) interface
</code></pre>
<p>Cleaning it up and including the arguments, we get:</p>
<pre><code class="language-haskell">affQuestion :: String -&gt; Interface -&gt; Aff String
affQuestion message interface = makeAff go
  where
  go :: (Either Error a -&gt; Effect Unit) -&gt; Effect Canceler
  go runAffFunction =
    nonCanceler &lt;$ question message (runAffFunction &lt;&lt;&lt; Right) interface
</code></pre>
<h1><a class="header" href="#04-readline-affpurs" id="04-readline-affpurs">04-ReadLine-Aff.purs</a></h1>
<pre><code class="language-haskell">module ConsoleLessons.ReadLine.Aff where

import Prelude

import Data.Either (Either(..))
import Effect (Effect)
import Effect.Aff (Aff, runAff_, makeAff, nonCanceler)
import Effect.Class (liftEffect)
import Effect.Console (log)
import Node.ReadLine (Interface, createConsoleInterface, noCompletion, close)
import Node.ReadLine as ReadLine

-- This is `affQuestion` from the previous file
question :: String -&gt; Interface -&gt; Aff String
question message interface = makeAff go
  where
    -- go :: (Either Error a -&gt; Effect Unit) -&gt; Effect Canceler
    go runAffFunction = nonCanceler &lt;$
      ReadLine.question message (runAffFunction &lt;&lt;&lt; Right) interface

main :: Effect Unit
main = do
  log &quot;\n\n&quot; -- separate output from program

  log &quot;Creating interface...&quot;
  interface &lt;- createConsoleInterface noCompletion
  log &quot;Created!\n&quot;
                                                                               {-
  runAff_ :: forall a. (Either Error a -&gt; Effect Unit) -&gt; Aff a -&gt; Effect Unit -}
  runAff_
    -- Ignore any errors and output and just close the interface
    (\_ -&gt; closeInterface interface)
    (useInterface interface)
  where
    closeInterface :: Interface -&gt; Effect Unit
    closeInterface interface = do
      log &quot;Now closing interface&quot;
      close interface
      log &quot;Finished!&quot;

    -- Same code as before, but without the Pyramid of Doom!
    useInterface :: Interface -&gt; Aff Unit
    useInterface interface = do
      liftEffect $ log &quot;Requesting user input...&quot;

      answer1 &lt;- interface # question &quot;Type something here (1): &quot;
      liftEffect $ log $ &quot;You typed: '&quot; &lt;&gt; answer1 &lt;&gt; &quot;'\n&quot;

      answer2 &lt;- interface # question &quot;Type something here (2): &quot;
      liftEffect $ log $ &quot;You typed: '&quot; &lt;&gt; answer2 &lt;&gt; &quot;'\n&quot;

      answer3 &lt;- interface # question &quot;Type something here (3): &quot;
      liftEffect $ log $ &quot;You typed: '&quot; &lt;&gt; answer3 &lt;&gt; &quot;'\n&quot;

      answer4 &lt;- interface # question &quot;Type something here (4): &quot;
      liftEffect $ log $ &quot;You typed: '&quot; &lt;&gt; answer4 &lt;&gt; &quot;'\n&quot;

      answer5 &lt;- interface # question &quot;Type something here (5): &quot;
      liftEffect $ log $ &quot;You typed: '&quot; &lt;&gt; answer5 &lt;&gt; &quot;'\n&quot;
</code></pre>
<h1><a class="header" href="#useful-aff-libraries" id="useful-aff-libraries">Useful Aff Libraries</a></h1>
<h2><a class="header" href="#based-on-aff" id="based-on-aff">Based on Aff</a></h2>
<p>These were found using a <a href="https://pursuit.purescript.org/search?q=purescript-aff-">purescript-aff-</a> search on Pursuit:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-aff-bus/4.0.0"><code>purescript-aff-bus</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-aff-retry/1.2.1"><code>purescript-aff-retry</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-aff-promise/2.0.1"><code>purescript-aff-promise</code></a>
<ul>
<li>This library makes JavaScript Promises properly work/communicate together with PureScript Aff computations and vice versa.</li>
</ul>
</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-aff-parallel/0.1.1"><code>purescript-aff-parallel</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-aff-reattempt/5.0.0"><code>purescript-aff-reattempt</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-aff-throttler/0.0.2"><code>purescript-aff-throttler</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-aff-coroutines/7.0.0"><code>purescript-aff-coroutines</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-affjax/9.0.0"><code>purescript-affjax</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-avar/3.0.0"><code>purescript-avar</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-concurrent-queues/1.1.0"><code>purescript-concurrent-queues</code></a></li>
</ul>
<h2><a class="header" href="#aff-wrappers-around-node" id="aff-wrappers-around-node">Aff Wrappers Around Node</a></h2>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-node-fs-aff/6.0.0">purescript-node-fs-aff</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-node-readline-aff/0.1.2">purescript-node-readline-aff</a> (outdated: does not compile on <code>PureScript 0.13.8</code>)</li>
</ul>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p>This folder helps you debug problems in your code by</p>
<ul>
<li>explaining some tips/tricks to use to help debug compiler errors</li>
<li>forewarning about some potential misunderstandings</li>
<li>helping you to read some compiler errors</li>
</ul>
<h2><a class="header" href="#running-the-lessons" id="running-the-lessons">Running The Lessons</a></h2>
<p>You should <strong>NOT</strong> use the REPL for these lessons.</p>
<p>Rather, you should use spago to run them using this syntax:</p>
<pre><code class="language-bash">spago run --main Debugging.OverviewAPI
</code></pre>
<p>When compiling these examples, you will likely see a warning like below:</p>
<pre><code>Warning found:
in module Debugging.CustomTypeErrors.TypeClassInstances
at src/03-Custom-Type-Errors/04-Type-Class-Instances.purs line 41, column 1 - line 41, column 23

  A custom warning occurred while solving type class constraints:

    No worries! This warning is supposed to happen!

    [Some warning message here...]


in value declaration warnInstance

See https://github.com/purescript/documentation/blob/master/errors/UserDefinedWarning.md for more information,
or to contribute content related to this warning.
</code></pre>
<p>This is supposed to happen, so don't be alarmed. When we hit that part of our lessons, we'll tell you how to remove the warnings so you can get rid of the &quot;compiler noise.&quot;</p>
<h1><a class="header" href="#general-debugging" id="general-debugging">General Debugging</a></h1>
<p>The following sections are tips for debugging issues that may arise in a strongly-typed language via the compiler.</p>
<h2><a class="header" href="#there-is-currently-no-actual-type--expected-type-distinction" id="there-is-currently-no-actual-type--expected-type-distinction">There is currently no &quot;Actual Type / Expected Type&quot; distinction</a></h2>
<p>In the following error...</p>
<pre><code>  Could not match type

    A

  with type

    B

  ... rest of error ...
</code></pre>
<p>... one might expect <code>A</code> to be the &quot;actual&quot; type and <code>B</code> to be the &quot;expected&quot; type. However, sometimes the two are swapped, so that <code>A</code> is the &quot;expected&quot; type and <code>B</code> is the &quot;actual&quot; type. This is not desirable, but is currently how the compiler works.</p>
<p>Why? Because <a href="https://github.com/purescript/purescript/issues/3111#issuecomment-335596641">the compiler uses a mixture of unification and type inference to check types</a>. See <a href="https://github.com/purescript/purescript/issues/3399">purescript/purescript#3399</a> for more information.</p>
<h2><a class="header" href="#distinguishing-the-difference-between--and--errors" id="distinguishing-the-difference-between--and--errors">Distinguishing the Difference between <code>{...}</code> and <code>(...)</code> errors</a></h2>
<p>(thomashoneyman recommended I document this. These examples might be incorrect since I am not fully aware of the comment that garyb made, but the general idea still applies.)</p>
<p>Recall that <code>{ label :: Type }</code> is syntax sugar for <code>Record (label :: Type)</code></p>
<p>So, the below error means a <code>Record</code> could not unify with some other type:</p>
<pre><code>  Could not match type
    { label :: Type }
  with type
    String
</code></pre>
<p>Whereas the below error means a <code>Record</code> was the correct type, but some of its label-type associations were missing.</p>
<pre><code>  Could not match type
    Record (label :: Type)
  with type
    Record (label :: Type, forgottenLabel :: OtherType)
</code></pre>
<h2><a class="header" href="#type-directed-search" id="type-directed-search">Type Directed Search</a></h2>
<p>Otherwise known as &quot;typed holes.&quot;</p>
<p>If you recall in <code>Syntax/Basic Syntax/src/Data-and-Functions/Type-Directed-Search.md</code>, we can use type-directed search to</p>
<ol>
<li>help us determine what an entity's type is</li>
<li>guide us in how to implement something</li>
<li>see better ways to code something via type classes</li>
</ol>
<p>As an example, let's say we have a really complicated function or type</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  a &lt;- computeA
  b &lt;- computeB
  c &lt;- (\a -&gt; (\c -&gt; doX c) &lt;$&gt; box a) &lt;$&gt; (Box 5) &lt;*&gt; (Box 8)
</code></pre>
<p>If we want to know what the type will be for <code>doX</code>, we can rewrite that entity using a type direction search, <code>?doX</code>, and see what the compiler outputs:</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  a &lt;- computeA
  b &lt;- computeB
  c &lt;- (\a -&gt; (\c -&gt; ?doX c) &lt;$&gt; box a) &lt;$&gt; (Box 5) &lt;*&gt; (Box 8)
</code></pre>
<p>If we're not sure what type a function outputs, we can precede the function with our search using <code>?name $ function</code>:</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  a &lt;- computeA
  b &lt;- computeB
  c &lt;- (\a -&gt; (\c -&gt; ?help $ doX c) &lt;$&gt; box a) &lt;$&gt; (Box 5) &lt;*&gt; (Box 8)
</code></pre>
<p>If you encounter a problem or need help, this should be one of the first things you use.</p>
<h2><a class="header" href="#getting-the-type-of-an-expression-from-the-compiler" id="getting-the-type-of-an-expression-from-the-compiler">Getting the Type of an Expression from the Compiler</a></h2>
<p>This is known as &quot;typed wildcards&quot;.</p>
<p>In a function body, wrapping some term with <code>(term :: _)</code> will cause the compiler to infer the type for you.</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  a &lt;- computeA
  b &lt;- computeB
  c &lt;- (\w x -&gt; ((doX x) :: _)) &lt;$&gt; box a) &lt;$&gt; (Box 5) &lt;*&gt; (Box 8)
</code></pre>
<h2><a class="header" href="#getting-the-type-of-a-function-from-the-compiler" id="getting-the-type-of-a-function-from-the-compiler">Getting the Type of a Function from the Compiler</a></h2>
<p>There are two possible situations where this idea might help:</p>
<ul>
<li>You know how to write the body for a function but aren't sure what it's type signature is</li>
<li>You're exploring a new unfamiliar library and are still figuring out how to piece things together. So, you attempt to write the body of a function but aren't sure what it's type signature will be.</li>
</ul>
<p>In such cases, we can completely omit the type signature and the compiler will usually infer what it is for us:</p>
<pre><code class="language-haskell">-- no type signature here for `f`,
-- so the compiler will output a warning
-- stating what its inferred type is
f = (\a -&gt; (\c -&gt; doX c) &lt;$&gt; box a) &lt;$&gt; (Box 5) &lt;*&gt; (Box 8)
</code></pre>
<p>However, the above is not always useful when one only wants to know what the type of either an argument or the return type. In such situations, one can use typed wildcards from above in the type signature:</p>
<pre><code class="language-haskell">doesX :: String -&gt; _ -&gt; Int
doesX str anotherString = length (concat str anotherString)
</code></pre>
<h2><a class="header" href="#determining-why-a-type-was-inferred-incorrectly" id="determining-why-a-type-was-inferred-incorrectly">Determining why a type was inferred incorrectly</a></h2>
<p>Sometimes, I wish we could have a 'unification trace' or a 'type inference trace'. I know the code I wrote works, but there's some mistake somewhere in my code that's making the compiler infer the wrong type at point X, which then produces the type inference problem much later at point Y. To solve Y, I need to fix the problem X, but I'm not sure where X is.</p>
<p>Here's an example:</p>
<pre><code class="language-haskell">type Rec = { a :: String }

f :: String -&gt; String
f theString = wrap (unwrap theString)

  where
    wrap :: String -&gt; Rec
    wrap theString = { a: theString }

    {-
      the mistake! Compiler says
      Cannot match type
        { a :: String }
      with type
        { a :: String, b :: String }
    unwrap :: Rec -&gt; String
    unwrap rec = rec.b
</code></pre>
<p>From the Slack channel, garyb mentioned passing the <code>--verbose-errors</code> flag to the compiler. <strong>This will output a LOT of information</strong>, but it's that or nothing. To do that, run this code:</p>
<pre><code class="language-bash">spago build -u --verbose-errors
spago build -u -v
</code></pre>
<h2><a class="header" href="#could-not-match-type-monad-with-type-function-argument---monad-a" id="could-not-match-type-monad-with-type-function-argument---monad-a">Could not match type <code>Monad</code> with type <code>Function (Argument -&gt; Monad a)</code></a></h2>
<p>Whenever you get an error like this....</p>
<pre><code>Error found:
in module Try
at src/example.purs:10:3 - 12:6 (line 10, column 3 - line 12, column 6)

  Could not match type

    Effect

  with type

    Function (String -&gt; Effect Unit)


while trying to match type Effect Unit
  with type (String -&gt; Effect Unit) -&gt; t0
while inferring the type of (log &quot;Here's a message&quot;) log
in value declaration main

where t0 is an unknown type
</code></pre>
<p>It's because you forgot to add the <code>do</code> keyword. Here's the code that produces the error:</p>
<pre><code class="language-haskell">main :: Effect Unit
main = -- missing `do` keyword!
  log &quot;Here's a message&quot;

  log &quot;Here's another message.&quot;
</code></pre>
<h2><a class="header" href="#improve-error-messages-when-using-unsafepartial-to-un-partial-functions" id="improve-error-messages-when-using-unsafepartial-to-un-partial-functions">Improve Error Messages when using <code>unsafePartial</code> to un-Partial Functions</a></h2>
<p>(This section assumes familiarity with the <code>Design Patterns/Partial Functions/</code> folder)</p>
<p>Taken from <a href="https://discourse.purescript.org/t/when-should-you-use-primitive-types-instead-of-custom-types/450/14">safareli's comment in &quot;When should you use primitive types instead of custom types?&quot;&quot;</a>, there might be times where you want to use a partial function to get or compute some value that might not be there. If one just uses <code>unsafePartial $ &lt;unsafeFunction&gt;</code>, the error message will likely not be helpful:</p>
<pre><code class="language-haskell">-- Don't do this.
foo :: forall a. Maybe a -&gt; a
foo mightBeHere =
                  -- we assume that 'mightBeHere' is the &quot;Just a&quot; constructor
  unsafePartial $ fromJust mightBeHere
</code></pre>
<p><code>sarafeli</code>'s suggestion is to pattern match on the value and use <code>unsafeCrashWith</code> instead to provide a much better error message in case your assumption is proven invalid.</p>
<pre><code class="language-haskell">foo :: forall a. Maybe a -&gt; a
foo mightBeHere = case mightBeHere of
  Nothing -&gt; unsafeCrashWith &quot;'mightBeHere' should be a valid 'a'&quot;
  Just v -&gt; v
</code></pre>
<h1><a class="header" href="#custom-type-errors" id="custom-type-errors">Custom Type Errors</a></h1>
<h2><a class="header" href="#pre-reqs-for-this-folder" id="pre-reqs-for-this-folder">Pre-reqs for This Folder</a></h2>
<p>To understand this folder's contents, you should read and be somewhat familiar with Type-Level Syntax. If you haven't already done so, go read through that folder's contents.</p>
<h2><a class="header" href="#scope-of-this-folder" id="scope-of-this-folder">Scope of This Folder</a></h2>
<p>This folder will demonstrate how to write Custom Type Errors (i.e. custom compiler warnings and errors) and why one might find it useful. It provides the foundations for understanding why something happens in the next folder's code. This folder does not get deep into how to do type-level programming. That will be covered later.</p>
<p>In this folder, we'll be using the infix aliases from <a href="https://pursuit.purescript.org/packages/purescript-typelevel-eval/0.2.0">purescript-typelevel-eval</a>. We won't be directly importing it here because it does not yet exist in the default package set (as of this writing).</p>
<h1><a class="header" href="#01-overview-apipurs" id="01-overview-apipurs">01-Overview-API.purs</a></h1>
<pre><code class="language-haskell">module Debugging.CustomTypeErrors.OverviewAPI where

{-
# Prim Special Submodules

Every Purescript project imports the Prim module by default:
https://pursuit.purescript.org/builtins/docs/Prim

This module defines `kind Type` and the types
for `Int`, `Array`, and `Function`.

In addition, the Prim module has sub module called &quot;TypeError&quot;
that is not imported by default. Within it, Prim defines a few
things for writing your own custom type warnings/errors.

Similar to what we did in the Syntax folder, we'll show the
value-level definitions of these type-level types, instances, and functions
-}

{-
The following is commented out to prevent a compiler warning:
  &quot;import is redundant&quot;

-- new imports
import Prim.TypeError (
  -- type-level type
    kind Doc

  -- type-level instances
  , Text
  , Quote
  , Above
  , Beside

  -- type-level functions
  , class Warn
  , class Fail
  )

-}

data Doc_
  = Text_ String      -- wraps a Symbol
  | Quote_ String     -- the Type's name as a Symbol
  | QuoteLabel_ String -- Similar to Text but handles things differently
                       -- Used particularly for 'labels', the 'keys'
                       -- in rows/records (see functions file)
  | Beside_ Doc_ Doc_ -- Similar to &quot;left &lt;&gt; right&quot; (&quot;leftright&quot;) in that
                      -- it places documents side-by-side. However, it's
                      -- different in that these documents are aligned at
                      -- the top.
  | Above_ Doc_ Doc_  -- same as &quot;top&quot; &lt;&gt; &quot;\n&quot; &lt;&gt; &quot;bottom&quot; (&quot;top\nbottom&quot;)

type Explanation = String

warn :: Explanation
warn = &quot;&quot;&quot;
         Usage:
              - Constrain a type with Warn in a value/function declaration
              - Constrain a type in a type class instance with Warn
         Result:
              If value/function is used, outputs a warning during compile-time
         Compilation succeeds?:
              Yes
         Use Cases:
              - &quot;Soft&quot; Deprecation - Indicate to users of library that this
                  function/value will be removed/changed in future
              - Warning indicating developer/debug code should be removed
                  before production code is released
         Does the REPL display it?:
              No (as of this writing)
         &quot;&quot;&quot;

fail :: Explanation
fail = &quot;&quot;&quot;
         Usage:
              - Constrain a type with Fail in a value/function declaration
              - Constrain a type in a type class instance with Fail
         Result:
              If instance is used, outputs an error during compile-time
         Compilation succeeds?:
              No
         Use Cases:
              - &quot;Hard&quot; Deprecation - Remove support for a value/function and
                  force users of library to migrate to new approach or
                  use a different value/function that does the same thing.
              - Provide better error messages for specific type class instances
                  that cannot exist.
         Does the REPL display it?:
              Yes
         &quot;&quot;&quot;
</code></pre>
<h1><a class="header" href="#02-valuespurs" id="02-valuespurs">02-Values.purs</a></h1>
<pre><code class="language-haskell">module Debugging.CustomTypeErrors.Values where

import Effect (Effect)
import Effect.Console (log)
import Data.Show (show)
import Data.Unit (Unit)
import Data.Function (($))
import Control.Bind (discard)

import Prim.TypeError (Text, class Warn, class Fail)

warnFunction :: Warn
  (  Text &quot;Deprecated! Use betterFunction instead&quot;
  ) =&gt; Int -&gt; Int
warnFunction x = x

betterFunction :: Number
betterFunction = 5.0

failFunction :: Fail
  (  Text &quot;Broken! Use betterFunction instead&quot;
  ) =&gt; Int -&gt; Int
failFunction _ = 20

regularFunction :: Int -&gt; Int
regularFunction _ = 4

main :: Effect Unit
main = do
  log $ show $ regularFunction 8
  log $ show $ warnFunction 3

  -- Uncomment the next line, save the file, run it, and see what happens
  -- log $ show $ failFunction 12
</code></pre>
<h1><a class="header" href="#03-functionspurs" id="03-functionspurs">03-Functions.purs</a></h1>
<pre><code class="language-haskell">module Debugging.CustomTypeErrors.Functions where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Type.Proxy (Proxy(..))

import Prim.TypeError (Text, Quote, Above, Beside, QuoteLabel, class Warn, class Fail)

data Doc_
  = Text_ String      -- wraps a Symbol
  | Quote_ String     -- the Type's name as a Symbol
  | QuoteLabel_ String -- Similar to Text but handles things differently
                       -- Used particularly for 'labels', the 'keys'
                       -- in rows/records (see below)
  | Beside_ Doc_ Doc_ -- Similar to &quot;left &lt;&gt; right&quot; (&quot;leftright&quot;) in that
                      -- it places documents side-by-side. However, it's
                      -- different in that these documents are aligned at
                      -- the top.
  | Above_ Doc_ Doc_  -- same as &quot;top&quot; &lt;&gt; &quot;\n&quot; &lt;&gt; &quot;bottom&quot; (&quot;top\nbottom&quot;)

-- The following aliases are taken from purescript-typelevel-eval:
-- https://pursuit.purescript.org/packages/purescript-typelevel-eval/0.2.0/docs/Type.Eval
-- I would use it and import them here, but it's not yet in the default package set
infixr 2 type Beside as &lt;&gt;
infixr 1 type Above as |&gt;

besideExample :: Warn
  (  Text &quot;Beside lays out documents side-by-side, aligned at the top:&quot;
  |&gt; Text &quot;&quot;
  |&gt; ( (  Text &quot;A&quot;
       |&gt; Text &quot;B&quot;
       ) &lt;&gt; Text &quot;C&quot;
     )
  |&gt; Text &quot;&quot;
  |&gt; ( Text &quot;C&quot; &lt;&gt; (  Text &quot;A&quot;
                   |&gt; Text &quot;B&quot;
                   )
     )

  ) =&gt; Int
besideExample = 2

warnValue :: Warn
  (  Text &quot;This warning appears only when you use this value or function&quot;
  |&gt; Text &quot;&quot;
  |&gt; Text &quot;The requested value of type, &quot; &lt;&gt; Quote Int &lt;&gt; Text &quot;,&quot;
  |&gt; Text &quot;is no longer something you should use!&quot;
  |&gt; Text &quot;&quot;
  |&gt; Text &quot;Use betterValue instead since it is of type &quot; &lt;&gt; Quote Number
  ) =&gt; Int
warnValue = 5

betterValue :: Number
betterValue = 5.0

failValue :: Fail
  (  Text &quot;This error only appears when you use this value&quot;
  |&gt; Text &quot;&quot;
  |&gt; Text &quot;Error: Value is no longer valid&quot;
  ) =&gt; Int
failValue = 20

regularValue :: Int
regularValue = 4

-- QuoteLabel vs Text
labelAsText :: forall l. Warn
  ( Text &quot;Text Label &quot; &lt;&gt; Text l
  ) =&gt; Proxy l -&gt; String
labelAsText _ = &quot;&quot;

labelAsQuote :: forall l. Warn
  ( Text &quot;Quote Label &quot; &lt;&gt; QuoteLabel l
  ) =&gt; Proxy l -&gt; String
labelAsQuote _ = &quot;&quot;

main :: Effect Unit
main = do
  log $ show regularValue
  log $ show warnValue

  log $ show besideExample

  -- Demonstrates the difference between Text and QuoteLabel
  log $ show (labelAsText (Proxy :: Proxy &quot;boo&quot;))
  log $ show (labelAsQuote (Proxy :: Proxy &quot;boo&quot;))

  log $ show (labelAsText (Proxy :: Proxy &quot;b\&quot;oo&quot;))
  log $ show (labelAsQuote (Proxy :: Proxy &quot;b\&quot;oo&quot;))

  log $ show (labelAsText (Proxy :: Proxy &quot;b o o&quot;))
  log $ show (labelAsQuote (Proxy :: Proxy &quot;b o o&quot;))

  -- Uncomment the next line, save the file, run it, and see what happens
  -- log $ show failValue
</code></pre>
<h1><a class="header" href="#04-type-class-instancespurs" id="04-type-class-instancespurs">04-Type-Class-Instances.purs</a></h1>
<pre><code class="language-haskell">module Debugging.CustomTypeErrors.TypeClassInstances where

import Effect (Effect)
import Effect.Console (log)
import Data.Show (show)
import Data.Unit (Unit)
import Data.Function (($))

import Prim.TypeError (Text, Above, class Warn, class Fail)

infixr 1 type Above as |&gt;

class ExampleClass a where
  emitMessage :: a -&gt; String

instance ExampleClass Int where
  emitMessage _ = &quot;an integer I'm sure...&quot;

data WarnType = WarnType
data FailType = FailType

instance Warn
  (  Text &quot;No worries! This warning is supposed to happen!&quot;
  |&gt; Text &quot;&quot;
  |&gt; Text &quot;[Some warning message here...]&quot;
  ) =&gt; ExampleClass WarnType where
  emitMessage _ = &quot;The message!&quot;

instance Fail
  (  Text &quot;Using this instance will cause code to fail&quot;
  ) =&gt; ExampleClass FailType where
  emitMessage _ = &quot;This will never occur&quot;

useInstanceOfExampleClass :: forall a. ExampleClass a =&gt; a -&gt; String
useInstanceOfExampleClass a = emitMessage a

main :: Effect Unit
main = do
  log $ show regularInstance

regularInstance :: String
regularInstance = useInstanceOfExampleClass 0

-- Even though this is never used in main,
-- it still emits a warning.
warnInstance :: String
warnInstance = useInstanceOfExampleClass WarnType

-- Even though this is never used in main,
-- it still emits a compiler error
-- failInstance :: String
-- failInstance = useInstanceOfExampleClass FailType
</code></pre>
<h1><a class="header" href="#debug-trace" id="debug-trace">Debug Trace</a></h1>
<p>Previously, we got around the &quot;<code>bind</code> outputs the same box-like type it receives&quot; restriction by using <code>MonadEffect</code>. However, we also explained that <code>ST</code>, the monad used to run a computation that uses local mutable state, did not have an instance for <code>MonadEffect</code>. This decision is intentional.</p>
<p>When we run production code, we want to uphold this restriction. However, when we are debugging code, this restriction can be very annoying. Fortunately, the <a href="https://pursuit.purescript.org/packages/purescript-debug/docs/Debug">Debug</a> package exists to help you use print debugging in any monadic context. You should use it when initially prototyping things. It should never appear in production code, nor as a solution for production-level logging. (We'll show how to do that in the <code>Application Structure</code> folder).</p>
<p><strong>WARNING</strong>: <code>Debug</code>'s functions are not always reliable when running concurrent code (i.e. <code>Aff</code>-based computations).</p>
<h2><a class="header" href="#compilation-instructions" id="compilation-instructions">Compilation Instructions</a></h2>
<h3><a class="header" href="#seeing-the-custom-type-errors" id="seeing-the-custom-type-errors">Seeing the Custom Type Errors</a></h3>
<p>The warnings that will appear when compiling this code only appear once. Once you have built the code, <code>spago</code> will reuse the already-compiled JavaScript and thus won't retrigger these warnings. If you want to see them again, follow these instructions.</p>
<pre><code class="language-bash"># Remove all previously compiled JavaScript
rm -rf output/

# Now build the code to see the warnings.
spago build
</code></pre>
<h3><a class="header" href="#running-the-examples" id="running-the-examples">Running the Examples</a></h3>
<p>Use these commands</p>
<pre><code class="language-bash">spago run -m Debugging.Debug
spago run -m Debugging.LocalState
</code></pre>
<h1><a class="header" href="#01-debugpurs" id="01-debugpurs">01-Debug.purs</a></h1>
<pre><code class="language-haskell">-- When you compile this file, it will output compiler warnings.
-- If you wish to remove that noise, comment out everything below
-- the &quot;module&quot; declaration.
module Debugging.Debug where

-- Comment out everything below this line to prevent compiler warning.
----------------------------------------------------------------------

import Prelude
import Effect (Effect)
import Effect.Console  (log)
import Debug (spy, trace, traceM)

-- Given a simple Box Monad
data Box a = Box a
-- all type class instances are at the end of the file

-- And a way to convert a Box computation into an Effect computation
runBox :: Box ~&gt; Effect
runBox (Box a) = pure a

boxed4 :: Box Int
boxed4 = Box 4

printAndReturnTheValue :: Int -&gt; Int
printAndReturnTheValue x = spy &quot;x&quot; x

printMessageThenRunComputation :: String -&gt; (Unit -&gt; Int) -&gt; Int
printMessageThenRunComputation msg x = trace msg x

-- When running this, you'll notice that the debug messages
-- are outputted in a font color different than the normal output.
main :: Effect Unit
main = do
  -- spy
  log $ show $ printAndReturnTheValue 5

  -- another way to do this
  let _ = spy &quot;four&quot; 4

  -- trace
  log $ show $ printMessageThenRunComputation &quot;before computation&quot; (\_ -&gt; 10)

  log &quot;Right now we are inside of the Effect monad context, \
      \which means we CAN use the `log` function here.&quot;
  value &lt;- runBox do

    four &lt;- boxed4
    -- now we are inside of the Box monad context,
    -- which means we CANNOT use `log` here since
    -- it returns `Effect Unit`, not `Box Unit`

    -- Instead, we'll use traceM
    traceM (&quot;Four is: &quot; &lt;&gt; show four)

    pure (four + 8)

  log $ &quot;Value is: &quot; &lt;&gt; show value

-- Box's type class instances
instance Functor Box where
  map f (Box a) = Box (f a)

instance Apply Box where
  apply (Box f) (Box a) = Box (f a)

instance Applicative Box where
  pure a = Box a

instance Bind Box where
  bind (Box a) f = f a

instance Monad Box
</code></pre>
<h1><a class="header" href="#debugwarning" id="debugwarning">DebugWarning</a></h1>
<p><code>Debug</code> uses Custom Type Errors to warn the developer when it is being used.</p>
<p>Let's examine it further since it provides an example for us to follow should we wish to do something similar in the future. The source code is <a href="https://github.com/garyb/purescript-debug/blob/v5.0.0/src/Debug.purs">here</a>, but we'll provide type signatures for the parts we need below and explain their usage:</p>
<pre><code class="language-haskell">-- See the copyright notice at the bottom of this file for this code:

-- | Nullary type class used to raise a custom warning for the debug functions.
class DebugWarning

instance Warn (Text &quot;Debug usage&quot;) =&gt; DebugWarning

foreign import trace :: forall a b. DebugWarning =&gt; a -&gt; (Unit -&gt; b) -&gt; b

-- same idea as 'trace' for all the other functions
</code></pre>
<p>In short, rather than writing <code>function :: Warn (Text &quot;Debug usage&quot;) =&gt; [function's type signature]</code> on every function, they use an empty type class whose sole instance adds this for every usage of that type class.</p>
<hr>
Copyright notice for the above code:
<pre><code>The MIT License (MIT)

Copyright (c) 2015 Gary Burgess

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the &quot;Software&quot;), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>
<h1><a class="header" href="#03-local-statepurs" id="03-local-statepurs">03-Local-State.purs</a></h1>
<pre><code class="language-haskell">-- Now that we understand how `Debug.Trace` works, let's show
-- what's going on in our previous local mutable state computation.
--
-- When you compile this file, it will output compiler warnings due to
-- usage of `Debug.Trace (traceM)`. If you wish to remove that noise,
-- comment out every usage of `traceM` in this file.
module Debugging.LocalState where

import Prelude

import Control.Monad.ST as ST
import Control.Monad.ST.Ref as STRef
import Debug (traceM)
import Effect (Effect)
import Effect.Console (log)

main :: Effect Unit
main = do
  log &quot;We will run some modifications on some local state \
      \and then try to modify it out of scope.&quot;
  log $ show $ ST.run do
    box &lt;- STRef.new 0
    x0 &lt;- STRef.read box
    traceM $ &quot;x0 should be 0: &quot; &lt;&gt; show x0

    _ &lt;- STRef.write 5 box
    x1 &lt;- STRef.read box
    traceM $ &quot;x1 should be 5: &quot; &lt;&gt; show x1

    -- Note: `STRef.modify_` doesn't exist.

    newState &lt;- STRef.modify (\oldState -&gt; oldState + 1) box
    x2 &lt;- STRef.read box
    traceM $ &quot;x2 should be 6: &quot; &lt;&gt; show x2 &lt;&gt; &quot; | newState should be 6: &quot; &lt;&gt; show newState

    value &lt;- STRef.modify' (\oldState -&gt; { state: oldState * 10, value: 30 }) box
    x3 &lt;- STRef.read box
    traceM $ &quot;value should be 30: &quot; &lt;&gt; show value
    traceM $ &quot;x3 should be 60: &quot; &lt;&gt; show x3

    let loop 0 = STRef.read box
        loop n = do
          _ &lt;- STRef.modify (_ + 1) box
          loop (n - 1)

    loop 20

  log &quot;Attempting to access box here will result in a compiler error&quot;
</code></pre>
<h1><a class="header" href="#console-based-debugging" id="console-based-debugging">Console-Based Debugging</a></h1>
<p>A library that may be useful to use when debugging is <code>purescript-debugger</code> (<a href="https://github.com/paf31/purescript-debugger"><code>3.0.0</code>'s source code</a> &amp; <a href="https://pursuit.purescript.org/packages/purescript-debugger/2.0.0"><code>2.0.0</code>'s docs</a>). This library's latest release is <code>3.0.0</code>, but the updated docs have not been pushed to Pursuit yet. I'm not sure what changed</p>
<p>I will not cover this library here (though I might later). I'm including it, so that you are aware of it in the future once we've covered more things.</p>
<h1><a class="header" href="#other-tips" id="other-tips">Other Tips</a></h1>
<p>This file includes tips I've seen people share on the FP Slack channel:</p>
<blockquote>
<p>How do you guys typically go about debugging runtime issues? Especially bad FFI interactions? Right now I end up using <code>Debug.Trace</code> pretty frequently. Im trying to move toward a workflow where I can resolve more of these issues with automated testing and in the REPL. I think the REPL is probably the way to go for most logic issues in PS? However, if API definitions are wonky in the FFI then the REPL isnt generally super useful since Ill just get some error from deep in the bundle in some dependency typically.</p>
</blockquote>
<p>From <code>@kritzcreek</code>:</p>
<blockquote>
<p>I use <code>Debug.Trace</code> and break points in the browser. In general, I minimize having to interact with the FFI. If you're crossing the boundary too often maybe you can change your design to move more into PS or isolate and group the FFI interactions more clearly. I rarely use the REPL at all, parcel or webpack reloading the webpage on change in my editor is fast enough for my feedback cycle needs</p>
</blockquote>
<h1><a class="header" href="#collections-and-loops" id="collections-and-loops">Collections and Loops</a></h1>
<p>This folder will overview the <code>purescript-foldable-traversable</code> and <code>purescript-filterable</code> libraries. Together, these libraries provide most of the functions one would use when working with collections.</p>
<p>These two type classes are being overviewed because their concepts will arise later in the &quot;Hello World&quot; folder. Rather than explaining them there when we need them, we'll explain them here so that they are more familiar when we get to them there.</p>
<h1><a class="header" href="#foldable" id="foldable">Foldable</a></h1>
<h2><a class="header" href="#usage-5" id="usage-5">Usage</a></h2>
<p>Plain English names:</p>
<ul>
<li>Summarizeable</li>
<li>Reducible</li>
<li>FP version of the Iterator Pattern</li>
</ul>
<pre><code>  Given
    a box-like type, `f`,
      that stores zero or more `a` values
        and
    an initial value of type, `b`
        and
    a `Semigroup`/`Monoid`-like function
      that produces a `b` value if given an `a` and a `b` argument,
        of which there are two versions
        (
          either `a -&gt; b -&gt; b`
          or     `b -&gt; a -&gt; b`
        ),
return a single value of type, `b` by
  (first application) passing the initial `b` and initial `a` values into the function,
    which produces the next `b` value,
  (recursive application) passing the previously-computed `b` value with the next `a` value into the function
    which produces the next `b` value,
    which will eventually be the final `b` value returned
      when there are no more `a` values
        in the box-like `f` type.
</code></pre>
<p>It enables:</p>
<ul>
<li>a way to reduce a <code>List</code> of <code>String</code>s into one <code>String</code> (the combination of all the <code>String</code>s)</li>
<li>a way to reduce a <code>List</code> of <code>Int</code>s into one <code>Int</code> (the sum/product of all the ints)</li>
<li>a way to take a <code>List Int</code> and create a <code>Map String Int</code> (each value is an <code>Int</code> from the list and its key is the output of <code>show int</code>)</li>
<li>a way to take a <code>List Int</code> and double each <code>Int</code> in the list (i.e. write <code>List</code>'s <code>Functor</code> instance by implementing <code>map</code> via this type class).</li>
</ul>
<h2><a class="header" href="#definition-6" id="definition-6">Definition</a></h2>
<h3><a class="header" href="#code-definition" id="code-definition">Code Definition</a></h3>
<p>Don't look at its docs until after looking at the visual overview in the next section: <a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/4.0.1/docs/Data.Foldable#t:Foldable">Foldable</a></p>
<pre><code class="language-haskell">class (Functor f) =&gt; Foldable f where
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m

  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
</code></pre>
<h3><a class="header" href="#visual-overview-1" id="visual-overview-1">Visual Overview</a></h3>
<p>For a cleaner visual, see <a href="http://www.joachim-breitner.de/blog/753-Drawing_foldl_and_foldr">Drawing <code>foldl</code> and <code>foldr</code></a></p>
<h4><a class="header" href="#foldl" id="foldl"><code>foldl</code></a></h4>
<p>This version creates a tree-like structure of computations that starts evaluating immediately via <code>function Binput A1</code> and continues evaluating towards the bottom-right. Since each step evaluates immediately, this version is &quot;stack safe.&quot;</p>
<pre><code>(b -&gt; a -&gt; b)  Binit   //=== `f a` ===\\
|               |      ||             ||
|               |      || A1  A2  A3  ||
|               |      \\=+===+===+===//
|               |         |   |   |
\               \         /   |   |
 \=========&gt;     ---------    |   |
  |                 B2        |   |
  |                 |         |   |
  \                 \         /   |
   \==========&gt;      ---------    |
    |                   B3        |
    |                   |         |
    \                   \         /
     \==========&gt;        ---------
                             Boutput
</code></pre>
<h4><a class="header" href="#foldr" id="foldr"><code>foldr</code></a></h4>
<p>This version creates a tree-like structure of computations that doesn't start evaluating until it gets to the bottom right of the tree. Once it reaches the bottom right, it evaluates <code>function A3 Binput</code> and then evaluates towards the top-left of the tree
Since each step towards the bottom-right of the tree allocates a stack, this function is not always &quot;stack safe&quot;.</p>
<pre><code>      Boutput
    -----     &lt;==========\
   /      \               \
   |      |               |
   |      |               |
   |      B3              |
   |    ------    &lt;=======\
   |   /       \           \
   |   |       |           |
   |   |       B2          |
   |   |    -------   &lt;====\
   |   |   /        \       \
   |   |   |        |       |
//=+===+===+===\\   |       |
|| A1  A2  A3  ||   |       |
||             ||   |       |
\\=== `f a` ===//   Binit   (a -&gt; b -&gt; b)
</code></pre>
<h3><a class="header" href="#examples-2" id="examples-2">Examples</a></h3>
<p>We'll implement instances for three types: <code>Box a</code>, <code>Maybe a</code>, and <code>List a</code>. Each implementation will become more complicated that the previous one.</p>
<h4><a class="header" href="#boxs-instance" id="boxs-instance"><code>Box</code>'s Instance</a></h4>
<pre><code class="language-haskell">data Box a = Box a

-- Box's implementation doesn't show the difference between `foldl` and `foldr`.
-- Moreover, the initial `b` value isn't really necessary.
instance Foldable Box where
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Box a -&gt; b
  foldl reduceToB initialB (Box a) = reduceToB initialB a

  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Box a -&gt; b
  foldr reduceToB initialB (Box a) = reduceToB a initialB

  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Box a -&gt; m
  foldMap aToMonoid (Box a) = aToMonoid a
</code></pre>
<h4><a class="header" href="#maybes-instance" id="maybes-instance"><code>Maybe</code>'s instance</a></h4>
<pre><code class="language-haskell">-- Maybe's implementation doesn't show the difference between `foldl` and `foldr`.
-- However, the initial `b` value is necessary
-- because of the possible `Nothing` case.
instance Foldable Maybe where
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Maybe a -&gt; b
  foldl reduceToB initialB (Just a) = reduceToB initialB a
  foldl _         initialB Nothing  =           initialB

  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Maybe a -&gt; b
  foldr reduceToB initialB (Just a) = reduceToB a initialB
  foldr _         initialB Nothing  =             initialB

  -- While we could implement this the same way as `Box`, let's reuse
  -- `foldl` to implement it
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Maybe a -&gt; m
  foldMap aToMonoid maybe =
    foldl (\b a -&gt; b &lt;&gt; (aToMonoid a)) mempty maybe
</code></pre>
<h4><a class="header" href="#lists-instance" id="lists-instance"><code>List</code>'s instance</a></h4>
<pre><code class="language-haskell">-- Cons 1 (Cons 2 Nil)
-- 1 : (Cons 2 Nil)
-- 1 : 2 : Nil
-- same as [1, 2]
-- In the below implementations, `op` stands for `operation`
instance Foldable List where
  -- Same as...
  -- ((((intialB `op` firstElem) `op` secondElem) `op` ...) `op` lastElem)
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; List a -&gt; b
  foldl _         accumB   Nil           = accumB
  foldl op initialB (head : tail) =
    foldl op (op initialB head) tail

  -- Same as...
  -- (firstElem `op` (secondElem `op` (... `op` (lastElem `op` initialB))))
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; b
  foldr op accumB   Nil           = accumB
  foldr op initialB (head : tail) =
    op head (foldl op initialB tail)

  -- Unlike Box, reusing `foldl`/`foldr` is actually the cleaner way
  -- to implement `foldMap` for `List`.
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; List a -&gt; m
  foldMap aToMonoid list =
    foldl (\b a -&gt; b &lt;&gt; (aToMonoid a)) mempty list

instance Functor List where
  map f list =
    -- Due to stack safety, this is not how this is implemented
    -- but it communicates the same idea
    foldr (\prevHead tail -&gt; (f prevHead) : tail) Nil list
</code></pre>
<h3><a class="header" href="#general-usage-patterns" id="general-usage-patterns">General Usage Patterns</a></h3>
<p>We'll see more of this in the upcoming overview of the derived functions. However, <code>foldl</code> and its corresponding members tend to follow a few patterns:</p>
<pre><code class="language-haskell">reduceAllAsIntoOneAValue = foldl reduce initial foldableType
  where
    iniital = -- a type class value or hard-coded value
              -- like `mempty` or `true` or `Data.Ordering.LT`, etc.

    reduce = -- some type class function like `&lt;&gt;` or `&amp;&amp;` or `+`, etc.
             -- Note: sometimes this function will change the `a` to
             -- a different type before the function receives it as an argument

-- allows this type of computation: &quot;a1 `operation` a2 `operation` a3&quot;
thereIsNoInitialB_iterateThroughAllAValues =
  let record = foldl reduce initial foldableType
  in record.value

  where
    initial = { isFirstRun: true, value: initialValue }
    reduce b a =
      { isFirstRun: false, value:
          if b.isFirstRun then a else (realReduceFunction b.value a)
      }

buildHigherKindedData = foldl build initial foldableType
  where
    initial = Map.empty
    build mapSoFar nextValue =
      let
        key = show nextValue
        value = someComplicatedFunction nextValue
      in
        Map.add mapSoFar key value

forEachA_doSomeComputation = foldl compute initial foldableType
  where
    initial :: Effect Unit
    initial = pure unit

    compute :: a -&gt; Effect Unit
    compute _ nextValue = do
      someValue &lt;- computeUsing nextValue
      allIsGood &lt;- doSomethingElse someValue
      pure unit
</code></pre>
<h2><a class="header" href="#laws-6" id="laws-6">Laws</a></h2>
<p>None</p>
<h2><a class="header" href="#derived-functions-5" id="derived-functions-5">Derived Functions</a></h2>
<p>We'll overview the derived functions by first grouping them into a few categories, and then providing a general definition for what each one does.</p>
<h3><a class="header" href="#default-implementations-for-the-members-of-the-foldable-type-class" id="default-implementations-for-the-members-of-the-foldable-type-class">Default implementations for the members of the <code>Foldable</code> type class</a></h3>
<p><code>foldMap</code> can be implemented using either <code>foldl</code> or <code>foldr</code>. Likewise, both <code>foldl</code> and <code>foldr</code> can be implemented using <code>foldMap</code>.</p>
<p>Thus, once one has implemented one of these sets, they can use a default implementation to implement the other set:</p>
<ul>
<li>if <code>foldl</code> and <code>foldr</code> both are implemented, you can implement <code>foldMap</code> by using one of the two function below:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:foldMapDefaultL"><code>foldMapDefaultL</code></a> which uses <code>foldl</code> under the hood</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:foldMapDefaultR"><code>foldMapDefaultR</code></a> which uses <code>foldr</code> under the hood</li>
</ul>
</li>
<li>if <code>foldMap</code> is implemented, you can use the functions below to implement <code>foldl</code> and <code>foldr</code>:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:foldlDefault"><code>foldlDefault</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:foldrDefault"><code>foldrDefault</code></a></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#use-another-type-class-to-reduce-multiple-a-values-into-one-value" id="use-another-type-class-to-reduce-multiple-a-values-into-one-value">Use another type class to reduce multiple <code>a</code> values into one value.</a></h3>
<ul>
<li>via <code>Semigroup</code>'s <code>append</code>/<code>&lt;&gt;</code> function:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:fold"><code>fold</code></a> == <code>a1 &lt;&gt; a2 &lt;&gt; ... &lt;&gt; aLast &lt;&gt; mempty</code></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:intercalate"><code>intercalate</code></a> == <code>a1 &lt;&gt; separator &lt;&gt; a2 &lt;&gt; separator &lt;&gt; a3 ...</code>
<ul>
<li><code>fold</code> but with a separator value appended in-beteeen <code>a</code> values.</li>
</ul>
</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:surroundMap"><code>surround</code></a> == <code>value &lt;&gt; a1 &lt;&gt; value &lt;&gt; a2 &lt;&gt; value ...</code>
<ul>
<li>The inverse of intercalate</li>
</ul>
</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:surround"><code>surroundMap</code></a> == <code>value &lt;&gt; (aToMonoid a1) &lt;&gt; value &lt;&gt; (aToMonoid a2) &lt;&gt; value ...</code>
<ul>
<li>Same as <code>surround</code>, but the <code>a</code> can be changed to <code>b</code> before being appended to <code>value</code>.</li>
</ul>
</li>
</ul>
</li>
<li>via <code>HeytingAlgebra</code>'s <code>conj</code>/<code>&amp;amp;&amp;amp;</code> or <code>disj</code>/<code>||</code> functions.
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:and"><code>and</code></a> == <code>a1 &amp;&amp; a2 &amp;&amp; a3 &amp;&amp; ...</code></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:or"><code>or</code></a> == <code>a1 || a2 || a3 || ...</code></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:all"><code>all</code></a> == <code>(aToB a1) &amp;&amp; (aToB a2) &amp;&amp; (aToB a3) &amp;&amp; ...</code>
<ul>
<li>Same as <code>and</code>, but the <code>a</code> can be changed to <code>b</code> before being <code>&amp;&amp;</code>'d.</li>
</ul>
</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:any"><code>any</code></a> == <code>(aToB a1) || (aToB a2) || (aToB a3) || ...</code>
<ul>
<li>Same as <code>or</code>, but the <code>a</code> can be changed to <code>b</code> before being <code>||</code>'d.</li>
</ul>
</li>
</ul>
</li>
<li>via <code>Semiring</code>s <code>plus</code>/<code>+</code> or <code>multiply</code>/<code>*</code> functions:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:sum"><code>sum</code></a> == <code>a1 + a2 + a3 + ...</code></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:product"><code>product</code></a> == <code>a1 * a2 * a3 * ...</code></li>
</ul>
</li>
<li>via <code>Alt</code>'s <code>alt</code>/<code>&lt;|&gt;</code> and <code>Plus</code>'s <code>empty</code> functions (very similar to the <code>Semigroup</code> and <code>Monoid</code> relationship):
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:oneOf"><code>oneOf</code></a> == [1, 2, 3] == <code>[1] &lt;|&gt; [2] &lt;|&gt; [3] &lt;|&gt; ...</code> == <code>foldl &lt;|&gt; empty [[1], [2], [3], ...]</code></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:oneOfMap"><code>oneOfMap</code></a></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#determine-information-about-the-foldable-type-based-on-the-a-values-it-contains--get-an-a-value" id="determine-information-about-the-foldable-type-based-on-the-a-values-it-contains--get-an-a-value">Determine information about the <code>Foldable</code> type based on the <code>a</code> values it contains / get an <code>a</code> value</a></h3>
<p>Note: the below functions are not as performant as they could be because they will iterate through all of the <code>a</code> values in the <code>Foldable</code> type, even if the desired information is found as soon as possible when testing the first <code>a</code> value. In other words, these functions do not &quot;short circuit&quot;.</p>
<ul>
<li>via <code>Eq</code>'s <code>eq</code>/<code>==</code> and <code>notEq</code>/<code>/=</code> functions:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:elem"><code>elem</code></a> == <code>(a1 == test) || (a2 == test) || (a3 == test) || ...</code></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:notElem"><code>notElem</code></a> == <code>(a1 /= test) &amp;&amp; (a2 /= test) &amp;&amp; (a3 /= test) &amp;&amp; ...</code></li>
</ul>
</li>
<li>Get the index of an <code>a</code> value within the <code>Foldable</code> type:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:indexl"><code>indexl</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:indexr"><code>indexr</code></a></li>
</ul>
</li>
<li>Get first element which satisfies some predicate:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:find"><code>find</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:findMap"><code>findMap</code></a></li>
</ul>
</li>
<li>via <code>Ord</code>'s <code>compare</code> function and its derivations (e.g. <code>&lt;</code>, <code>&gt;</code>, etc.):
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:minimum"><code>minimum</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:minimumBy"><code>minimumBy</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:maximum"><code>maximum</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:maximumBy"><code>maximumBy</code></a></li>
</ul>
</li>
<li>Calculate the length or emptiness of the type:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:null"><code>null</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:length"><code>length</code></a></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#execute-a-for-loop-that-runs-an-applicativemonadic-computation-eg-effect-using-each-a-in-the-foldable-type" id="execute-a-for-loop-that-runs-an-applicativemonadic-computation-eg-effect-using-each-a-in-the-foldable-type">Execute a &quot;for loop&quot; that runs an applicative/monadic computation (e.g. <code>Effect</code>) using each <code>a</code> in the <code>Foldable</code> type</a></h3>
<p>In the Philosophical Foundations folder, we used a recursive function to implement a &quot;for loop.&quot; I mentioned there that one could implement the same thing using a type class called <code>Foldable</code>. It is these last three functions that show how to do that.</p>
<p>In JavaScript, we might write something like this:</p>
<pre><code class="language-javascript">var array = [1, 2, 3];
for (int i = 0; i &lt; array.length; i++) {
  var elem = array[i];
  console.log(elem);
}
</code></pre>
<p>In PureScript, we would write the same thing via <code>Foldable</code>:</p>
<ul>
<li>*<a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:for_"><code>for_</code></a> == <code>for_ array log</code></li>
<li>*<a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:traverse_"><code>traverse_</code></a> == <code>traverse_ log array</code>
<ul>
<li>Same as <code>for_</code> but the function comes first</li>
</ul>
</li>
<li>*<a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:sequence_"><code>sequence_</code></a> == <code>sequence_ [ log &quot;1&quot;, log &quot;2&quot;, log &quot;3&quot; ]</code>
<ul>
<li>Same as <code>for_</code> but the <code>a</code> values are applicative computations that have yet to be executed</li>
</ul>
</li>
</ul>
<ul>
<li>Note: that each of these computations must output only <code>Unit</code>. <code>Traversable</code>, which is covered next, removes that limitation.</li>
</ul>
<p>A related function is <code>foldM</code>, which allows one to run a monadic computation multiple times where the next computation depends on the output of the previous computation. <strong>As the docs indicate, this function is not generally stack-safe.</strong></p>
<p><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Foldable#v:foldM"><code>foldM</code></a></p>
<p>Here's an example:</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  int &lt;- randomInt 1 10
  output &lt;- foldM recursiveComputation 1 [1, 2, 3]
  log $ &quot;Output was: &quot; &lt;&gt; show output
  where
    recursiveComputation initialOrAccumulatedValue nextValueInArray = do
      anotherInt &lt;- randomInt 1 nextValueInArray
      pure (anotherInt + initialOrAccumulatedValue)
</code></pre>
<p>... which is the same as writing...</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  int &lt;- randomInt 1 10

  -- begin loop
    -- initialOrAccumulatedValue = 1; nextValueInArray = 1
  anotherInt1 &lt;- randomInt 1 1
  accmulatedValue1 &lt;- pure (anotherInt1 + 1)

    -- initialOrAccumulatedValue = 1; nextValueInArray = 2
  anotherInt2 &lt;- randomInt 1 2
  accmulatedValue2 &lt;- pure (anotherInt2 + accmulatedValue1)

    -- initialOrAccumulatedValue = 1; nextValueInArray = 1
  anotherInt3 &lt;- randomInt 1 3
  output &lt;- pure (anotherInt3 + accmulatedValue2)
  -- end loop

  log $ &quot;Output was: &quot; &lt;&gt; show output
</code></pre>
<h1><a class="header" href="#traversable" id="traversable">Traversable</a></h1>
<h2><a class="header" href="#usage-6" id="usage-6">Usage</a></h2>
<p><a href="https://twitter.com/blouerat/status/867278331779198976">The answer is always traverse</a></p>
<p>While <code>Foldable</code> allowed us to use things like <code>for_</code>, <code>traverse_</code>, and <code>sequence_</code>, these three functions restricted computations to only outputting <code>Unit</code>. <code>Traversable</code> removes that restriction and stores each computation's output in the same <code>Traversable</code> type. Moreover, its derived functions enable a few other nice things.</p>
<p>Plain English names:</p>
<ul>
<li>BoxSwap (sequence)</li>
<li>ForEach (traverse)</li>
</ul>
<h3><a class="header" href="#sequence" id="sequence">Sequence</a></h3>
<h4><a class="header" href="#use-case-1-swap-the-box-types" id="use-case-1-swap-the-box-types">Use Case 1: Swap the box types</a></h4>
<p>I have <code>Array (Maybe a)</code>. I need <code>Maybe (Array a)</code>. The box-like types, <code>Array</code> and <code>Maybe</code> need to swap places.</p>
<pre><code class="language-haskell">sequence [Just 1, Just 2, Nothing] == Nothing -- because the array had at least 1 `Nothing`.
sequence [Just 1, Just 2, Just 8] == Just [1, 2, 8] -- because the array only had `Just`s.
</code></pre>
<h4><a class="header" href="#use-case-2-run-all-computations-in-a-traversable-type-and-store-their-outputs-in-the-same-traversable-type" id="use-case-2-run-all-computations-in-a-traversable-type-and-store-their-outputs-in-the-same-traversable-type">Use Case 2: run all computations in a <code>Traversable</code> type and store their outputs in the same <code>Traversable</code> type</a></h4>
<p>This box-swapping property is quite useful as the below example illustrates.</p>
<p>We'll start with sequence first. I could write:</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  let produceInt = randomInt 1 10

  output1 &lt;- produceInt
  output2 &lt;- produceInt
  output3 &lt;- produceInt
  output4 &lt;- produceInt
  -- ...
  log $ &quot;Generated Ints were: &quot; &lt;&gt; show [output1, output2, output3, output4]
</code></pre>
<p>The above code works. However, if I want to add a fifth one, I need to add another <code>outputN &lt;- produceInt</code> line and add the <code>outputN</code> to the array.</p>
<p>Instead, I could write</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  outputArray &lt;- sequence
    [ produceInt
    , produceInt
    , produceInt
    , produceInt
    -- ...
    ]
  log $ &quot;Generated Ints were: &quot; &lt;&gt; show outputArray
</code></pre>
<h3><a class="header" href="#traverse-convert-each-a-value-in-the-traversable-type-into-a-computation-run-all-computations-and-store-their-outputs-in-the-same-traversable-type" id="traverse-convert-each-a-value-in-the-traversable-type-into-a-computation-run-all-computations-and-store-their-outputs-in-the-same-traversable-type">Traverse: convert each <code>a</code> value in the <code>Traversable</code> type into a computation, run all computations, and store their outputs in the same <code>Traversable</code> type</a></h3>
<p>I could write:</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  let produceInt = \maxBound -&gt; randomInt 1 maxBound

  output1 &lt;- produceInt 8
  output2 &lt;- produceInt 20
  output3 &lt;- produceInt 40
  output4 &lt;- produceInt 90
  -- ...
  log $ &quot;Generated Ints were: &quot; &lt;&gt; show [output1, output2, output3, output4]
</code></pre>
<p>The same problems as before arise. Instead, I could write</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  let produceInt = \maxBound -&gt; randomInt 1 maxBound
  outputArray &lt;- traverse produceInt [8, 20, 40, 90]
  log $ &quot;Generated Ints were: &quot; &lt;&gt; show outputArray
</code></pre>
<h2><a class="header" href="#definition-7" id="definition-7">Definition</a></h2>
<pre><code class="language-haskell">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p>See its docs: <a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable">Traversable</a></p>
<h2><a class="header" href="#laws-7" id="laws-7">Laws</a></h2>
<p>None, but the members should be compatible in the following ways:</p>
<pre><code>traverse f xs = sequence (f &lt;$&gt; xs)
sequence = traverse identity
</code></pre>
<h2><a class="header" href="#derived-functions-6" id="derived-functions-6">Derived Functions</a></h2>
<h3><a class="header" href="#default-implementations-for-the-members-of-the-traversable-type-class" id="default-implementations-for-the-members-of-the-traversable-type-class">Default implementations for the members of the <code>Traversable</code> type class</a></h3>
<p><code>traverse</code> can be implemented using <code>sequence</code> and <code>sequence</code> can be implemented using <code>traverse</code>. Similar to <code>Foldable</code>, once one has implemented one of these when writing a <code>Traversable</code> instance for a data type, they can use a default implementation to implement the other:</p>
<ul>
<li>if <code>traverse</code> is implemented, you can implement <code>sequence</code> by using <a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable#v:sequenceDefault"><code>sequenceDefault</code></a></li>
<li>if <code>sequence</code> is implemented, you can implement <code>traverse</code> by using <a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable#v:traverseDefault"><code>traverseDefault</code></a></li>
</ul>
<h3><a class="header" href="#for-is-traverse-with-its-arguments-flipped" id="for-is-traverse-with-its-arguments-flipped"><code>for</code> is <code>traverse</code> with its arguments flipped</a></h3>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable#v:for"><code>for</code></a></li>
</ul>
<p>Using the same <code>traverse</code> example as above:</p>
<pre><code class="language-haskell">main :: Effect Unit
main = do
  outputArray &lt;- for [8, 20, 40, 90] \maxBound -&gt; randomInt 1 maxBound
  log $ &quot;Generated Ints were: &quot; &lt;&gt; show outputArray
</code></pre>
<h3><a class="header" href="#outputting-each-steps-accumulated-value-at-that-time-for-a-foldlfoldr-computation" id="outputting-each-steps-accumulated-value-at-that-time-for-a-foldlfoldr-computation">Outputting each step's accumulated value at that time for a <code>foldl</code>/<code>foldr</code> computation</a></h3>
<p>The downside of using <code>foldl</code>/<code>foldr</code> is that you only know the <code>foldl</code>/<code>foldr</code> computation's final output. You don't know how that output was reached / what each step's accumulated value was.</p>
<pre><code class="language-haskell">foldl (+) 0 [1, 2, 3, 4,  5 ] ==
            15 -- &lt;= know the output, but don't know how we reached that conclusion
               --    What was the output of `accumulatedValueAtThatPoint + 2`?
</code></pre>
<p>In such cases, you use</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable#v:scanl"><code>scanl</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable#v:scanr"><code>scanr</code></a></li>
</ul>
<pre><code class="language-haskell">foldl (+) 0 [1, 2, 3, 4,  5 ] ==
            15 -- &lt;= know the output, but don't know how we reached that conclusion

scanl (+) 0 [1, 2, 3, 4,  5 ] ==
            [1, 3, 6, 10, 15] -- &lt;= now we can see how that conclusion was reached
                              --    if traversing from the left

scanr (+) 0 [1,  2,  3,  4, 5] ==
            [15, 14, 12, 9, 5] -- &lt;= now we can see how that conclusion was reached
                               --    if traversing from the right
</code></pre>
<p>In other words, the value at index <code>n</code> in the outtputted array is the output of passing the value at index <code>n</code> in the input array and the accumulated value at that point in time into the folding function (i.e. <code>+</code>). Using the <code>scanr</code> example, the input array's index 2 value (i.e. <code>3</code>) and the accumulated value at that time (the output array's index 3 value, <code>9</code>) were both passed into the folding function, <code>+</code>, to produce the output array's index 2 value (i.e. <code>12</code>).</p>
<h3><a class="header" href="#outputting-both-the-output-and-each-steps-accumulated-value-at-that-time-for-a-foldlfoldr-computation" id="outputting-both-the-output-and-each-steps-accumulated-value-at-that-time-for-a-foldlfoldr-computation">Outputting <strong>both</strong> the output <strong>and</strong> each step's accumulated value at that time for a <code>foldl</code>/<code>foldr</code> computation</a></h3>
<p>The downside of using <code>scanl</code>/<code>scanr</code> is that we don't have access to <strong>both</strong> the final output of the fold <strong>and</strong> the path it took to get there.</p>
<pre><code class="language-haskell">foldl (+) 0 [1, 2, 3, 4,  5 ] ==
            15 -- &lt;= know the output, but don't know the path of how we got there

scanl (+) 0 [1, 2, 3, 4,  5 ] ==
            [1, 3, 6, 10, 15] -- &lt;= know the path, but not the output
</code></pre>
<p>In such cases, you can use</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable#v:mapAccumL"><code>mapAccumL</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Traversable#v:mapAccumR"><code>mapAccumR</code></a></li>
</ul>
<pre><code class="language-haskell">foldl (+) 0 [1, 2, 3, 4,  5 ] ==
            15 -- &lt;= know the output, but don't know the path of how we got there

scanl (+) 0 [1, 2, 3, 4,  5 ] ==
            [1, 3, 6, 10, 15] -- &lt;= know the path, but not the output

type Accum s a = { accum :: s, value :: a }

mapAccumL (\accumulationSoFar nextValue -&gt;
    let outputAtThisStep = accumulationSoFar + nextValue
    in { accum: outputAtThisStep, value: outputAtThisStep}
  ) 0                [1, 2, 3, 4,  5 ] ==
  {accum: 15, value: [1, 3, 6, 10, 15]} -- &lt;= know both output and path
</code></pre>
<p>You can see how <code>mapAccumL</code>/<code>mapAccumR</code> enables you to write even complex computations fairly easily. Still, these two functions are more expressive than just a combining the outputs of <code>foldl</code> and <code>scanl</code> in one computation, since they allow for more types to be used in the computation.</p>
<p>Below is a nonsensical example demonstrating this:</p>
<pre><code class="language-haskell">import Prelude
import Data.Traversable (mapAccumL)
import Data.Traversable.Accum (Accum)
import Data.Foldable (sum, length)
import Data.Array (snoc)

-- type Accum s a = { accum :: s, value :: a }

nonsensicalExample :: Accum (Array Int) (Array Int)
nonsensicalExample = mapAccumL reducer [] [1, 2, 3, 4, 5]
  where
  reducer :: Array Int -&gt; Int -&gt; Accum (Array Int) Int
  reducer accumulationSoFar nextValue =
    let
      arrayLength = length accumulationSoFar
      arraySum = sum accumulationSoFar -- foldl (+) 0 accumulationSoFar
    in { accum: accumulationSoFar `snoc` arrayLength `snoc` arraySum
       , value: show $ nextValue + arraySum
       }
</code></pre>
<p>produces <code>{ accum: [0,0,2,0,4,2,6,8,8,22], value: [&quot;1&quot;, &quot;2&quot;, &quot;5&quot;, &quot;12&quot;, &quot;27&quot;] }</code></p>
<h1><a class="header" href="#their-variations" id="their-variations">Their Variations</a></h1>
<p>Once you get how <code>Foldable</code> and <code>Traversable</code> works, the following variations should be pretty easy to grasp</p>
<h2><a class="header" href="#variants-that-include-the-a-values-index" id="variants-that-include-the-a-values-index">Variants that include the <code>a</code> value's index</a></h2>
<p>The same as their base type classes, but an additional <code>Int</code> argument represent the <code>a</code>'s index in <code>f</code> is included in the <code>map</code>/<code>fold</code>/<code>traverse</code> functions.</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.FunctorWithIndex"><code>FunctorWithIndex</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.FoldableWithIndex"><code>FoldableWithIndex</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.TraversableWithIndex"><code>TraversableWithIndex</code></a></li>
</ul>
<h2><a class="header" href="#variants-where-the-f-cannot-be-empty" id="variants-where-the-f-cannot-be-empty">Variants where the <code>f</code> cannot be empty</a></h2>
<p>The same as their base type classes, but the <code>f</code> type must always have at least 1 <code>a</code> value. As a result, the <code>Applicative</code> requirement in the type class' functions can be downgraded to just <code>Apply</code>:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Semigroup.Foldable"><code>Foldable1</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Semigroup.Traversable"><code>Traversable1</code></a></li>
</ul>
<h2><a class="header" href="#variants-where-the-f-can-have-2-types" id="variants-where-the-f-can-have-2-types">Variants where the <code>f</code> can have 2 types</a></h2>
<p>The same as their base type classes, but as though it was <code>f (Tuple a b)</code> rather than <code>f a</code>:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Bifoldable"><code>Bifoldable</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-foldable-traversable/docs/Data.Bitraversable"><code>Bitraversable</code></a></li>
</ul>
<h1><a class="header" href="#purescript-filterable" id="purescript-filterable">PureScript Filterable</a></h1>
<p>The following type classes come from <a href="https://pursuit.purescript.org/packages/purescript-filterable"><code>purescript-filterable</code></a>.</p>
<h2><a class="header" href="#compactable" id="compactable">Compactable</a></h2>
<p><a href="https://pursuit.purescript.org/packages/purescript-filterable/docs/Data.Compactable#t:Compactable"><code>Compactable</code></a></p>
<pre><code class="language-haskell">class Compactable f where
  compact :: forall a.    f (Maybe a)    -&gt;           f a

  separate :: forall l r. f (Either l r) -&gt; { left :: f l, right :: f r }
</code></pre>
<p><a href="https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:catMaybes"><code>catMaybes</code></a> is a function that removes all <code>Nothing</code>s in an <code>Array</code>. <code>compact</code> and <code>separate</code> generalize this idea to work across more <code>f</code> types and works for both <code>Maybe</code> and <code>Either</code>:</p>
<pre><code class="language-haskell">catMaybes [Just 1, Nothing] == [1]

compact [Just 1, Nothing] == [1]
compact (Just 1 : Just 2 : Nothing : Nil) == 1 : 2 : Nil

separate [Left 1, Left 2, Right 3, Right 4] == { left: [1, 2], right: [3, 4] }
</code></pre>
<h2><a class="header" href="#filterable" id="filterable">Filterable</a></h2>
<p><a href="https://pursuit.purescript.org/packages/purescript-filterable/docs/Data.Filterable#t:Filterable"><code>Filterable</code></a> generalizes the concept of <a href="https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:filter"><code>Array.filter</code></a> and <a href="https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:partition"><code>Array.partition</code></a> to work arcross more <code>f</code> types.</p>
<pre><code class="language-haskell">class (Compactable f, Functor f) &lt;= Filterable f where
  filter :: forall a.
    (a -&gt; Boolean)    -&gt; f a -&gt;         f a

  filterMap :: forall a b.
    (a -&gt; Maybe b)    -&gt; f a -&gt;         f b

  partition :: forall a.
    (a -&gt; Boolean)    -&gt; f a -&gt; { no :: f a, yes :: f a }

  partitionMap :: forall a l r.
    (a -&gt; Either l r) -&gt; f a -&gt; { left :: f l, right :: f r }
</code></pre>
<h2><a class="header" href="#witherable" id="witherable">Witherable</a></h2>
<p><a href="https://pursuit.purescript.org/packages/purescript-filterable/docs/Data.Witherable"><code>Witherable</code></a> is the same as <code>Traversable</code>'s <code>traverse</code> but either removes the resulting <code>Nothing</code>s like <code>compact</code> or distinguishes the <code>Left</code>s and the <code>Rights</code> like <code>separate</code>.</p>
<pre><code class="language-haskell">-- traverse :: forall a b m. Applicative m =&gt;
--  (a -&gt; m b           ) -&gt; t a -&gt; m          (t b)

class (Filterable t, Traversable t) &lt;= Witherable t where
  wither :: forall m a b. Applicative m =&gt;
    (a -&gt; m (Maybe b)   ) -&gt; t a -&gt; m          (t b)

  wilt :: forall m a l r. Applicative m =&gt;
    (a -&gt; m (Either l r)) -&gt; t a -&gt; m { left :: t l, right :: t r }
</code></pre>
<p>Its derived functions, <code>wilted</code> and <code>withered</code>, use <code>sequence</code> instead of <code>traverse</code>.</p>
<pre><code class="language-haskell">-- sequence :: forall a m. Applicative m =&gt;
--  t (m a           ) -&gt; m          (t a)

withered :: forall t m x. Witherable t =&gt; Applicative m =&gt;
    t (m (Maybe x)   ) -&gt; m          (t x)

wilted :: forall t m l r. Witherable t =&gt; Applicative m =&gt;
    t (m (Either l r)) -&gt; m { left :: t l, right :: t r }
</code></pre>
<h1><a class="header" href="#unfoldable" id="unfoldable">Unfoldable</a></h1>
<h2><a class="header" href="#usage-7" id="usage-7">Usage</a></h2>
<p>Plain English names:</p>
<ul>
<li>Generator</li>
<li>FP version of a generic &quot;while&quot; loop</li>
</ul>
<pre><code>  Given
    a function, `f`,
      that uses the next `b` value to generate
        either the case that ends the while loop, `Nothing`
        or the case that continues the while loop, `Just`
          which wraps a `Tuple` so that it can return
            the first or next value, `a`, that gets &quot;put into&quot; the `t` container
              and
            the next `b` value that is then used by `f`
              to run the next iteration in the loop
  and
    the first `b` value
return a container/collection, `t`, that stores all the `a` values
  that were generated by the `f` function,
    which may &quot;contain&quot; 0 or many `a` values.
</code></pre>
<p>It enables:</p>
<ul>
<li>a way to generate a <code>List</code> of <code>Ints</code>s where each <code>Int</code> in the <code>List</code> is one greater than the previous <code>Int</code></li>
<li>a way to run the same <code>Effect</code>/<code>Aff</code> computation multiple times until a given condition is true</li>
</ul>
<h2><a class="header" href="#definition-8" id="definition-8">Definition</a></h2>
<h3><a class="header" href="#code-definition-1" id="code-definition-1">Code Definition</a></h3>
<p>Don't look at its docs until after looking at the visual overview in the next section: <a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable#t:Unfoldable">Unfoldable</a></p>
<pre><code class="language-haskell">-- We'll ignore the `Unfoldable1` superclass for now..
class Unfoldable1 t &lt;= Unfoldable t where
  unfoldr :: forall a b. (b -&gt; Maybe (Tuple a b)) -&gt; b -&gt; t a
</code></pre>
<h3><a class="header" href="#visual-overview-2" id="visual-overview-2">Visual Overview</a></h3>
<p><img src="content/21-Hello-World/04-Collections-and-Loops/src/../assets/unfoldable-visualized.svg" alt="unfoldable-visaulized" title="Unfoldable Visualized" /></p>
<h3><a class="header" href="#examples-3" id="examples-3">Examples</a></h3>
<p>We'll implement an instance for <code>List a</code>.</p>
<h4><a class="header" href="#lists-instance-1" id="lists-instance-1"><code>List</code>'s Instance</a></h4>
<pre><code class="language-haskell">data List a = Nil | Cons a

instance Unfoldable List where
  unfoldr :: forall a b. (b -&gt; Maybe (Tuple a b)) -&gt; b -&gt; List a
  unfoldr f initialB = case f initialB of
    Nothing -&gt; Nil
    Just (Tuple a nextB) -&gt; Cons a (unfoldr f nextB)
</code></pre>
<h2><a class="header" href="#laws-8" id="laws-8">Laws</a></h2>
<p>None</p>
<h2><a class="header" href="#derived-functions-7" id="derived-functions-7">Derived Functions</a></h2>
<h3><a class="header" href="#overview-of-possible-functions-for-f" id="overview-of-possible-functions-for-f">Overview of Possible Functions for <code>f</code></a></h3>
<p>The only part of <code>unfoldr f initialB</code> we can hard-code in a derived function is the <code>f</code> function. There are three different functions we could use for <code>f</code>:</p>
<pre><code class="language-haskell">-- We'll use this type alias in the next couple of sections
type UnfoldrFunction a b = b -&gt; Maybe Tuple a b

-- case 1
alwaysReturnJust :: forall a b. a -&gt; b -&gt; UnfoldrFunction a b
alwaysReturnJust a b = \initialB -&gt; Just (Tuple a b)

-- case 2
alwaysReturnNothing :: forall a b. UnfoldrFunction a b
alwaysReturnNothing _ = Nothing

-- case 3
itDepends :: forall a b. UnfoldrFunction a b
itDepends = -- possibilities are shown later
</code></pre>
<table><thead><tr><th>Case Name</th><th>Derived Function Name</th><th>Result</th></tr></thead><tbody>
<tr><td>case 1</td><td>!!!  !!!</td><td><strong>Runtime Error: Infinite loop!</strong></td></tr>
<tr><td>case 2</td><td><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable#v:none"><code>none</code></a></td><td>Produces an empty <code>t</code></td></tr>
<tr><td>case 3</td><td><code>replicate</code>, <code>replicateA</code>, and <code>fromMaybe</code></td><td>see below overviews of each function</td></tr>
</tbody></table>
<p>Case 1 functions always produce a runtime error due to creating an infinite loop. They will appear in two ways:</p>
<pre><code class="language-haskell">-- obvious because Just is always returned
example1 = unfoldr (const Just (Tuple 0 0)) 0

-- Not as obvious in situations where
-- there are a lot of possible conditions
example2 =
  unfoldr f 0
  where
  f nextB
    | nextB &lt; 0  = Just (Tuple 1 2)
    | nextB &gt; 0  = Just (Tuple 2 -4)
    | nextB == 0 = Just (Tuple 8 4)
    | otherwise  = Nothing
      -- ^ this case never occurs
</code></pre>
<h3><a class="header" href="#case-3-functions" id="case-3-functions">Case 3 Functions</a></h3>
<h4><a class="header" href="#using-a-countdown-or-countup-function-to-do-something-n-many-times" id="using-a-countdown-or-countup-function-to-do-something-n-many-times">Using a countdown or countup function to do something <code>n</code>-many times</a></h4>
<pre><code class="language-haskell">countUp :: forall a. Int -&gt; UnfoldrFunction a Int
countUp limit = \nextInt -&gt;
  if nextInt &gt;= limit then Nothing
  else Just (Tuple aValue (nextInt + 1))

countDown :: forall a. UnfoldrFunction a Int
countDown = \nextInt -&gt;
  if nextInt &lt;= 0 then Nothing
  else Just (Tuple aValue (nextInt - 1))
</code></pre>
<p>These kinds of functions are used in the following derived functions:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable#v:replicate"><code>replicate</code></a> - Add the same <code>a</code> value to a <code>t</code> container <code>x</code> number of times.</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable#v:replicate"><code>replicateA</code></a> - Run the same applicative-based computation <code>x</code> number of times and store their results in the <code>t</code> container.</li>
</ul>
<h4><a class="header" href="#converting-a-maybe-into-another-type-that-has-an-unfoldable-instance" id="converting-a-maybe-into-another-type-that-has-an-unfoldable-instance">Converting a <code>Maybe</code> into another type that has an <code>Unfoldable</code> instance</a></h4>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable#v:fromMaybe"><code>fromMaybe</code></a></li>
</ul>
<h1><a class="header" href="#unfoldable1" id="unfoldable1">Unfoldable1</a></h1>
<p>This is the same as <code>Unfoldable</code> except the returned <code>t</code> value must always have at least 1 <code>a</code> value. As a result, it's actually harder to find a data type that can <strong>only</strong> implement <code>Unfoldable1</code> but can't implement <code>Unfoldable</code>.</p>
<h2><a class="header" href="#definition-9" id="definition-9">Definition</a></h2>
<h3><a class="header" href="#code-definition-2" id="code-definition-2">Code Definition</a></h3>
<pre><code class="language-haskell">class Unfoldable1 t where
  unfoldr1 :: forall a b. (b -&gt; Tuple a (Maybe b)) -&gt; b -&gt; t a
</code></pre>
<p>The only difference between <code>Unfoldable</code> and <code>Unfoldable1</code> is the type signature for <code>f</code>. In both cases, the <code>b</code> value is inside of a <code>Maybe</code>:</p>
<pre><code class="language-haskell">-- Unfoldable
f :: forall a b. b -&gt; Maybe (Tuple a b)

-- Unfoldable1
f :: forall a b. b -&gt; Tuple a (Maybe b)
</code></pre>
<h2><a class="header" href="#laws-9" id="laws-9">Laws</a></h2>
<p>None</p>
<h2><a class="header" href="#derived-functions-8" id="derived-functions-8">Derived Functions</a></h2>
<h3><a class="header" href="#parallels-to-unfoldable" id="parallels-to-unfoldable">Parallels to <code>Unfoldable</code></a></h3>
<table><thead><tr><th>Concept</th><th>Unfoldable<br>(<code>t</code> can be empty)</th><th>Unfoldable1<br>(<code>t</code> can't be empty)</th></tr></thead><tbody>
<tr><td>Produce a <code>t</code> value</td><td><code>none</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable1#v:singleton"><code>singleton</code></a></td></tr>
<tr><td>Add an <code>a</code> <code>n</code>-many times to a <code>t</code> container</td><td><code>replicate</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable1#v:replicate1"><code>replicate1</code></a></td></tr>
<tr><td>Run an applicative-based computation <code>n</code>-many times and store the results in a <code>t</code> container</td><td><code>replicateA</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/docs/Data.Unfoldable1#v:replicate1A"><code>replicate1A</code></a></td></tr>
<tr><td>Convert <code>Maybe a</code> to <code>t a</code></td><td><code>fromMaybe</code></td><td>possible, but not implemented</td></tr>
</tbody></table>
<p><code>Unfoldable1</code> does not have a version of <code>fromMaybe</code> included, but I believe it is possible if one places a <code>Monoid</code> constraint on <code>a</code> and uses <code>mempty</code> when receiving a <code>Nothing</code> case.</p>
<h3><a class="header" href="#specific-to-unfoldable1" id="specific-to-unfoldable1">Specific to <code>Unfoldable1</code></a></h3>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-unfoldable/4.1.0/docs/Data.Unfoldable1#v:range"><code>range</code></a></li>
</ul>
<h1><a class="header" href="#closing-thoughts" id="closing-thoughts">Closing Thoughts</a></h1>
<h2><a class="header" href="#stack-safe-recursive-functions" id="stack-safe-recursive-functions">Stack-Safe Recursive Functions</a></h2>
<p>At this point, you should read through the <code>Design Patterns/Stack Safety.md</code> file. That file covers the two other kinds of loops: recursive loops and <code>Effect</code>-based loops like <code>whileE</code>, <code>forE</code>, and <code>untilE</code>.</p>
<h2><a class="header" href="#when-to-use-it-array-vs-list" id="when-to-use-it-array-vs-list">When to Use It? Array vs List</a></h2>
<blockquote>
<p>Hello. When should I use Array and when List?</p>
</blockquote>
<blockquote>
<p>It depends on which operations you want to do. Any update on an array is <code>(n)</code> but random lookup is <code>O(1)</code>. Lists have efficient operations at the front, and everything else is <code>O(n)</code>. Array updates copy all other elements, resulting in twice the memory usage, while for most list operations the result and the source share part of the list. However, lists use a less compact layout in memory.</p>
<p>Rules of thumb: if you create the sequence once and read it many times, use an array. Folds over arrays are faster, length is constant time and lookup is constant time. If you want to constantly manipulate the structure, especially at the front, use a list.</p>
<p>If your number of elements is very small (i.e. <code>n</code> is bounded), try both and measure. Array might in many cases be faster for few elements, even with random updates. Mostly because cloning of arrays is implemented directly in V8, whereas rebuilding lists is done with many many PureScript operations.</p>
</blockquote>
<p>See <a href="https://discourse.purescript.org/t/typeclass-abstraction-to-use-for-data-structures/479">Typeclass abstractions to use for data structures</a>. For algebraic graphs, consider using <a href="https://github.com/thomashoneyman/purescript-alga"><code>purescript-alga</code></a>.</p>
<h1><a class="header" href="#application-structure" id="application-structure">Application Structure</a></h1>
<p>Prerequisites:</p>
<ul>
<li>You should understand what &quot;smart constructors&quot; are (see <code>Design Patterns</code> folder) and how they work</li>
</ul>
<p>The upcoming folders will explain</p>
<ul>
<li>a small explanation on the onion architecture / 3-Layer Haskell Cake concepts</li>
<li>an overview of what MTL and Free/Run are and how they work conceptually</li>
<li>how to structure an FP program via MTL and Free/Run</li>
<li><strong>folders starting with <code>1</code> contain heavily-commented examples of basic programs using these application architecture styles.</strong> When learning one particular style, you should look at these programs for what an 'end-result' looks like using that style as well as how it compares to other styles. We'll start with the simplest &quot;hello world&quot; program that uses only one effect and write programs that use more and more effects/capabilities.</li>
</ul>
<p>These will later be used to write programs in the <code>Projects</code> folder that run in Node via the console and/or in the Browser via Halogen.</p>
<p>In the functional paradigm, programs are structured in such a way that they look very similar to something called the &quot;onion architecture.&quot; <strong>The below videos are optional watching.</strong> Watch them for a clearer idea of what &quot;onion architecture&quot; is:</p>
<ul>
<li><a href="https://www.youtube.com/embed/R2pW09tMCnE?start=6&amp;end=527">A Quick Introduction to Onion Architecture</a></li>
<li><a href="https://www.youtube.com/watch?v=pL9XeNjy_z4">Domain-Driven Design through Onion Architecture</a></li>
</ul>
<p>Another optional video to watch: <a href="https://www.youtube.com/watch?v=US8QG9I1XW0">Functional Architecture - The Pits of Success</a>. It explains that FP naturally pushes developers towards this architecture whereas other languages push developers away from it.</p>
<p>When we structure our code according to the below table, it provides a number of benefits</p>
<ul>
<li>top-down domain-driven design: your data types and your function's type signatures are often your always-up-to-date documentation</li>
<li>&quot;impure&quot; computations (i.e. computations that do things like state manipulation, reading from a file, network activities) are expressed as a &quot;pure&quot; computation, making them much easier to test</li>
<li>&quot;Platforms&quot; (i.e. frameworks, databases, etc.) can easily be swapped out with other newer platforms without changing any &quot;business logic&quot; code or potentially introducing regressions</li>
</ul>
<table><thead><tr><th>Layer Level</th><th>Onion Architecture Term</th><th>General idea</th></tr></thead><tbody>
<tr><td>Layer 4</td><td>Core</td><td>Strong types with well-defined properties and their pure, total functions that operate on them</td></tr>
<tr><td>Layer 3</td><td>Domain</td><td>the &quot;business logic&quot; code which uses &quot;effects,&quot; impure computations that are expressed in a pure way</td></tr>
<tr><td>Layer 2</td><td>API</td><td>the &quot;production&quot; or &quot;test&quot; monad which &quot;links&quot; these pure effects/capabilties to their impure implementations</td></tr>
<tr><td>Layer 1</td><td>Infrastructure</td><td>the platform-specific framework/libraries we'll use to implement some special effects/capabilities (i.e. <code>Node.ReadLine</code> (terminal-based programs), <code>Halogen</code>/<code>React</code> (web-based UIs))</td></tr>
<tr><td>Layer 0</td><td>Machine Code<br>(no equivalent onion term)</td><td>the &quot;base&quot; monad that runs the program (e.g. production: <code>Effect</code>/<code>Aff</code>; test: <code>Identity</code>/<code>Trampoline</code>)</td></tr>
</tbody></table>
<p>To get a general idea for the concept this folder is going to try to teach:</p>
<ul>
<li>Watch the second half of <a href="https://youtu.be/GlUcCPmH8wI?t=1977">Code Reuse in PureScript: Functions, Type Classes, and Interpreters</a> and focus on the following section:
<ul>
<li>'Which code is more reusable' (45:28 - 50:29):
<ul>
<li>Final Encoding = Provide an implementation as an argument = monad transformers (what we cover first in this folder)</li>
<li>Initial Encoding = Interpret a result = <code>Free</code> monad (what we cover second in this folder)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Another learning resource that is still a work-in-progress but which will explain more than this work is 'Functional Design and Architecture':</p>
<ul>
<li><a href="https://np.reddit.com/r/haskell/comments/avaxda/the_campaign_for_my_book_functional_design_and/?st=jsowhkm4&amp;sh=d2be89c4">Reddit post introducing it</a></li>
<li><a href="https://docs.google.com/document/d/1bh9Sa0rIGzU9Z88N_TJF6BtgHD_QLYdh1nK-yLKn_IU/edit">Its current Table of Contents</a></li>
</ul>
<h2><a class="header" href="#a-word-of-thanks" id="a-word-of-thanks">A Word of Thanks</a></h2>
<p>While trying to learn this myself, I benefited from looking at the code in stepchownfun's BSD-3 licensed project, <a href="https://github.com/stepchowfun/effects"><code>effects</code></a>, as a guide when I did not completely understand something myself.</p>
<h1><a class="header" href="#00-a-bad-programpurs" id="00-a-bad-programpurs">00-A-Bad-Program.purs</a></h1>
<pre><code class="language-haskell">module BadProgram where

import Prelude

import Effect (Effect)
import Effect.Console (log)
import Effect.Random (randomInt)

main :: Effect Unit
main = do
  log &quot;This is an example of a program that is written in an FP language, \
      \but which is terribly structured. Why? Because it's impossible to test \
      \or otherwise prove that the code works correctly. All of its pure \
      \business logic is intermixed with impure code that makes the \
      \program work.&quot;

  initialState &lt;- randomInt 10 20
  int2 &lt;- randomInt 5 20
  int3 &lt;- randomInt 5 30

  let nextState = initialState + int2 * int3 / initialState

  int4 &lt;- randomInt 200 900
  int5 &lt;- randomInt 45 80
  int6 &lt;- randomInt 2 3

  let finalState = nextState * int6 * int5 - int4 + initialState

  log $ &quot;The final output of the program was: &quot; &lt;&gt; show finalState

{-
There's a few issues with this program as it is currently written:

First, it's hard to test. How would you test this program to ensure
    it works properly?

Maybe we want to guarantee that the code will always produce
    a value that is even. Since all of our functions (i.e. the stuff
    we do before storing the next state) receive random integers,
    how could we ensure these functions are defined correctly?

Second, this program does not tell us whether an error can occur
    and, if so, where such an error would appear.

Third, what if we wanted to use a different random number generator
    than the one provided via `Effect.Random (randomInt)`? Let's say
    the first time we run the program, we do want to use 'randomInt.'
    If so, then this works. However, let's say the next time we run
    this program, we want it to use something more complex. Well,
    we don't have an easy way to quickly swap out a random number generator
    without changing our business logic.

Such problems as these will be fixed/improved if we structure our FP
programs using Modern FP Architecture that is covered in this folder.
-}
</code></pre>
<h1><a class="header" href="#monads-effects-and-capabilities" id="monads-effects-and-capabilities">Monads, Effects, and Capabilities</a></h1>
<p>Monads represent sequential computation via <code>bind</code>/<code>&gt;&gt;=</code>: &quot;do X, and once finished, do Y&quot;. In our previous example/explanation from <code>Hello World/Prelude/Control-Flow/How the Computer Executes FP Programs.md</code>, we implied that <code>Box</code> could be used to &quot;compute&quot; something. In that example, however, it merely acted as a wrapper around values and functions. When we covered <code>Effect</code> and <code>Aff</code> in their respective folder, we saw that conceptually they operated very similar to <code>Box</code>.</p>
<p>Still, our <code>Box</code>/<code>Effect</code>/<code>Aff</code> examples did not make it clear how <code>Monad</code>s could be a &quot;computation.&quot; While <code>bind</code>/<code>&gt;&gt;=</code> insures that one computation occurs before another (i.e. sequential computation), it does not define what kinds of computation are done. Thus, we must explain what &quot;effects&quot;/&quot;capabilities&quot; are.</p>
<p>For the rest of this folder, we'll use the terms, &quot;effects&quot; and &quot;capabilties,&quot; interchangeably. Lowercased &quot;effect&quot; refers to something different than the <code>Effect</code> monad.</p>
<h2><a class="header" href="#effects--capabilities" id="effects--capabilities">Effects / Capabilities</a></h2>
<p>To understand what we mean by &quot;effects&quot; (and due to license-related things), read through the first two sentences of <a href="https://ocharles.org.uk/posts/2016-01-26-transformers-free-monads-mtl-laws.html">Monad transformers, free monads, mtl, laws and a new approach</a>, then continue reading this page.</p>
<h3><a class="header" href="#examples-of-effects--capabilities" id="examples-of-effects--capabilities">Examples of Effects / Capabilities</a></h3>
<p>Capabilities can be grouped together into type class functions that define computations which <code>bind</code> executes in a sequential manner. These type classes are specialized; they are designed to do one thing very very well.</p>
<p>So what kind of &quot;capabilities&quot; can we have? Let's now give some examples via the table below:</p>
<table><thead><tr><th>When we want a type of computation (effect) that...</th><th>... we expect to use functions named something like ...</th><th>... which are best abstracted together in a type class called...</th></tr></thead><tbody>
<tr><td>Provides for later usage a read-only value/function that may change between different program runs<br>(e.g. &quot;settings&quot; values; dependency injection)</td><td><ul><li><code>getSettingValue</code></li><li><code>getConfigValueStoredOnFile</code></li><li><code>getNumberOfPlayersInGame</code></li></ul></td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Reader.Class#t:MonadAsk"><code>MonadAsk</code></a></td></tr>
<tr><td>Modifies the state of a data structure<br>(e.g. changing the nth value in a list)</td><td><ul><li><code>pop stack</code></li><li><code>replaceAt index treeOfStrings &quot;some value&quot;</code></li><li><code>(\int -&gt; int + 1)</code></li></ul></td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#t:MonadState"><code>MonadState</code></a></td></tr>
<tr><td>Returns a computation's output and additional data that is generated during the computation</td><td><ul><li><a href="https://stackoverflow.com/a/27651976">See this SO answer</a></li><li><a href="https://www.reddit.com/r/haskell/comments/3faa02/what_are_some_real_world_uses_of_writer/">See this Reddit thread</a></li></ul></td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Writer.Class#t:MonadTell"><code>MonadTell</code></a></td></tr>
<tr><td>Stops computation because of a possible error<br>(e.g. &quot;file does not exist&quot;)</td><td>--</td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Error.Class#t:MonadThrow"><code>MonadThrow</code></a></td></tr>
<tr><td>Deals with &quot;callback hell&quot;<br>(e.g. <a href="http://www.thev.net/PaulLiu/invert-inversion.html">de-invert inversion of control</a>)</td><td>--</td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Cont.Class#t:MonadCont"><code>MonadCont</code></a></td></tr>
</tbody></table>
<table><thead><tr><th>When we want to extend the functionality of...</th><th>... with the ability to...</th><th>... we can use its extension type class called...</th></tr></thead><tbody>
<tr><td>MonadAsk</td><td>Modify the read-only value for one computation<br>(e.g. <code>makeFontSizeMoreAccessible getFontSize displayPage</code>)</td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Reader.Class#t:MonadReader"><code>MonadReader</code></a></td></tr>
<tr><td>MonadTell</td><td>Modify or use the additional non-output data before completing a computation</td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Writer.Class#t:MonadWriter"><code>MonadWriter</code></a></td></tr>
<tr><td>MonadThrow</td><td>Catch and handle the error that was thrown<br>(e.g. create the missing file)</td><td><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Error.Class#t:MonadError"><code>MonadError</code></a></td></tr>
</tbody></table>
<h2><a class="header" href="#modeling-effects" id="modeling-effects">Modeling Effects</a></h2>
<p>In this folder, we'll only cover <code>MTL</code>/<code>ReaderT Design Pattern</code> and <code>Free</code>/<code>Run</code>. The article to which we referred above overviews more ideas, but that is not our current focus. It might be worth returning to it after one has read through the rest of this folder.</p>
<h3><a class="header" href="#composing-monads" id="composing-monads">Composing Monads</a></h3>
<p>As we explained previously, <code>bind</code>/<code>&gt;&gt;=</code>'s type signature forces one to only return the same <code>Box</code>-like monad type that is used in bind:</p>
<pre><code class="language-haskell">bind :: forall a. f   a -&gt; ( a    -&gt; f   b)           -&gt; f    b
bind :: forall a. Box a -&gt; ( a    -&gt; Box b         )  -&gt; Box  b
bind             (Box 4)   (\four -&gt; Box (show four)) == Box &quot;4&quot;
</code></pre>
<p><strong>In other words, if we use one monad, we cannot use any other monads.</strong> So, how do we get around this limitation?</p>
<p>We saw the same problem earlier when we wanted to run an <code>Effect</code> monad inside of an <code>Aff</code> monad. We fixed it by &quot;lifting&quot; the <code>Effect</code> monad into the <code>Aff</code> monad via a <a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.NaturalTransformation#t:NaturalTransformation"><code>NaturalTransformation</code></a>/<code>~&gt;</code>. This was abstracted into a type class specific for <code>Effect ~&gt; someOtherMonad</code> in <a href="https://pursuit.purescript.org/packages/purescript-effect/2.0.0/docs/Effect.Class#t:MonadEffect"><code>MonadEffect</code></a>.</p>
<p><code>MTL</code> and <code>Free</code> use different approaches to solving this problem and its solution is what creates the Onion Architecture-like idea we mentioned before. As we saw earlier in Nate's video in this folder's ReadMe, <code>mtl</code> is the &quot;Final Encoding&quot; style and <code>Free</code>/<code>Run</code> is the &quot;Initial Encoding&quot; style.</p>
<p><strong>The following ideas are quick overviews of each approach. Their terminology and exact details will be explained in their upcoming folder. It is not meant to be clearly understandable at first.</strong></p>
<h4><a class="header" href="#mtl-approach" id="mtl-approach">MTL Approach</a></h4>
<p><strong>Monad Transformers</strong> are thus named because they &quot;transform&quot; some other monad by augmenting it with additional functions. One monad (e.g. <code>Box</code>) can only use <code>bind</code> and <code>pure</code> to do sequential computation. However, we can &quot;transform&quot; <code>Box</code>, so that it now has state-manipulating functions like <code>get</code>/<code>set</code>/<code>modify</code>. &quot;MTL&quot; refers to the original &quot;Monad Transformers Library&quot; (I believe).</p>
<p>In the <code>MTL</code>-approach, one models the above effects using functions (we'll show how later). Since monad transformers augment some &quot;base&quot; monad, it creates a stack-like picture (read from bottom to top):</p>
<pre><code>BaseMonad
      ^
      | augments
      |
Pure MonadState
</code></pre>
<p>Since each function is a different monadic type, they cannot be used within the same monadic context in <code>do notation</code>. Thus, one gets around this monad-composition problem by creating a &quot;stack&quot; of nested monad transformers (i.e. functions). Following the previous idea, we can define <strong>something similar to</strong> a <code>NaturalTransformation</code> that &quot;lifts&quot; the effects of one monadic function (e.g. a function that implements <code>MonadReader</code>) into another monadic function (e.g. a function that implements <code>MonadState</code>), which augments the base monad. Using a visual, it produces this diagram (read from bottom to top):</p>
<pre><code>BaseMonad
      ^
      | augments
      |
Pure MonadState_TargetMonad
      ^
      | gets lifted into
      |
Pure MonadReader_SourceMonad
</code></pre>
<p>Generalizing this idea, we must ultimately create a &quot;stack&quot; of these function-based monad-transformers. Using a visual, it produces this diagram (read from bottom to top):</p>
<pre><code>BaseMonad
      ^
      | augments
      |
Pure MonadState
      ^
      | gets lifted into
      |
Pure MonadWriter
      ^
      | gets lifted into
      |
Pure MonadReader
</code></pre>
<p>This idea is at the heart of the type class called <code>MonadTrans</code>. Again, you should feel somewhat confused right now and a bit overwhelmed. However, we'll refer to these ideas later to help explain why we make some of the design choices that we do. By the end of this folder, this will all make sense.</p>
<h4><a class="header" href="#free" id="free">Free</a></h4>
<p>In the <code>Free</code>-approach, one models the above effects using data structures (again, we'll show how later). Essentially, one uses domain-specific languages (DSLs) created via data structures to define an Abstract Syntax Tree (AST). Such trees describe computations but do not run them. Later on, an AST is &quot;interpreted&quot; (via a <code>NaturalTransformation</code>/<code>~&gt;</code>) into a final base monad that actually runs the computation. Using a visual, it produces this diagram (read top to bottom):</p>
<pre><code>Pure High-Level Language
      |
      | gets interpreted into
      |
     \ /
Base Monad
</code></pre>
<p>Due to how interpreters work, one can define high-level ASTs that are interpreted into lower-level ASTs before being run by a base monad. Using a visual, it produces this diagram (read from bottom to top):</p>
<pre><code>Pure AST via High-Level Language
      |
      | gets interpreted into
      |
     \ /
Pure AST via Medium-Level Language
      |
      | gets interpreted into
      |
     \ /
Pure AST via Low-Level Language
      |
      | gets interpreted into
      |
     \ /
Base Monad
</code></pre>
<h1><a class="header" href="#mtl" id="mtl">MTL</a></h1>
<p>This folder does 5 things:</p>
<ul>
<li>walks the reader through the <code>Function</code> monad and how to read its <code>do notation</code> and how functions can become monad transformers. At the end, we'll describe the whole point of using monad transformers.</li>
<li>walks the reader through the problems that led us to define the <code>MonadState</code> type class and explains why its function's type signature is defined that way. We'll use this idea to teach the general idea behind all the other monad transformers</li>
<li>overviews each monad transformer</li>
<li>explains what problem <code>MonadTrans</code> solves and how the 'monad transformer stack' works</li>
<li>explains the limitations of monad transformers</li>
<li>overviews the <code>ReaderT design pattern</code>. At the end, we'll clarify when to use &quot;monad stacks&quot; and when to use the <code>ReaderT design pattern</code>.</li>
</ul>
<h2><a class="header" href="#explaining-the-name" id="explaining-the-name">Explaining the Name</a></h2>
<p><strong>Monad Transformers</strong> are thus named because they &quot;transform&quot; some other monad by augmenting it with additional capabilities. One monad (e.g. <code>Box</code>) can only use <code>bind</code> and <code>pure</code> to do sequential computation. However, we can &quot;transform&quot; <code>Box</code>, so that it now has state-manipulating functions like <code>get</code>/<code>set</code>/<code>modify</code>. Purescript has defined all of these in the library called <code>purescript-transformers</code>.</p>
<h1><a class="header" href="#foundations" id="foundations">Foundations</a></h1>
<p>Many people find it very difficult to understand how Monad Transformers actually work. I believe it's because new learners are exposed to too many new things at once, so that they get overwhelemed and likely don't understand why they don't understand.</p>
<p>Rather than jumping into an explanation of what monad transformers are, I'm going to build the necessary scaffolding to make understanding them easier. At the very end, I'll begin to show what problem they solve.</p>
<p>In short, monad transformers make it easier to adhere to the Onion Architecture, so that one can easily test and run their business logic by swapping out the &quot;infrastructure&quot; used. For example, my random number game can use the Terminal environment to allow the player to input their guesses when I am actually running the program. If I want to test my program's business logic, I can &quot;simulate&quot; the user's guesses in a test environment.</p>
<p>In both cases, the same business logic is used, and adjusting it will affect both the real-world use of it and the tests. In other words, there is no 'syncing' problem here between the real business logic that runs my code and the business logic I test.</p>
<h2><a class="header" href="#folders-contents-1" id="folders-contents-1">Folder's Contents</a></h2>
<p>In this folder, we'll show that a <code>Function</code> can be a Monad and then show how to convert it into a Monad Transformer.</p>
<p>At the very end, we'll summarize why monad transformers are useful and give an overview of how they work.</p>
<h1><a class="header" href="#the-function-monad" id="the-function-monad">The Function Monad</a></h1>
<h2><a class="header" href="#a-refresher-on-monads" id="a-refresher-on-monads">A Refresher on Monads</a></h2>
<p>Via the <code>Box</code> type, we originally learned what a <code>Monad</code> even is. To refresh our memory, a data type can be called a <code>Monad</code> if it can implement a law-abiding instance for the <code>Monad</code> type class. We then used the <code>Box</code> type to introduce &quot;do notation,&quot; which desugars into nested <code>bind</code>/<code>&gt;&gt;=</code> calls.</p>
<p>We later showed that using other monadic types like <code>Maybe</code>, <code>Either</code>, and <code>List</code> led to different control flows. <code>Maybe</code> led to a nested if-then-else statement. <code>Either</code> was similar but returned something when an error occurred. <code>List</code> produced a nested <code>for</code> loop.</p>
<p>However, we never stopped to consider the data type, <code>Function</code>. When we re-examine the <code>Function</code> data type, we'll see that it's naturally a <code>Monad</code>.</p>
<h2><a class="header" href="#reviewing-function-as-a-data-type" id="reviewing-function-as-a-data-type">Reviewing <code>Function</code> as a Data Type</a></h2>
<p>Putting it into syntax, <code>Function</code> is defined like this:</p>
<pre><code class="language-haskell">data Function a b = -- implementation

infix ? Function as -&gt;

-- Thus, when we write this:
intToString :: Int -&gt; String
intToString _ = &quot;a string&quot;

-- It desguars to this:
intToString :: Function Int String
intToString _ = &quot;a string&quot;
</code></pre>
<h2><a class="header" href="#implementing-the-monad-type-class-hierarchys-functions" id="implementing-the-monad-type-class-hierarchys-functions">Implementing the <code>Monad</code> Type Class Hierarchy's Functions</a></h2>
<p>Let's start implement instances for these type classes. For now, take my word for it that these implementations satisfy the laws of their respective type classes.</p>
<h3><a class="header" href="#functor" id="functor">Functor</a></h3>
<h4><a class="header" href="#initial-problems" id="initial-problems">Initial Problems</a></h4>
<p>Let's look at <code>Functor</code>. It's type signature looks like this.</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>This creates the first problem: <code>Functor</code> expects a higher-kinded type, <code>f</code>, that only takes one type. For example, <code>Box a</code> only takes one type. However, <code>Function a b</code> takes two types. So, how can this be resolved? We must assume that <code>Function a b</code> already has its first type. For example...</p>
<pre><code class="language-haskell">data Function a b = -- implementation

noTypesDefined :: forall a b. Function a   b
noTypesDefined = -- implementation

oneTypeDefined :: forall   b. Function Int b
oneTypeDefined = -- implementation

allTypesDefined ::            Function Int Int
allTypesDefined = -- implementation
</code></pre>
<p>To make <code>Function</code> higher-kinded by only one type, and not two, we should use something like <code>oneTypeDefined</code> above:</p>
<pre><code class="language-haskell">class Functor (Function inputType) where
</code></pre>
<h4><a class="header" href="#implementing-map" id="implementing-map">Implementing <code>map</code></a></h4>
<p>Getting back to the problem at hand, here's the type signature for Function's <code>map</code> implementation with very helpful names:</p>
<pre><code class="language-haskell">class Functor (Function inputType) where
  map :: forall originalOutputType newOutputType.
         (originalOutputType -&gt; newOutputType) -&gt;
         Function inputType originalOutputType -&gt; Function inputType newOutputType
</code></pre>
<p>It should seem pretty obvious how this gets implemented. Let's walk through this slowly.</p>
<ol>
<li><code>map</code> returns a new function whose input is <code>input</code>. So, let's use an inline function to do that:</li>
</ol>
<pre><code class="language-haskell">class Functor (Function inputType) where
  map :: forall originalOutputType newOutputType.
         (originalOutputType -&gt; newOutputType) -&gt;
         Function inputType originalOutputType -&gt; Function inputType newOutputType
  map originalToNew f = (\input -&gt; {- remaining body of function -} )
</code></pre>
<ol start="2">
<li>Since <code>f</code> is the only function that can &quot;receive&quot; a value of type, <code>input</code>, we have to pass that value into <code>f</code>. <code>f</code> will produce <code>originalOutput</code>, so let's store that in a let binding:</li>
</ol>
<pre><code class="language-haskell">class Functor (Function inputType) where
  map :: forall originalOutputType newOutputType.
         (originalOutputType -&gt; newOutputType) -&gt;
         Function inputType originalOutputType -&gt; Function inputType newOutputType
  map originalToNew f = (\input -&gt;
    let originalOutput = f input
    in {- remaining body of function -} )
</code></pre>
<ol start="3">
<li>Since <code>originalToNew</code> is the only function that can &quot;receive&quot; a value of type, <code>originalOutput</code>, we have to pass the value outputted by <code>f</code> into that function. <code>originalToNew</code> produces a value of the type, <code>newOutput</code>, which gives us the return value of our created function:</li>
</ol>
<pre><code class="language-haskell">class Functor (Function inputType) where
  map :: forall originalOutputType newOutputType.
         (originalOutputType -&gt; newOutputType) -&gt;
         Function inputType originalOutputType -&gt; Function inputType newOutputType
  map originalToNew f = (\input -&gt;
    let originalOutput = f input
    in originalToNew originalOutput)
</code></pre>
<p>As we can see, the types guided us on how to implement this function. If we look at this closer, we can see that it's just function composition.</p>
<pre><code class="language-haskell">class Functor (Function inputType) where
  map :: forall originalOutputType newOutputType.
         (originalOutputType -&gt; newOutputType) -&gt;
         Function inputType originalOutputType -&gt; Function inputType newOutput
  map originalToNew f = (\input -&gt; originalOutput $ f input)
  -- or
  map originalToNew f = (originalOutput &lt;&lt;&lt; f)
  -- or even
  map = (&lt;&lt;&lt;)
</code></pre>
<p>In real code, normally we use <code>a</code>, <code>b</code> as type variable. Therefore, the above snippet will be simplfied to</p>
<pre><code class="language-haskell">class Functor (Function i) where
  map :: forall a b. (a -&gt; b) -&gt; Function i a -&gt; Function i b
  map = (&lt;&lt;&lt;)
</code></pre>
<h4><a class="header" href="#takeaways" id="takeaways">Takeaways</a></h4>
<p>Our first example taught us two things:</p>
<ul>
<li>we have to make <code>Function</code> higher-kinded by one less type by specifying its first type (the input) and let the <code>a</code> and <code>b</code> arguments refer to its second type (the output).</li>
<li>to implmement the instance, we have to create a new function by using lambda syntax: <code>\argument -&gt; body</code></li>
</ul>
<h3><a class="header" href="#apply-2" id="apply-2">Apply</a></h3>
<h4><a class="header" href="#initial-problems-1" id="initial-problems-1">Initial Problems</a></h4>
<p>Let's now look at <code>Apply</code>'s <code>apply</code> function. It's type signature looks like this.</p>
<pre><code class="language-haskell">class (Functor f) &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>Again, let's take this slowly. Notice first the first argument, what should the full type signature of <code>f (a -&gt; b)</code> be if <code>f</code> is <code>Function</code>? Since the <code>f</code> has to be the same for both situations, then <code>f</code> has to be <code>Function input</code>. In other words, the first argument is a function that returns another function:</p>
<pre><code class="language-haskell">class (Functor (Function inputType)) &lt;= Apply (Function inputType) where
  apply :: forall originalOutputType newOutputType.
           Function inputType (originalOutputType -&gt; newOutputType) -&gt;
           Function inputType  originalOutputType -&gt;
           Function inputType  newOutputType
</code></pre>
<h4><a class="header" href="#implementing-apply" id="implementing-apply">Implementing <code>apply</code></a></h4>
<p>Let's see how to implement this function.</p>
<ol>
<li>Since <code>apply</code> returns a new function, let's start creating one using lambda syntax:</li>
</ol>
<pre><code class="language-haskell">class (Functor (Function inputType)) &lt;= Apply (Function inputType) where
  apply :: forall originalOutputType newOutputType.
           Function inputType (originalOutputType -&gt; newOutputType) -&gt;
           Function inputType  originalOutputType -&gt;
           Function inputType  newOutputType
  apply functionInFunction f = (\input -&gt; {- body of function -})
</code></pre>
<ol start="2">
<li>At this point, both <code>f</code> and <code>functionInFunction</code> can receive an value of type, <code>input</code>. For right now, let's do what we did last time and only pass it into <code>f</code>. We'll store the output in a let binding:</li>
</ol>
<pre><code class="language-haskell">class (Functor (Function inputType)) &lt;= Apply (Function inputType) where
  apply :: forall originalOutputType newOutputType.
           Function inputType (originalOutputType -&gt; newOutputType) -&gt;
           Function inputType  originalOutputType -&gt;
           Function inputType  newOutputType
  apply functionInFunction f = (\input -&gt;
    let originalOutput = f input
    in {- body of function -})
</code></pre>
<ol start="3">
<li>At this point, the only way to get map <code>originalOutput</code> into <code>newOutput</code> is to pass it into the function that's hidden in <code>functionInFunction</code>. How do we get that out? We can pass <code>input</code> into that function. Again, we'll store that output in a let binding:</li>
</ol>
<pre><code class="language-haskell">class (Functor (Function inputType)) &lt;= Apply (Function inputType) where
  apply :: forall originalOutputType newOutputType.
           Function inputType (originalOutputType -&gt; newOutputType) -&gt;
           Function inputType  originalOutputType -&gt;
           Function inputType  newOutputType
  apply functionInFunction f = (\input -&gt;
    let
      originalOutput = f input
      originalToNew = functionInFunction input
    in {- body of function -})
</code></pre>
<ol start="4">
<li>We now have all the pieces we need to return <code>newOutput</code>. Let's pass <code>originalOutput</code> into <code>originalTonew</code>:</li>
</ol>
<pre><code class="language-haskell">class (Functor (Function inputType)) &lt;= Apply (Function inputType) where
  apply :: forall originalOutputType newOutputType.
           Function inputType (originalOutputType -&gt; newOutputType) -&gt;
           Function inputType  originalOutputType -&gt;
           Function inputType  newOutputType
  apply functionInFunction f = (\input -&gt;
    let
      originalOutput = f input
      originalToNew = functionInFunction input
    in originalToNew originalOutput)
</code></pre>
<p>Great! Can we clean it up now?</p>
<pre><code class="language-haskell">class (Functor (Function inputType)) &lt;= Apply (Function inputType) where
  apply :: forall originalOutputType newOutputType.
           Function inputType (originalOutputType -&gt; newOutputType) -&gt;
           Function inputType  originalOutputType -&gt;
           Function inputType  newOutputType
  apply functionInFunction f = (\input -&gt; (functionInFunction input) (f input))
</code></pre>
<h4><a class="header" href="#takeaways-1" id="takeaways-1">Takeaways</a></h4>
<p>Our second example taught us the following:</p>
<ul>
<li>to get all the pieces necessary to implement a type class' function, we sometimes need to pass the input value into multiple functions.</li>
</ul>
<h3><a class="header" href="#applicative-1" id="applicative-1">Applicative</a></h3>
<p>Let's now look at <code>Applicative</code>'s <code>pure</code> function. It's type signature looks like this.</p>
<pre><code class="language-haskell">class (Apply f) &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p>Converting <code>f</code> into <code>Function input</code>, we get this type signature:</p>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Applicative (Function inputType) where
  pure :: forall outputType. outputType -&gt; Function inputType outputType
</code></pre>
<p>Let's see how to implement it.</p>
<ol>
<li>Since <code>pure</code> returns a new function, let's start creating one using lambda syntax:</li>
</ol>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Applicative (Function inputType) where
  pure :: forall outputType. outputType -&gt; Function inputType outputType
  pure value = (\input -&gt; {- body of function -})
</code></pre>
<ol start="2">
<li>Since the function must return <code>value</code> as its output, let's ignore the argument and just return that value.</li>
</ol>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Applicative (Function inputType) where
  pure :: forall outputType. outputType -&gt; outputType
  pure value = (\input -&gt; value)
</code></pre>
<p>Let's clean this one up:</p>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Applicative (Function inputType) where
  pure :: forall outputType. outputType -&gt; Function inputType outputType
  pure value = (\_ -&gt; value)
</code></pre>
<h3><a class="header" href="#bind-1" id="bind-1">Bind</a></h3>
<h4><a class="header" href="#implementing-bind" id="implementing-bind">Implementing <code>bind</code></a></h4>
<p>Let's now look at <code>Bind</code>'s <code>bind</code> function. It's type signature looks like this.</p>
<pre><code class="language-haskell">class (Functor m) &lt;= Bind m where
  bind :: forall a b. (a -&gt; m b) -&gt; m a -&gt; m b
</code></pre>
<p>Converting <code>m</code> into <code>Function input</code>, we get this type signature:</p>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
</code></pre>
<p>Let's see how to implement it.</p>
<ol>
<li>Since <code>bind</code> returns a new function, let's start creating one using lambda syntax:</li>
</ol>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutput -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
  bind originalToFunction f = (\input -&gt; {- body of function -})
</code></pre>
<ol start="2">
<li>Since <code>f</code> is the only function that can &quot;receive&quot; the <code>input</code> value, let's pass it into <code>f</code> and store the output:</li>
</ol>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
  bind originalToFunction f = (\input -&gt;
    let originalOutput = f input
    in {- body of function -})
</code></pre>
<ol start="3">
<li>Since <code>originalToFunction</code> can &quot;receive&quot; the <code>originalOutput</code> value, let's pass that into <code>originalToFunction</code> and store its result in a let binding:</li>
</ol>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
  bind originalToFunction f = (\input -&gt;
    let
      originalOutput = f input
      inputToNewOutput = originalToFunction originalOutput
    in {- body of function -})
</code></pre>
<ol start="4">
<li>Since <code>inputToNewOutput</code> is the only function that can produce the <code>newOutput</code> value, let's pass <code>input</code> into it to get that value:</li>
</ol>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
  bind originalToFunction f = (\input -&gt;
    let
      originalOutput = f input
      inputToNewOutput = originalToFunction originalOutput
    in inputToNewOutput input)
</code></pre>
<p>Let's now clean it up. First we'll get rid of that <code>inputToNewOutput</code> binding:</p>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
  bind originalToFunction f = (\input -&gt;
    let
      originalOutput = f input
    in (originalToFunction originalOutput) input)
</code></pre>
<p>Second, we'll get rid of that <code>originalOutput</code> binding:</p>
<pre><code class="language-haskell">class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
  bind originalToFunction f = (\input -&gt; (originalToFunction (f input)) input)
</code></pre>
<p>As can be seen, this example was a slightly more complicated version of <code>apply</code> in that we needed to pass <code>input</code> to multiple functions.</p>
<h2><a class="header" href="#summary-of-our-takeaways" id="summary-of-our-takeaways">Summary of Our Takeaways</a></h2>
<ul>
<li><code>map</code> example:
<ul>
<li>we have to make <code>Function</code> higher-kinded by one less type by specifying its first type (the input) and let the <code>a</code> and <code>b</code> arguments refer to its second type (the output).</li>
<li>to implmement the instance, we have to create a new function by using lambda syntax: <code>\argument -&gt; body</code></li>
</ul>
</li>
<li><code>apply</code>/<code>bind</code> example:
<ul>
<li>to get all the pieces necessary to return the <code>b</code>/<code>newOutput</code> value, we sometimes need to pass the <code>input</code> value into multiple functions.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#resugaring-function" id="resugaring-function">Resugaring <code>Function</code></a></h2>
<p>In our code above, we desugared <code>(a -&gt; b)</code> into <code>Function a b</code>. What would happen if we resugared our type class instances above back into <code>-&gt;</code>? How would we write it then?</p>
<pre><code class="language-haskell">class Functor ((-&gt;) inputType) where
  map :: forall originalOutputType newOutputType.
         (originalOutputType -&gt; newOutputType) -&gt;
         (inputType -&gt; originalOutputType) -&gt; (inputType -&gt; newOutputType)
  map originalToNew f = (\input -&gt;
    let originalOutput = f argument
    in originalToNew originalOutput)

class (Functor ((-&gt;) inputType)) &lt;= Apply ((-&gt;) inputType) where
  apply :: forall originalOutputType newOutputType.
           (inputType -&gt; (originalOutputType -&gt; newOutputType)) -&gt;
           (inputType -&gt; originalOutputType) -&gt;
           (inputType -&gt; newOutputType)
  apply functionInFunction f = (\input -&gt;
    let
      originalOutput = f input
      originalToNew = functionInFunction input
    in originalToNew originalOutput)

class (Apply ((-&gt;) inputType)) &lt;= Applicative ((-&gt;) inputType) where
  pure :: forall outputType. outputType -&gt; (inputType -&gt; outputType)
  pure value = (\_ -&gt; value)

class (Apply ((-&gt;) inputType)) &lt;= Bind ((-&gt;) inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; (inputType -&gt; newOutputType)) -&gt;
          (inputType -&gt; originalOutputType) -&gt;
          (inputType -&gt; newOutputType)
  bind originalToFunction f = (\input -&gt;
    let
      originalOutput = f input
      inputToNewOutput = originalToFunction originalOutput
    in inputToNewOutput input)
</code></pre>
<h1><a class="header" href="#monadic-function-examples" id="monadic-function-examples">Monadic Function Examples</a></h1>
<p>This file will help you learn how to read a monadic function's &quot;do notation.&quot; We'll take some very simple examples and do a graph reduction on them to show how a series of <code>bind</code>/<code>&gt;&gt;=</code> calls are evaluated into a final value.</p>
<h2><a class="header" href="#function-implementations" id="function-implementations">Function Implementations</a></h2>
<p>To help us evaluate these examples manually, we'll include our verbose &quot;not cleaned up&quot; solutions from the previous file here (except for the <code>Applicative</code> one):</p>
<pre><code class="language-haskell">class Functor (Function inputType) where
  map :: forall originalOutputType newOutputType.
         (originalOutputType -&gt; newOutputType) -&gt;
         Function inputType originalOutputType -&gt;
         Function inputType newOutputType
  map originalToNew f = (\input -&gt;
    let originalOutput = f input
    in originalToNew originalOutput)

class (Functor (Function inputType)) &lt;= Apply (Function inputType) where
  apply :: forall originalOutputType newOutputType.
           Function inputType (originalOutputType -&gt; newOutputType) -&gt;
           Function inputType  originalOutputType -&gt;
           Function inputType  newOutputType
  apply functionInFunction f = (\input -&gt;
    let
      originalOutput = f input
      originalToNew = functionInFunction input
    in originalToNew originalOutput)

-- Since pure ignores its argument, I'll use the cleaned up version
-- here because it's easier to understand
class (Apply (Function inputType)) &lt;= Applicative (Function inputType) where
  pure :: forall outputType. outputType -&gt; Function inputType outputType
  pure value = (\_ -&gt; value)

class (Apply (Function inputType)) &lt;= Bind (Function inputType) where
  bind :: forall originalOutputType newOutputType.
          (originalOutputType -&gt; Function inputType newOutputType) -&gt;
          Function inputType originalOutputType -&gt;
          Function inputType newOutputType
  bind originalToFunction f = (\input -&gt;
    let
      originalOutput = f input
      inputToNewOutput = originalToFunction originalOutput
    in inputToNewOutput input)
</code></pre>
<h2><a class="header" href="#example-1-pure" id="example-1-pure">Example 1: <code>pure</code></a></h2>
<p>Let's say I have the following code using &quot;do notation&quot;</p>
<pre><code class="language-haskell">someComputation = do
  pure 1
</code></pre>
<p>Let's break it down:</p>
<pre><code class="language-haskell">pure 1

-- replace `pure` with implementation
(\_ -&gt; 1)
</code></pre>
<p>This reveals the first issue with learning how to read &quot;do notation&quot; for monadic functions: the entire thing is one massive function. <code>someComputation</code> is not a value; it's a function that expects an input.</p>
<p>To actually use it, we'd need to write something like this:</p>
<pre><code class="language-haskell">produceAValue = someComputation &quot;example input&quot;
  where
  someComputation = do
    pure 1
</code></pre>
<h2><a class="header" href="#example-2-single-bind" id="example-2-single-bind">Example 2: single <code>bind</code></a></h2>
<p>Let's say I have the following code using &quot;do notation&quot;</p>
<pre><code class="language-haskell">produceValue = someComputation 4
  where
  someComputation = do
    value &lt;- \four -&gt; 1 + four
    pure (value + 5)
</code></pre>
<p>Let's break it down:</p>
<pre><code class="language-haskell">produceValue = someComputation 4
  where
  someComputation = do
    value &lt;- \four -&gt; 1 + four
    pure (value + 5)

-- hide the &quot;produceValue&quot; part and focus only on the 'someComputation' part
do
  value &lt;- \four -&gt; 1 + four
  pure (value + 5)

-- desugar do notation into nested &gt;&gt;= calls
(\four -&gt; 1 + four) &gt;&gt;= (\value -&gt;
  pure (value + 5)
)

-- desguar &gt;&gt;= into bind
bind (\four -&gt; 1 + four) (\value -&gt;
  pure (value + 5)
)

-- replace `bind` with definition
(\input -&gt;
  let
    originalOutput = (\four -&gt; 1 + four) input
    originalToFunction = (\value -&gt; pure (value + 5))
    inputToNewOutput = originalToFunction originalOutput
  in inputToNewOutput input
)

-- replace `pure` with definition
(\input -&gt;
  let
    originalOutput = (\four -&gt; 1 + four) input
    originalToFunction = (\value -&gt; (\_ -&gt; value + 5))
    inputToNewOutput = originalToFunction originalOutput
  in inputToNewOutput input
)

-- uncurry the curried function due to `pure` definition replacement
(\input -&gt;
  let
    originalOutput = (\four -&gt; 1 + four) input
    originalToFunction = (\value _ -&gt; value + 5)
    inputToNewOutput = originalToFunction originalOutput
  in inputToNewOutput input
)

-- apply argument to `originalOutput` (`four` becomes `input`)
(\input -&gt;
  let
    originalOutput = (\input -&gt; 1 + input)
    originalToFunction = (\value _ -&gt; value + 5)
    inputToNewOutput = originalToFunction originalOutput
  in inputToNewOutput input
)

-- evaluate `originalOutput`
(\input -&gt;
  let
    originalOutput = 1 + input
    originalToFunction = (\value _ -&gt; value + 5)
    inputToNewOutput = originalToFunction originalOutput
  in inputToNewOutput input
)

-- replace `originalOutput` with its implementation
(\input -&gt;
  let
    originalToFunction = (\value _ -&gt; value + 5)
    inputToNewOutput = originalToFunction (1 + input)
  in inputToNewOutput input
)

-- inline `originalToFunction`'s definition
(\input -&gt;
  let
    inputToNewOutput = (\value _ -&gt; value + 5) (1 + input)
  in inputToNewOutput input
)

-- apply the first argument to the function
(\input -&gt;
  let
    inputToNewOutput = (\(1 + input) _ -&gt; (1 + input) + 5)
  in inputToNewOutput input
)

-- Remove the applied argument
(\input -&gt;
  let
    inputToNewOutput = (\            _ -&gt; (1 + input) + 5)
  in inputToNewOutput input
)

-- inline `inputToNewOutput`
(\input -&gt;
  (\_ -&gt; (1 + input) + 5) input
)

-- apply the `input` argument, which gets ignored
(\input -&gt;
         (1 + input) + 5)
)

-- finish cleaning up the code
(\input -&gt; (1 + input) + 5))
(\input -&gt;  1 + input  + 5)

-- re-reveal the &quot;produceValue&quot; part
produceValue = someComputation 4
  where
  someComputation = (\input -&gt; 1 + input + 5)

-- inline `someComputation`
produceValue = (\input -&gt; 1 + input + 5) 4

-- apply the argument
produceValue = (\4 -&gt; 1 + 4 + 5)

-- remove the lambda argument
produceValue = 1 + 4 + 5

-- Evaluate it
produceValue = 10
</code></pre>
<h2><a class="header" href="#example-3-multiple-bind" id="example-3-multiple-bind">Example 3: multiple <code>bind</code></a></h2>
<p>I'll leave this up to the reader to reduce, but the syntax should make it clear how it works (4 is always the initial input in each function below):</p>
<pre><code class="language-haskell">produceValue = someComputation 4
  where
  someComputation = do
    five &lt;- (\four -&gt; 1 + four)
    three &lt;- (\fourAgain -&gt; 7 - fourAgain)
    two &lt;- (\fourOnceMore -&gt; 13 + fourOnceMore - five * three)
    (\fourTooMany -&gt; 8 - two + three)
</code></pre>
<h1><a class="header" href="#special-output" id="special-output">Special Output</a></h1>
<p>Previously, we wrote the instances for a normal <code>(a -&gt; b)</code> function. But this is only one possible function! What if we modified that function, so that it outputted something different than just <code>b</code>? The reader might ask, &quot;But if <code>map</code>, <code>apply</code>, <code>pure</code>, and <code>bind</code> all require the output/<code>b</code> type to be polymorphic (i.e. it should work for all <code>b</code>s), what type could we possibly return?&quot;</p>
<p>Since <code>b</code> must still be polymorphic, why don't we wrap it in a higher-kinded type? For example, why not change <code>(a -&gt; b)</code> to <code>(a -&gt; Box b)</code>? How would we implement those type class instances?</p>
<h2><a class="header" href="#newtyping-our-function" id="newtyping-our-function">Newtyping our <code>Function</code></a></h2>
<p>If our goal is to write instances for the function, <code>(a -&gt; Box b)</code>, how can we ensure this function's type signature never changes? We can wrap the function in a newtype:</p>
<pre><code class="language-haskell">newtype OutputBox a b = OutputBox (a -&gt; Box b)
</code></pre>
<p>This creates a new problem. When we originally evaluated a monadic function, we could pass the value to the function without problem: <code>produceValue = someComputation 4</code>.</p>
<p>Since our above function is now wrapped in a newtype, we need a way to easily unwrap the newtype and pass the argument to the function. Why don't we create a function called <code>runOutputBox</code> to do just that?</p>
<pre><code class="language-haskell">runOutputBox :: forall a b. OutputBox a b -&gt; a -&gt; Box b
runOutputBox (OutputBox function) argument = function argument
</code></pre>
<p>Now we're ready to implement instances for <code>OutputBox</code></p>
<h2><a class="header" href="#functor-1" id="functor-1">Functor</a></h2>
<h3><a class="header" href="#implementing-map-1" id="implementing-map-1">Implementing <code>map</code></a></h3>
<p>Let's look at <code>Functor</code> again.</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>Following the same idea as before, we can convert <code>m</code> into <code>OutputBox input</code> and get this type signature:</p>
<pre><code class="language-haskell">instance Functor (OutputBox input) where
  map :: forall originalOutput newOutput.
         (originalOutput -&gt; newOutput) -&gt;
         OutputBox input originalOutput -&gt;
         OutputBox input newOutput
  map originalToNew (OutputBox f) = -- implementation
</code></pre>
<p>Let's see how to implement it.</p>
<ol>
<li>Since <code>map</code> returns an <code>OutputBox</code> type, let's start by first creating a newtype constructor:</li>
</ol>
<pre><code class="language-haskell">instance Functor (OutputBox input) where
  map :: forall originalOutput newOutput.
         (originalOutput -&gt; newOutput) -&gt;
         OutputBox input originalOutput -&gt;
         OutputBox input newOutput
  map originalToNew (OutputBox f) = OutputBox
</code></pre>
<ol start="2">
<li>The type, <code>OutputBox</code>, wraps a function, so let's use lambda syntax to create a new one:</li>
</ol>
<pre><code class="language-haskell">instance Functor (OutputBox input) where
  map :: forall originalOutput newOutput.
         (originalOutput -&gt; newOutput) -&gt;
         OutputBox input originalOutput -&gt;
         OutputBox input newOutput
  map originalToNew (OutputBox f) = OutputBox (\input -&gt; {- body of function -})
</code></pre>
<ol start="3">
<li>Since <code>f</code> is the only argument that can receive the <code>input</code> value, let's pass <code>input</code> into <code>f</code> and store its output in a let binding:</li>
</ol>
<pre><code class="language-haskell">instance Functor (OutputBox input) where
  map :: forall originalOutput newOutput.
         (originalOutput -&gt; newOutput) -&gt;
         OutputBox input originalOutput -&gt;
         OutputBox input newOutput
  map originalToNew (OutputBox f) = OutputBox (\input -&gt;
    let boxStoringOriginalOutput = f input
    in {- body of function -})
</code></pre>
<p>We have a problem. Do you know what it is? <code>OutputBox a b</code> is really <code>(a -&gt; Box b)</code>. So, <code>f</code> in the code above produces a value of the type, <code>Box originalOutput</code>.</p>
<p>Hmm... When we defined <code>map</code> for <code>Function input</code>, we could pass <code>originalOutput</code> directly into <code>originalToNew</code> at this point. However, <code>originalOutput</code> is currently stuck inside of <code>Box</code>. So, we have two questions.</p>
<ol>
<li>How do we get <code>originalOutput</code> out of the <code>Box</code>?</li>
<li>Once we get a value of the desired type, <code>newOutput</code>, how do we stick it back into the <code>Box</code>?</li>
</ol>
<p>In other words, our situation can be expressed in a type signature:</p>
<pre><code class="language-haskell">someFunction :: Box originalOutput -&gt; Box newOutput
</code></pre>
<p>Wait! Doesn't that look very similar to <code>Functor</code>'s <code>map</code>?</p>
<pre><code class="language-haskell">map :: (originalOutput -&gt; newOutput) -&gt; Box originalOutput -&gt; Box newOutput
</code></pre>
<p>And isn't <code>originalToNew</code> a function with this exact type signature: <code>(originalOutput -&gt; newOutput)</code>? And doesn't <code>Box</code> itself have an instance for <code>Functor</code>.</p>
<ol start="4">
<li>Use <code>Box</code>'s <code>map</code> to finish implementing the function.</li>
</ol>
<pre><code class="language-haskell">instance Functor (OutputBox input) where
  map :: forall originalOutput newOutput.
         (originalOutput -&gt; newOutput) -&gt;
         OutputBox input originalOutput -&gt;
         OutputBox input newOutput
  map originalToNew (OutputBox f) = OutputBox (\input -&gt;
    let boxStoringOriginalOutput = f input
    in map originalToNew boxStoringOriginalOutput
    )
</code></pre>
<p>Great! Let's clean it up by inlining <code>boxStoringOriginalOutput</code>.</p>
<pre><code class="language-haskell">instance Functor (OutputBox input) where
  map :: forall originalOutput newOutput.
         (originalOutput -&gt; newOutput) -&gt;
         OutputBox input originalOutput -&gt;
         OutputBox input newOutput
  map originalToNew (OutputBox f) = OutputBox (\input -&gt;
      map originalToNew (f input)
    )
</code></pre>
<h3><a class="header" href="#takeaways-2" id="takeaways-2">Takeaways</a></h3>
<p>Lessons we learned in this example:</p>
<ul>
<li>to implement <code>Functor</code> for <code>(a -&gt; Box b)</code>, we needed to use <code>Box</code>'s <code>Functor</code> instance.</li>
</ul>
<h2><a class="header" href="#apply-3" id="apply-3">Apply</a></h2>
<p>Let's now look at <code>Apply</code>.</p>
<pre><code class="language-haskell">class (Functor f) &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>Our function will have this type signature:</p>
<pre><code class="language-haskell">instance (Functor (OutputBox input)) &lt;= Apply (OutputBox input) where
  apply :: forall originalOutput newOutput.
           OutputBox input (originalOutput -&gt; newOutput) -&gt;
           OutputBox input originalOutput -&gt;
           OutputBox input newOutput
  apply (OutputBox inputToFunction) (OutputBox f) = -- implementation
</code></pre>
<ol>
<li>As before, let's implement the shell of our return type: a newtype wrapper around a function created using lambda syntax:</li>
</ol>
<pre><code class="language-haskell">instance (Functor (OutputBox input)) &lt;= Apply (OutputBox input) where
  apply :: forall originalOutput newOutput.
           OutputBox input (originalOutput -&gt; newOutput) -&gt;
           OutputBox input originalOutput -&gt;
           OutputBox input newOutput
  apply (OutputBox inputToFunction) (OutputBox f) = OutputBox (\input -&gt;
      {- body of function -}
    )
</code></pre>
<ol start="2">
<li>Let's pass <code>input</code> into <code>f</code>:</li>
</ol>
<pre><code class="language-haskell">instance (Functor (OutputBox input)) &lt;= Apply (OutputBox input) where
  apply :: forall originalOutput newOutput.
           OutputBox input (originalOutput -&gt; newOutput) -&gt;
           OutputBox input originalOutput -&gt;
           OutputBox input newOutput
  apply (OutputBox inputToFunction) (OutputBox f) = OutputBox (\input -&gt;
      let boxStoringOriginalOput = f input
      in {- body of function -}
    )
</code></pre>
<ol start="3">
<li>Let's pass <code>input</code> into <code>inputToFunction</code> to expose function:</li>
</ol>
<pre><code class="language-haskell">instance (Functor (OutputBox input)) &lt;= Apply (OutputBox input) where
  apply :: forall originalOutput newOutput.
           OutputBox input (originalOutput -&gt; newOutput) -&gt;
           OutputBox input originalOutput -&gt;
           OutputBox input newOutput
  apply (OutputBox inputToFunction) (OutputBox f) = OutputBox (\input -&gt;
      let
        boxStoringOriginalOutput = f input
        boxStoringOriginalToNew = inputToFunction input
      in {- body of function -}
    )
</code></pre>
<p>Hmm... This seems similar to what happened before. We have two boxes that are both storing values. When we tried implementing the <code>Functor</code> instance for our function, we used <code>Box</code>'s <code>Functor</code> definition. If we look at the types of our <code>Box</code>es, we'll see that this coincidence applies here, too. <code>boxStoringOriginalToNew</code> has type, <code>Box (originalOutput -&gt; newOutput)</code> while <code>boxStoringOriginalOutput</code> has type, <code>Box originalOutput</code>. So, let's use <code>Box</code>'s <code>Apply</code> instance to finish the funciton!</p>
<pre><code class="language-haskell">instance (Functor (OutputBox input)) &lt;= Apply (OutputBox input) where
  apply :: forall originalOutput newOutput.
           OutputBox input (originalOutput -&gt; newOutput) -&gt;
           OutputBox input originalOutput -&gt;
           OutputBox input newOutput
  apply (OutputBox inputToFunction) (OutputBox f) = OutputBox (\input -&gt;
      let
        boxStoringOriginalOutput = f input
        boxStoringOriginalToNew = inputToFunction input
      in apply boxStoringOriginalToNew boxStoringOriginalOutput
    )
</code></pre>
<h3><a class="header" href="#takeaways-3" id="takeaways-3">Takeaways</a></h3>
<p>Lessons we learned in this example:</p>
<ul>
<li>to implement <code>Apply</code> for <code>(a -&gt; Box b)</code>, we needed to use <code>Box</code>'s <code>Apply</code> instance.</li>
</ul>
<h2><a class="header" href="#applicative-2" id="applicative-2">Applicative</a></h2>
<p>You've probably noticed a pattern by now. To implement a type class for our function, we need to use <code>Box</code>'s corresponding instance for that type class.</p>
<p>We'll do this one quickly.</p>
<pre><code class="language-haskell">class (Apply f) &lt;= Applicative f where
  pure :: forall a. a -&gt; f a


instance (Apply (OutputBox input)) &lt;= Applicative (OutputBox input) where
  pure :: forall a. a -&gt; (OutputBox input) a
  pure value = OutputBox (\input -&gt; pure a {- Box's `pure` -})
</code></pre>
<h2><a class="header" href="#bind-2" id="bind-2">Bind</a></h2>
<p>We'll do this one a bit more slowly.</p>
<pre><code class="language-haskell">class (Apply m) &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

-- convert `f` into `OutputBox input`
instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction = -- implementation

-- Write the initial newtype constructor wrapping a function created
-- via lambda syntax
instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction = OutputBox (\input -&gt;
      {- body of function -}
    )

-- expose the `boxOriginalOutput` value
instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction = OutputBox (\input -&gt;
      let boxOriginalOutput = inputToOriginal input
      in {- body of function -}
    )

-- use `Box`'s `bind` to reveal `originalOutput`
instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction = OutputBox (\input -&gt;
      let boxOriginalOutput = inputToOriginal input
      in bind boxOriginalOutput (\originalOutput -&gt;
           {- body of function -}
         )
    )

-- pass `originalOutput` into `originalToFunction`
-- and use pattern matching to expose the function wrapped in the `OutpuBox`
instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction = OutputBox (\input -&gt;
      let boxOriginalOutput = inputToOriginal input
      in bind boxOriginalOutput (\originalOutput -&gt;
           let (OutputBox inputToNew) = originalToFunction originalOutput
           in {- body of function -}
         )
    )

-- pass `input` into `inputToNew`, which produces `Box newOutput` and
-- satisfies the type signature of `bind`.
instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction = OutputBox (\input -&gt;
      let boxOriginalOutput = inputToOriginal input
      in bind boxOriginalOutput (\originalOutput -&gt;
           let (OutputBox inputToNew) = originalToFunction originalOutput
           in inputToNew input
         )
    )
</code></pre>
<p>If we were to clean up the finished code above, we would write this:</p>
<pre><code class="language-haskell">instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction =
    OutputBox (\input -&gt; do
      originalOutput &lt;- inputToOriginal input
      let (OutpuBox inputToNew) = originalToFunction originalOutput
      inputToNew input
    )
</code></pre>
<h2><a class="header" href="#generalizing-box-to-any-monad" id="generalizing-box-to-any-monad">Generalizing <code>Box</code> to any <code>Monad</code></a></h2>
<p>If we look at our final instances below (they were copied from above), we'll see that we never once used <code>Box</code> explicitly. Rather, we could have replaced <code>Box</code> with any monadic data type and we would still be able to implement instances of these type class' functions that satisfy their type signatures.</p>
<pre><code class="language-haskell">instance Functor (OutputBox input) where
  map :: forall originalOutput newOutput.
         (originalOutput -&gt; newOutput) -&gt;
         OutputBox input originalOutput -&gt;
         OutputBox input newOutput
  map originalToNew (OutputBox f) = OutputBox (\input -&gt;
      map originalToNew (f input)
    )

instance (Functor (OutputBox input)) &lt;= Apply (OutputBox input) where
  apply :: forall originalOutput newOutput.
           OutputBox input (originalOutput -&gt; newOutput) -&gt;
           OutputBox input originalOutput -&gt;
           OutputBox input newOutput
  apply (OutputBox inputToFunction) (OutputBox f) = OutputBox (\input -&gt;
      let
        boxStoringOriginalOutput = f input
        boxStoringOriginalToNew = inputToFunction input
      in apply boxStoringOriginalToNew boxStoringOriginalOutput
    )

instance (Apply (OutputBox input)) &lt;= Applicative (OutputBox input) where
  pure :: forall a. a -&gt; (OutputBox input) a
  pure value = OutputBox (\input -&gt; pure a)

instance (Apply (OutputBox input)) &lt;= Bind (OutputBox input) where
  bind :: forall originalOutput newOutput.
          OutputBox input originalOutput -&gt;
          (originalOutput -&gt; OutputBox input newOutput) -&gt;
          OutputBox input newOutput
  bind (OutputBox inputToOriginal) originalToFunction =
    OutputBox (\input -&gt; do
      originalOutput &lt;- inputToOriginal input
      let (OutpuBox inputToNew) = originalToFunction originalOutput
      inputToNew input
    )
</code></pre>
<p>If we were to generalize our function to a monad, it would look like this:</p>
<pre><code class="language-haskell">newtype OutputMonad a m b = (a -&gt; m b)

runOutputMonad :: forall m a b. Monad m =&gt; OutputMonad a m b -&gt; a -&gt; m b
runOutputMonad (OutputMonad function) arg = function arg
</code></pre>
<h1><a class="header" href="#introducing-monad-transformers-and-capabilities" id="introducing-monad-transformers-and-capabilities">Introducing Monad Transformers and Capabilities</a></h1>
<h2><a class="header" href="#comparing-function-input-output-to-outputbox-input-output" id="comparing-function-input-output-to-outputbox-input-output">Comparing <code>Function input output</code> to <code>OutputBox input output</code></a></h2>
<p>When we initially covered the original monadic function, <code>(a -&gt; b)</code>, we discovered that it's &quot;do notation&quot; could be read like this:</p>
<pre><code class="language-haskell">produceValue = someComputation 4
  where
  someComputation = do
    five &lt;- (\four -&gt; 1 + four)
    three &lt;- (\fourAgain -&gt; 7 - fourAgain)
    two &lt;- (\fourOnceMore -&gt; 13 + fourOnceMore - five * three)
    (\fourTooMany -&gt; 8 - two + three)
</code></pre>
<p>The above computation demonstrates something important: the argument, <code>4</code>, passed to <code>someComputation</code> is always available in its do notation despite the argument, <code>4</code>, never appearing as an argument in <code>someComputation</code>'s definition.</p>
<pre><code class="language-haskell">-- In other words, we have this...
someComputation = do
  -- code...

-- ... not this...
someComputation argumentThatIsFour = do
  -- some code
</code></pre>
<p>The normal <code>(a -&gt; b)</code> function allows us to reference the argument we pass into the function at any point in its do notation. Unfortunately, since the return value of that function is <code>b</code>, we are limited to only writing pure code. In other words, <code>someComputation</code> is a computation that can never interact with the outside world.</p>
<p>But what happens if we use the <code>OutputMonad</code>/<code>(a -&gt; monad b)</code> function? Since it outputs a monadic data type, what if that monadic data type was <code>Effect</code> or <code>Aff</code>? If so, the resulting code would be very hard to read:</p>
<pre><code class="language-haskell">produceComputation = runOutputEffect someComputation 4
  where                                                                     {-
  someComputation :: OutputMonad a   m      b                               -}
  someComputation :: OutputMonad Int Effect String
  someComputation = do
    five &lt;- (\four -&gt; pure $ 1 + four)
    three &lt;- (\fourAgain -&gt; pure $ 7 - fourAgain)
    intBetween0And12 &lt;- (\fourOnceMore -&gt; randomInt 0 $ 13 + fourOnceMore - five)
    (\fourTooMany -&gt; log $ show $ 8 - intBetween0And12)
</code></pre>
<p>But what if we expressed the same idea using capabilities via type class constraints? This is the same code as above:</p>
<pre><code class="language-haskell">produceComputation = runOutputMonad someComputation 4
  where
  someComputation :: forall m. Monad m =&gt;
                     MonadReader Int m =&gt;
                     MonadEffect m =&gt;
                     OutputMonad Int m String
  someComputation = do
    four &lt;- ask
    let five = 1 + four
    let three = 7 - four
    intBetween0And12 &lt;- liftEffect $ randomInt 0 $ 13 + four - five
    liftEffect $ log $ show $ 8 - intBetween0And12
</code></pre>
<h2><a class="header" href="#introducing-readert" id="introducing-readert">Introducing <code>ReaderT</code></a></h2>
<p>To see this from a slighty different angle, we'll cover a few things before linking to an example showing how a computation &quot;evolves&quot; into the <code>Reader</code> monad.</p>
<p><code>OutputMonad</code> is better known as <code>ReaderT</code>:</p>
<ul>
<li>when <code>ReaderT</code>'s monadic type is a real monad, we call it <a href="https://pursuit.purescript.org/packages/purescript-transformers/4.2.0/docs/Control.Monad.Reader.Trans#t:ReaderT"><code>ReaderT</code></a></li>
<li>when <code>ReaderT</code>'s monadic type is <code>Identity</code> (placeholder monadic type), we call it <a href="https://pursuit.purescript.org/packages/purescript-transformers/4.2.0/docs/Control.Monad.Reader"><code>Reader</code></a>.</li>
</ul>
<p>It's corresponding type class is <a href="https://pursuit.purescript.org/packages/purescript-transformers/4.2.0/docs/Control.Monad.Reader.Class"><code>MonadReader</code></a>.</p>
<p>Watch a computation &quot;evolve&quot; into the <code>Reader</code> monad in <a href="https://gist.github.com/rlucha/696ca604c9744ad11aff7d46b1706de7">the Monad Reader Example</a>.</p>
<h2><a class="header" href="#monad-transformers-summarized" id="monad-transformers-summarized">Monad Transformers Summarized</a></h2>
<h3><a class="header" href="#the-main-idea" id="the-main-idea">The Main Idea</a></h3>
<p>This is the whole point of using monadic functions that output monadic data types: <strong>they allow us to encode all of our business logic as one massive pure function.</strong></p>
<table><thead><tr><th>If the underlying outputted monadic data type is...</th><th>then running our code will ...</th></tr></thead><tbody>
<tr><td><code>Effect</code>/<code>Aff</code><br>(&quot;impure&quot; monads)</td><td>execute a program</td></tr>
<tr><td><code>Identity</code>^/<code>Trampoline</code>^^<br>(&quot;pure&quot; monad)</td><td>allow us test our business logic</td></tr>
</tbody></table>
<p>^ <code>Identity</code> is what you get if <code>Box</code> was a newtype rather than data. In other words, <code>newtype Identity a = Identity a</code>. <code>identity</code> is a function that returns as output its input. Thus, it's often used as a &quot;placeholder&quot; / <code>mempty</code> function value. Similarly, <code>Identity a</code> is a type that reduces to the <code>a</code> type at runtime. Thus, it's often used as a &quot;placeholder&quot; / <code>mempty</code>-like monadic type.
^^ <code>Trampoline</code> is a monad that we haven't introduced yet.</p>
<p>With one monad, we can prove that our business logic works as expected and does not have any bugs, and with another monad, we can execute that same business logic as a useful program.</p>
<p>This helps us understand the name behind &quot;Monad Transformers&quot;. Monadic functions that return other monadic data types (i.e. <code>a -&gt; m b</code>) are called &quot;Monad Transformers&quot; because they transform (or augment) the base monad with additional capabilities. They are the &quot;implementation&quot; that makes all of this work.</p>
<p>However, we use type classes like <code>MonadReader</code>, <code>MonadState</code>, <code>MonadWriter</code>, etc. to express that a given computation can only be run if their implementation can satisfy the required capabilities.</p>
<p>In short, we use type classes above to &quot;write&quot; our business logic and monad transformers to &quot;run&quot; our business logic.</p>
<h3><a class="header" href="#breaking-it-down" id="breaking-it-down">Breaking It Down</a></h3>
<p>First, there is a type class that indicates that some underlying monad has the <strong>capability</strong> to do some effect (e.g. state manipulation via <code>MonadState</code>).</p>
<p>Second, there is a default implementation for that class via a monadic newtyped function (e.g. <code>ReaderT</code>). As we will see later, such functions add in specific effects, reduce some of the syntax boilerplate one might write, and make impossible states impossible.
When we wish to transform some other monad, we use the newtyped monadic functions that end with <code>T</code> as in &quot;transformer&quot; (e.g. <code>ReaderT</code>). However, if we don't want to transform a monad (i.e. just use <code>Identity</code> to act as a placeholder monadic type), then we remove that <code>T</code> (e.g. <code>Reader</code>).</p>
<p>Third, the general pattern (there are exceptions!) that we will see reappear when overviewing the other Monad Transformers:</p>
<ul>
<li>There is a type class called <code>Monad[Word]</code> where <code>[Word]</code> clarifies what functions the type class provides. This type class indicates that some underlying monad has some <strong>capability</strong>.</li>
<li>There is a single default implementation for <code>Monad[Word]</code> called <code>[Word]T</code>. When the monad type is specialized to <code>Identity</code>, it's simply called <code>[Word]</code>.</li>
<li>To run a computation using <code>Monad[Word]</code>, we must use either <code>run[Word] computation arg</code> (i.e. the monad is <code>Identity</code>) or <code>run[Word]T computation arg</code> (i.e. a non-<code>Identity</code> monad).</li>
</ul>
<p>Putting it into a table, we get this.</p>
<table><thead><tr><th>Type Class</th><th>Sole Implementation<br>(<code>m</code> is real monad)<br><br>function that runs it</th><th>Sole Implementation<br>(<code>m</code> is <code>Identity</code>)<br><br>function that runs it</th></tr></thead><tbody>
<tr><td><code>Monad[Word]</code><br>(General Pattern)</td><td><code>[Word]T</code><br><br><code>run[Word]T</code></td><td><code>[Word]</code><br><br><code>run[Word]</code></td></tr>
<tr><td><code>MonadState</code></td><td><code>StateT</code><br><br><code>runStateT</code></td><td><code>State</code><br><br><code>runState</code></td></tr>
<tr><td><code>MonadReader</code></td><td><code>ReaderT</code><br><br><code>runReaderT</code></td><td><code>Reader</code><br><br><code>runReader</code></td></tr>
<tr><td><code>MonadWriter</code></td><td><code>WriterT</code><br><br><code>runWriterT</code></td><td><code>Writer</code><br><br><code>runWriter</code></td></tr>
<tr><td><code>MonadCont</code></td><td><code>ContT</code><br><br><code>runCont</code></td><td><code>Cont</code><br><br><code>runCont</code></td></tr>
<tr><td><code>MonadError</code></td><td><code>ExceptT</code><br><br><code>runExceptT</code></td><td><code>Except</code><br><br><code>runExcept</code></td></tr>
</tbody></table>
<p>To summarize each monad transformer, we'll use another table. <strong>The below terms for &quot;pure&quot; and &quot;impure&quot; refer to whether the computations can interact with the real world.</strong>:</p>
<table><thead><tr><th>A basic function...</th><th>... is used to run a <strong>pure</strong> computation ...</th><th>can be &quot;upgraded&quot; to a monad transformer...</th><th>... which is used to run an <strong>impure</strong> computation ...</th></tr></thead><tbody>
<tr><td><code>input -&gt; output</code></td><td>that depends on its input</td><td><code>globalValue -&gt; monad outputThatUsesGlobalValue</code><br><br><code>ReaderT</code></td><td>that depends on some global configuration</td></tr>
<tr><td><code>state -&gt; Tuple output state</code></td><td>that does state manipulation</td><td><code>oldState -&gt; monad (Tuple (output, newState))</code><br><br><code>StateT</code></td><td>that does state manipulation</td></tr>
<tr><td><code>function $ arg</code></td><td>once an argument is fully computed</td><td><code>\function -&gt; output</code><br><br><code>ContT</code></td><td>and periodically use a function passed in as an argument to compute something</td></tr>
</tbody></table>
<p>Some monad transformers just specify what their output type will be:</p>
<table><thead><tr><th>A basic return value...</th><th>... that is used to run a <strong>pure</strong> computation ...</th><th>... can be put into a Monad and become a monad transformer...</th><th>... which is used to run an <strong>impure</strong> computation ...</th></tr></thead><tbody>
<tr><td><code>Tuple output additionalOutput</code></td><td>that also produces additional output</td><td><code>monad (Tuple (output, accumulatedValue)</code><br><br><code>WriterT</code></td><td>that produces accumulated data as additional output</td></tr>
<tr><td><code>Either e a</code></td><td>that handles partial functions</td><td><code>monad (Either e a)</code><br><br><code>ExceptT</code></td><td>that may fail and the error matters</td></tr>
<tr><td><code>Maybe a</code></td><td>that might not return a value</td><td><code>monad (Maybe a)</code><br><br><code>MaybeT</code></td><td>that might not return a value</td></tr>
<tr><td><code>List a</code></td><td>that produces 0 or more values</td><td><code>monad (List a)</code><br><br><code>ListT</code></td><td>that produces 0 or more values</td></tr>
</tbody></table>
<p>Once again, the &quot;base monad&quot; that usually inhibits <code>m</code> in the &quot;stack&quot; of nested monad transformers is usually one of two things:</p>
<ul>
<li><code>Effect</code>/<code>Aff</code>: impure monads that actually make our business logic useful</li>
<li><code>Identity</code>/<code>Free</code>: pure monads that test our business logic.</li>
</ul>
<h1><a class="header" href="#implementing-a-monad-transformer" id="implementing-a-monad-transformer">Implementing a Monad Transformer</a></h1>
<p>This folder will show the thought process one would take to implement a monad transformer (e.g. the type class and its implementation) for manipulating state in a monad stack. The lessons learned/demonstrated in this folder will make it easier to understand the standard monad transformers covered in the rest of this <code>MTL</code> folder.</p>
<h1><a class="header" href="#looking-at-oo-for-a-pattern" id="looking-at-oo-for-a-pattern">Looking at OO for a Pattern</a></h1>
<p>We'll look at three examples of OO code to help us understand it's equivalent in FP code.</p>
<h2><a class="header" href="#incrementing-an-integer" id="incrementing-an-integer">Incrementing an Integer</a></h2>
<p>Given this code:</p>
<pre><code class="language-javascript">a = 0;
x = a++;
y = a++;
z = a++;
// which we'll rewrite to use a function that receives an argument
a = 0;
x = getAndIncrement(a);
y = getAndIncrement(a);
z = getAndIncrement(a);
</code></pre>
<p><code>getAndIncrement</code> is an example of an impure function because it does not return the same value each time it is called. Moreover, <code>a</code>'s value changes over time, so that <code>a /= 0</code> at the end of our program. How might we write the same thing using pure functions? We'll demonstrate a few attempts and explain their problems before showing the final working solution</p>
<pre><code class="language-javascript">// we'll make the function pure
// and call it &quot;add1&quot;
var add1 = (i) =&gt; i + 1;

a = 0;
x = add1(a);
y = add1(a);
z = add1(a);

// Values end states are:
a == 0
x == y == z == 1
</code></pre>
<p>The problem is <code>add1</code> receives the wrong state as an argument. If we pass the returned state from our previous call into the next call, we can resolve this problem:</p>
<pre><code class="language-javascript">a = 0;
x = add1(a);
y = add1(x);
z = add1(y);

// Values end states are:
a == 0
x == 1
y == 2
z == 3
</code></pre>
<p>At this point, we could do state manipulation using a recursive function...</p>
<pre><code class="language-haskell">runNTimes :: forall a. Int -&gt; (a -&gt; a) -&gt; a
runNTimes 0 _ output = output
runNTimes count func arg = runNTimes (count - 1) func (func arg)
</code></pre>
<p>... but state manipulation is more complicated than that. What if we wanted to add 1 at one point and add 2 at another? What if we want to subtract 5 as well? In short, this approach does not work when we increase the complexity of the state manipulation. The next two examples will focus on a different kind of state manipulation.</p>
<h2><a class="header" href="#random-number-generators" id="random-number-generators">Random Number Generators</a></h2>
<p>Given this code:</p>
<pre><code class="language-javascript">x = random.nextInt
y = random.nextInt
z = random.nextInt

// rewritten to use &quot;function arg&quot; syntax
x = nextInt(random);
y = nextInt(random);
z = nextInt(random);
</code></pre>
<p><code>nextInt</code> is an impure function because it does not return the same value each time it is called. How might we write the same thing using pure functions? We'll demonstrate a few attempts and explain their problems before showing the final working solution</p>
<pre><code class="language-javascript">// Assume that  `nextInt` is now pure...
x = nextInt(random);
y = nextInt(random);
// ... then 'x' ALWAYS equals 'y'
// A random number can sometimes be the same one as before,
// but this shouldn't always be true

// To make `x /= y`, we need a new `random` value, something like:
x = nextInt(random1);
y = nextInt(random2);
</code></pre>
<p>The solution is to make <code>nextInt</code> return two things via the <code>Tuple a b</code> type</p>
<ul>
<li>the random int value</li>
<li>a new value of <code>random</code></li>
</ul>
<pre><code class="language-javascript">(Tuple x random2) = nextInt(random1);
(Tuple y random3) = nextInt(random2);
</code></pre>
<p>where <code>Tuple a b</code> is just a box that holds two values of the same/different types:</p>
<pre><code class="language-haskell">data Tuple a b = Tuple a b
</code></pre>
<h2><a class="header" href="#popping-stacks" id="popping-stacks">Popping Stacks</a></h2>
<p>We'll explain this idea once more using a different context: Stacks. In OO, we can write the following code:</p>
<pre><code class="language-javascript">// assuming we have a non-empty stack:
//   (top) [1, 2, 3, 4, 5] (bottom)
x = stack.pop // x == 1
y = stack.pop // y == 2
z = stack.pop // z == 3

// rewritten using &quot;function arg&quot; syntax
x = pop(stack);
y = pop(stack);
z = pop(stack);
</code></pre>
<p><code>pop</code> is an impure function as calling it will not return the same value each time it is called. How might we write the same thing using pure functions?</p>
<pre><code class="language-javascript">// Assume that  `nextInt` is now pure...
x = pop(stack);
y = pop(stack);
// ... we just popped the same value twice off of the stack
// so that 'x' is always the same value/object as 'y'
// In other words
pop(stack) == x == y == 1

// To make `y` == 2, we need a version of `stack` that will return `2`
// as its next value to `pop`. In other words, something like...
x = pop(originalStack);
y = pop(originalStack_withoutX);
</code></pre>
<p>The solution is to make <code>pop</code> return two things via the <code>Tuple a b</code> type:</p>
<ul>
<li>the popped value</li>
<li>a new version of <code>stack</code> without the popped value</li>
</ul>
<pre><code class="language-javascript">(Tuple x originalStack_withoutX)    = pop(originalStack);
(Tuple y originalStack_withoutXorY) = pop(originalStack_withoutX);
</code></pre>
<h2><a class="header" href="#identifying-the-pattern" id="identifying-the-pattern">Identifying the Pattern</a></h2>
<p>Here's the solution we came up with:</p>
<pre><code class="language-javascript">(Tuple x random2) = randomInt(random1);
(Tuple y random3) = randomInt(random2);

(Tuple x originalStack_withoutX)    = pop(originalStack);
(Tuple y originalStack_withoutXorY) = pop(originalStack_withoutX);

// and generalizing it to a pattern, we get
(Tuple value1,  value2        ) = stateManipulation(value1);
(Tuple value2,  value3        ) = stateManipulation(value2);
(Tuple value3,  value4        ) = stateManipulation(value3);
// ...
(Tuple value_N, value_N_plus_1) = stateManipulation(valueN);
</code></pre>
<p>Turning this into Purescript syntax, we get:</p>
<pre><code class="language-haskell">state_manipulation_function :: forall state value. (state -&gt; Tuple value state)
</code></pre>
<h1><a class="header" href="#implementing-the-pattern" id="implementing-the-pattern">Implementing the Pattern</a></h1>
<p>Here's the solution we came up with:</p>
<pre><code class="language-javascript">(Tuple x random2) = randomInt(random1);
(Tuple y random3) = randomInt(random2);

(Tuple x originalStack_withoutX)    = pop(originalStack);
(Tuple y originalStack_withoutXorY) = pop(originalStack_withoutX);

// and generalizing it to a pattern, we get
(Tuple value1,  value2        ) = stateManipulation(value1);
(Tuple value2,  value3        ) = stateManipulation(value2);
(Tuple value3,  value4        ) = stateManipulation(value3);
// ...
(Tuple value_N, value_N_plus_1) = stateManipulation(valueN);
</code></pre>
<p>Turning this into Purescript syntax, we get:</p>
<pre><code class="language-haskell">state_manipulation_function :: forall state value. (state -&gt; Tuple value state)
</code></pre>
<h2><a class="header" href="#syntax-familiarity" id="syntax-familiarity">Syntax Familiarity</a></h2>
<p>Starting with a simple example written using meta-language, we can simulate the state manipulation syntax when it's only run once. Unlike the &quot;add 1 to integer&quot; problem from before, this will return the integer state as a <code>String</code>, not an <code>Int</code>:</p>
<pre><code class="language-haskell">type State = Int
type Value = String

initialState :: State
initialState = 0

add1 :: (State -&gt; Tuple Value State)
add1 oldState   =
  let theNextState = oldState + 1
  in Tuple (show theNextState) theNextState

main :: Effect Unit
main =
  case (add1 initialValue) of
    Tuple theValue theNextState -&gt; do
      log $ &quot;Value was: &quot; &lt;&gt; theValue               -- &quot;1&quot;
      log $ &quot;next state was: &quot; &lt;&gt; show theNextState --  1
</code></pre>
<h2><a class="header" href="#why-we-need-a-monad" id="why-we-need-a-monad">Why We Need a Monad</a></h2>
<p>What if we want to run <code>add1</code> four times?</p>
<p>Knowing that we have more complicated state manipulation ahead of us (e.g. Stacks), we should follow the pattern we identified above:</p>
<ol>
<li>Pass an initial state value into <code>add1</code>, which outputs <code>Tuple nextStateAsString nextState</code></li>
<li>Extract the <code>nextState</code> part of the Tuple</li>
<li>Pass <code>nextState</code> into another <code>add1</code> call</li>
<li>Loop a few times</li>
<li>Pass the last state into <code>add</code> and return its output: <code>Tuple lastStateAsString lastState</code>.</li>
</ol>
<p>In code, this looks like:</p>
<pre><code class="language-haskell">type State = Int
type Value = String
type Count = Int

add1 :: (State -&gt; Tuple Value State)
add1 oldState   =
  let theNextState = oldState + 1
  in Tuple (show theNextState) theNextState

add1_FourTimes :: State -&gt; Tuple Value State
add1_FourTimes initialState = runNTimes 4 add1 initialState

runNTimes :: Count -&gt; (State -&gt; Tuple Value State) -&gt; State -&gt; Tuple Value State
runNTimes 1 add1_ nextState = add1_ nextState
runNTimes count add1_ nextState =
  runNTimes (count - 1) add1_ (getSecond $ add1_ i)

  where
  getSecond :: Tuple Value State -&gt; Int
  getSecond (Tuple _ state) = state
</code></pre>
<p>This works but only because it's so simple. Let's say we want to call <code>add1</code> on the first state, then call <code>times2</code> on the second state, and then return the output of calling <code>add1</code> on the third state. How would we update our code to do that?</p>
<p>We could try to specify a stack of functions (using an array or some other stack-like data structure) that are used to recursively evaluate the next state outputted by the previous function. <strong>Below is not a working example</strong> of how one would write that, <strong>but merely demonstrates the heart</strong> behind it:</p>
<pre><code class="language-haskell">type Stack a = Array a
type State = Int
type Value = String

-- This code doesn't type check!
-- It exists for teaching purposes only!
runUsingFunctions :: Stack (State -&gt; Tuple Value State) -&gt; State -&gt; Tuple Value State
runUsingFunctions [last] state = last state
runUsingFunctions [second, last] = runUsingFunctions [last] (getSecond $ second state)
runUsingFunctions [first, second, last] state =
  runUsingFunctions [second, last] (getSecond $ first state)

  where
  getSecond :: Tuple Value State -&gt; State
  getSecond (Tuple _ state) = state
</code></pre>
<p>Conceptually, there are two problems with the above code.</p>
<ol>
<li>If we change the value type for one function so that it's different from all other function in the stack (e.g. <code>toNumber :: Int -&gt; Tuple Number Int</code>), the above code will no longer compile.</li>
<li>We cannot use a function that receives the next state AND value(s) produced by previous function(s) as its arguments.</li>
</ol>
<p>As an example for the second point, how could we use these two functions in the same state manipulation workflow:</p>
<pre><code class="language-haskell">firstFunction :: State1 -&gt; Tuple Value1 State2

fourthFunction :: State4 -&gt; Value1 -&gt; Tuple Value4 State5
</code></pre>
<p>The following function, <code>crazyFunction</code>, demonstrates both of these problems without the intermediary second and third functions:</p>
<ol>
<li>Take some <code>initialState</code> value</li>
<li>Pass that value into <code>add1 :: State -&gt; Tuple Int Int</code>, which returns <code>Tuple value1 state2</code></li>
<li>Pass <code>value</code> and <code>state2</code> into <code>addValue1StringLengthTo :: Int -&gt; Int -&gt; Tuple String Int</code> where
<ul>
<li><code>value</code> will be converted into a <code>String</code>, called <code>valueAsString</code></li>
<li>the length of <code>valueAsString</code> will be added to <code>state2</code>, which produces <code>state3</code></li>
<li><code>state3</code> is converted into a <code>String</code>, called <code>value2</code></li>
<li>the function returns <code>Tuple value2 state3</code></li>
</ul>
</li>
<li>Return <code>addStringLengthTo</code>'s output: <code>Tuple value2 nextState3</code></li>
</ol>
<p>To write <code>crazyFunction</code>, we need something more like sequential computation, which implies <code>bind</code>/<code>&gt;&gt;=</code>. However, <code>bind</code> requires a Monad to work. With these clues, we need a function whose type signature looks something like this:</p>
<pre><code class="language-haskell">someFunction :: forall state monad value
              . Monad monad
             =&gt; (state -&gt; Tuple value state) -- the state manipulation function
             -&gt; state                        -- the initial state
             -&gt; monad (Tuple value state)    -- the monad that makes `bind` work
someFunction function state = pure $ function state
</code></pre>
<p>Putting this all together, we get this:</p>
<pre><code class="language-haskell">someFunction :: forall state monad value
              . Monad monad

             -- the state manipulation function...
             =&gt; (state -&gt; Tuple value state)

             -- (the initial/next state)
             -&gt; state

             -- whose output gets lifted into a Monad that makes `bind` work,
             -- so we can compose multiple state manipulating functions
             -- together into one function
             -&gt; monad (Tuple value state))
someFunction function initialOrNextState =
    let tuple = function initialOrNextState

      -- lift it into the Monad to
      -- enable sequential computation via bind
    in pure tuple
  )

-- our Monad type
data Box a = Box a

unwrapBox :: forall a. Box a -&gt; a
unwrapBox (Box a) = a

addStringLengthTo :: Int -&gt; Int -&gt; Tuple String Int
addStringLengthTo value state =
  let valueAsString = show value
      state3 = state + (length valueAsString)
  in Tuple (show state3) state3

-- Uses `someFunction` to compose multiple state functions together into one
crazyFunction :: Int -&gt; Box (Tuple Int Int)
crazyFunction initial = do                                                   {-
  Tuple value  state  &lt;- pure $ function state
  Tuple value  state  &lt;- (\s -&gt; pure $ function s) state
  Tuple value  state  &lt;- (someFunction function) state                      -}
  Tuple value1 state2 &lt;- (someFunction add1) initial
  (someFunction (\s -&gt; addStringLengthTo value1 s) state2

main :: Effect Unit
main =
  case (unwrapBox $ crazyFunction 0) of
    Tuple theString theInt -&gt; do
      log $ &quot;theString was: &quot; &lt;&gt; theString  -- &quot;2&quot;
      log $ &quot;theInt was: &quot; &lt;&gt; show theInt   --  2
</code></pre>
<p>There's two problems with the above approach, which the next sections will refine.</p>
<h2><a class="header" href="#the-identity-monad" id="the-identity-monad">The <code>Identity</code> Monad</a></h2>
<p><code>Box</code> is a literal runtime Box. So, using it here as our monad type means we'll be runtime boxing and unboxing the result of our functions, thereby slowing down our code needlessly. We only need <code>Box</code> so we can use a Monad for sequential computation, not because we need the type, <code>Box</code>, specifically (we could use <code>Box2</code> and our code wouldn't change). Why don't we get rid of this needless runtime overhead by using a type that only exists at compile-time? This implies using <code>newtype</code> because the type still needs to implement an instance for <code>Monad</code>.</p>
<p>Since we have a &quot;placeholder&quot; function called <code>identity</code>, let's reuse this name for our compile-time-only type:</p>
<pre><code class="language-haskell">-- placeholder for a function!
identity :: forall a. a -&gt; a
identity x = x

-- runtime type!
data    Box      a = Box      a

-- placeholder for a monad!
-- compile-time-ONLY type!
newtype Identity a = Identity a
</code></pre>
<h2><a class="header" href="#the-syntax-problem" id="the-syntax-problem">The Syntax Problem</a></h2>
<p><code>crazyFunction</code> showed an issue with our current approach: we have to pass the previous <code>state</code> result back into the next function. If the developer passes in the wrong state value, the code will no longer work as expected:</p>
<pre><code class="language-haskell">crazyFunction :: Int -&gt; Identity (Tuple Int Int)
crazyFunction initial = do
  -- Computation 1: here we calculate what state2 is
  Tuple value1 state2 &lt;- (someFunction add1) initial

  -- Computation 2: here we calculate what state3 is
  Tuple value2 state3 &lt;- (someFunction add1) state2

  -- Computation 3: here we pass in `state2` when we should pass in `state3`
  (someFunction (\s -&gt; addStringLengthTo value2 s) state2
</code></pre>
<p>In short, we need to hide the <code>state</code> value entirely from the function so that developers cannot pass in the wrong value. Thus, we must also get rid of the <code>Tuple value state</code> notion in our function. Putting those two concepts together, we imagine syntax that looks like this:
<code>nextValue &lt;- someFunction (\nextState -&gt; stateManipulatingFunction nextState)</code></p>
<p>This syntax...
<code>nextValue &lt;- someFunction (\initialState -&gt; stateManipulatingFunction initialState)</code>
... looks very similar to OO's syntax:
<code>var nextValue = initialState.stateManipulatingFunction();</code></p>
<p>Another benefit: it gets rid of the boilerplate-y noise-y <code>Tuple</code>s</p>
<p>What would we need to change to get this syntax? This gets tricky.</p>
<p>First, <code>initialState</code> should now be located outside <code>crazyFunction</code> and appear in another function, <code>runSomeFunction</code>. <code>runSomeFunction</code> should pass the <code>initialState</code> value into the final composition of all the state manipulating functions:</p>
<pre><code class="language-haskell">runSomeFunction :: forall state value.
                   (state -&gt; Identity (Tuple value state)) -&gt;
                   state -&gt;
                   Tuple value state
runSomeFunction stateFunctionsComposedIntoOne initialState =
  let (Identity tuple) = stateFunctionsComposedIntoOne initialState
  in tuple

addStringLengthTo :: Int -&gt; Int -&gt; Tuple String Int
addStringLengthTo value state =
  let valueAsString = show value
      state3 = state + (length valueAsString)
  in Tuple (show state3) state3

-- Using our new syntax...
crazyFunction :: (state -&gt; Identity (Tuple Int state))
crazyFunction = do
  -- Computation 1
  value1 &lt;- someFunction (\initialState -&gt; add1 initialState)

  -- Computation 2
  -- `bind` will produce `Tuple value2 state3`
  someFunction (\state2 -&gt; addStringLengthTo value1 state2)
</code></pre>
<p>Second (and as the above example shows), <code>someFunction</code> must somehow return just <code>value</code> and not <code>Tuple value state</code>.</p>
<p>From these clues, we get this new type signature:</p>
<pre><code class="language-haskell">someFunction :: forall state monad value.
                Monad monad =&gt;
                (state -&gt; Tuple value state) -&gt; monad value
someFunction function = -- ???

runSomeFunction :: forall state value.
                   (state -&gt; Identity (Tuple value state)) -&gt;
                   state -&gt;
                   Tuple value state
runSomeFunction stateFunctionsComposedIntoOne initialState =
  let (Identity tuple) = stateFunctionsComposedIntoOne initialState
  in tuple
</code></pre>
<p>It would seem that this idea is not possible. We'll reveal how in the next file. For now, we'll abstract this concept into a type class</p>
<h3><a class="header" href="#abstracting-the-concept-into-a-type-class" id="abstracting-the-concept-into-a-type-class">Abstracting the Concept into a Type Class</a></h3>
<p>We want to use <code>someFunction</code> for numerous state manipulating functions on numerous data structures (e.g. <code>add1</code>, <code>popStack</code>, <code>replaceElemAtIndex</code>). This implies that we need to convert <code>someFunction</code> into a type class, so we can use <code>someFunction</code> in other situations via a type class constraint. Let's attempt to define it and call the type class <code>MonadState</code>. Its function, <code>state</code>, should be the same as <code>someFunction</code>'s type signature:</p>
<pre><code class="language-haskell">someFunction :: forall state monad value
              . Monad monad
             =&gt; (state -&gt; Tuple value state)
             -&gt; monad value
someFunction function = -- ???

class MonadState ??? where
  state :: forall s m a
             .  (s -&gt; Tuple a s )
             -&gt; m a
</code></pre>
<p>Because we know we need <code>bind</code>, let's add a Monad constraint, <code>m</code>, to <code>???</code>:</p>
<pre><code class="language-haskell">class (Monad m) &lt;= MonadState m where
  state :: forall s a
             .  (s -&gt; Tuple a s )
             -&gt; m a
</code></pre>
<p>We need to make sure the <code>state</code> type does not change, so we'll also define a functional dependency from <code>m</code> to <code>s</code></p>
<pre><code class="language-haskell">class (Monad m) &lt;= MonadState s m | m -&gt; s where
  state :: forall a
             .  (s -&gt; Tuple a s )
             -&gt; m a
</code></pre>
<p>Combining this definition with its corresponding <code>runSomeFunction</code>, we get this (where <code>runSomeFunction</code> is now called <code>runStateFunction</code>)</p>
<pre><code class="language-haskell">class (Monad m) &lt;= MonadState s m | m -&gt; s where
  state :: forall a. (s -&gt; Tuple a s) -&gt; m a

runStateFunction :: forall s a. (s -&gt; Identity (Tuple a s)) -&gt; s -&gt; Tuple a s
runStateFunction stateManipulation initialState =
  let (Identity tuple) = stateManipulation initialState
  in tuple
</code></pre>
<p>Ok. Now let's see how this seemingly impossible syntax is actually possible.</p>
<h1><a class="header" href="#a-magical-monad" id="a-magical-monad">A Magical Monad</a></h1>
<p>We reached these conclusions previously:</p>
<ul>
<li>we need <code>Monad</code>'s <code>bind</code>/<code>&gt;&gt;=</code> to enable multiple different state-manipulating functions to work</li>
<li>we need to hide the <code>state</code> from the actual function, so that developers can't pass in the wrong state value accidentally (i.e. make impossible states impossible). This came with two implications:
<ul>
<li>Calling <code>bind</code>/<code>&gt;&gt;=</code> should return just <code>value</code>, not <code>Tuple value state</code></li>
<li>Running the computation via <code>runSomeFunction</code> should return <code>Tuple value state</code>.</li>
</ul>
</li>
</ul>
<p>In short, we need to implement the following two functions with these type signatures:</p>
<pre><code class="language-haskell">class (Monad m) &lt;= MonadState state monad | monad -&gt; state where
  state :: forall value. (state -&gt; Tuple value state) -&gt; monad value

runStateFunction :: forall state value.
                   (state -&gt; Identity (Tuple value state)) -&gt;
                    state -&gt;
                    Tuple value state
runStateFunction stateManipulation initialState =
  let (Identity tuple) = stateManipulation initialState
  in tuple
</code></pre>
<h2><a class="header" href="#introducing-the-function-monad" id="introducing-the-function-monad">Introducing the Function Monad</a></h2>
<p>What if <code>Function</code> was a <code>Monad</code>? This might sound surprising at first, but it's actually true.</p>
<p>Recall that a <code>Monad</code> is any type that has lawful instances for the <code>Functor</code>, <code>Apply</code>, <code>Applicative</code>, <code>Bind</code>, and <code>Monad</code> (FAABM) type classes. As long as a type can successfully implement lawful functions for them, the type can be called monadic.</p>
<p>How might this be possible?</p>
<p>First, a <code>Monad</code> has kind <code>Type -&gt; Type</code> whereas a <code>Function</code> has kind <code>Type -&gt; Type -&gt; Type</code>.</p>
<p>We can make <code>Function</code>'s kind one less by specifying either the input type or the output type:</p>
<ul>
<li><code>Function Int a</code>/<code>(Int -&gt; a)</code> has kind <code>Type -&gt; Type</code></li>
<li><code>Function a Int</code>/<code>(a -&gt; Int)</code> has kind <code>Type -&gt; Type</code></li>
</ul>
<p>In other words, we need to turn <code>Function</code> into a completely new type (<code>data</code>, <code>type</code>, or <code>newtype</code>) that should only exist at compile time to reduce runtime overhead (e.g. <code>type</code> or <code>newtype</code>) that can also implement type classes (i.e. only <code>newtype</code>). Using a newtyped version of <code>Function</code>, we can specify all the types in the function:</p>
<pre><code class="language-haskell">newtype TypedFunction input output =
  TypedFunction (input -&gt; output)

specifiesInput :: forall a. TypedFunction Int b -- Kind: Type -&gt; Type

specifiesOutput :: forall a. TypedFunction a Int  -- Kind: Type -&gt; Type
</code></pre>
<p>Second, since <code>Function</code> can refer to any function, what should our newtyped function's type signature be? We'll use the state-manipulating function's type signature itself!
<code>(state -&gt; monad (Tuple value state))</code></p>
<p>We will call this the <code>StateT</code> monad. The <code>T</code> part of the name will become clearer later.</p>
<h2><a class="header" href="#monadic-instances" id="monadic-instances">Monadic Instances</a></h2>
<p>Let's now implement the FAABM type classes by using pattern matching to expose the inner function. The <code>value</code> type will be left undefined (i.e. it's the <code>a</code> in everything), making <code>StateT</code> have the necessary kind, <code>Type -&gt; Type</code>:</p>
<h3><a class="header" href="#functor-2" id="functor-2">Functor</a></h3>
<pre><code class="language-haskell">newtype StateT state monad value =
  StateT (state -&gt; monad (Tuple value state))

-- Let's follow the types. We'll need to return a `StateT` value
-- so we'll start by doing that:
instance (Monad monad) =&gt; Functor (StateT state monad) where
  map :: forall a b
       . (a -&gt; b)
      -&gt; StateT state monad a
      -&gt; StateT state monad b
  map f (StateT g) = StateT -- todo

-- Since StateT wraps a function whose only argument
-- is state, we'll add that now:
instance (Monad monad) =&gt; Functor (StateT state monad) where
  map :: forall a b
       . (a -&gt; b)
      -&gt; StateT state monad a
      -&gt; StateT state monad b
  map f (StateT g) = StateT (\state -&gt;
      -- todo
    )

-- We need to use that function, but it only takes an `a`
-- argument. So, we need to get that `a` by using `g`
-- Thus, we'll pass the returning StateT's state argument into `g`
-- Then we get a `monad (Tuple a state)`
instance (Monad monad) =&gt; Functor (StateT state monad) where
  map :: forall a b
       . (a -&gt; b)
      -&gt; StateT state monad a
      -&gt; StateT state monad b
  map f (StateT g) = StateT (\state -&gt;
      let
        ma = g state
      in
        -- todo
    )
-- So we can use `bind/&gt;&gt;=` to expose the Tuple within this monad
instance (Monad monad) =&gt; Functor (StateT state monad) where
  map :: forall a b
       . (a -&gt; b)
      -&gt; StateT state monad a
      -&gt; StateT state monad b
  map f (StateT g) = StateT (\state -&gt;
      let
        ma = g state
      in
        ma &gt;&gt;= (\(Tuple value state2) -&gt;
          -- todo
        )
    )

-- Great. Now let's pass `value` into the `f` function
instance (Monad monad) =&gt; Functor (StateT state monad) where
  map :: forall a b
       . (a -&gt; b)
      -&gt; StateT state monad a
      -&gt; StateT state monad b
  map f (StateT g) = StateT (\state -&gt;
      let
        ma = g state
      in
        ma &gt;&gt;= (\(Tuple value state2) -&gt;
          let 
            b = f value
          in 
            --todo
        )
    )

-- Now we have our `b`. However, the returned `StateT` needs
-- to wrap a function that returns `monad (Tuple value state)`
-- Let's do that now and finish implementing Functor for StateT
instance (Monad monad) =&gt; Functor (StateT state monad) where
  map :: forall a b
       . (a -&gt; b)
      -&gt; StateT state monad a
      -&gt; StateT state monad b
  map f (StateT g) = StateT (\state -&gt;
      let
        ma = g state
      in
        ma &gt;&gt;= (\(Tuple value state2) -&gt;
          let
            b = f value
          in
            pure (Tuple b state2)
        )
    )
</code></pre>
<h3><a class="header" href="#apply-4" id="apply-4">Apply</a></h3>
<p>Since <code>Apply</code> is very similar to <code>Functor</code> (actually the exact same, but we just unwrap the <code>f</code> now, too), we'll just show the code.</p>
<pre><code class="language-haskell">instance (Monad monad) =&gt; Apply (StateT state monad) where
  apply :: forall a b
        -- (state -&gt; Tuple (a -&gt; b) state)
         . StateT state monad (a -&gt; b)
        -&gt; StateT state monad a
        -&gt; StateT state monad b
  apply (StateT f) (StateT g) = StateT (\s1 -&gt;
    let
      (Tuple value1 s2) = g s1
    in
      let
        (Tuple function s3) = f s2
      in
        let
          mappedValue = function value1
        in
          pure $ Tuple mappedValue s3
        )
      )
    )
</code></pre>
<h3><a class="header" href="#applicative-3" id="applicative-3">Applicative</a></h3>
<p>The Applicative instance is actually quite straight forward:</p>
<pre><code class="language-haskell">instance (Monad monad) =&gt; Applicative (StateT state monad) where
  pure :: forall a. a -&gt; StateT state monad a
  pure a = StateT (\s -&gt; pure $ Tuple a s)
</code></pre>
<h3><a class="header" href="#bind--monad" id="bind--monad">Bind &amp; Monad</a></h3>
<pre><code class="language-haskell">instance (Monad monad) =&gt; Bind (StateT state monad) where
  bind :: forall a b
        . StateT state monad a
       -&gt; (a -&gt; StateT state monad b)
       -&gt; StateT state monad b
  bind (StateT g) f = StateT (\s1 -&gt;
    let
      (Tuple value1 s2) = g s1
    in
      let
        (State h) = f value1
      in
        h s2
      )
    )

-- The Monad instance is just declared since there is nothing to implement.
instance (Monad m) =&gt; Monad (StateT state monad)
</code></pre>
<h3><a class="header" href="#monadstate" id="monadstate">MonadState</a></h3>
<pre><code class="language-haskell">instance (Monad m) =&gt; Monad (StateT state monad) where
  state :: forall value. (state -&gt; Tuple value state) -&gt; StateT state monad value
  state f = StateT (\s -&gt; pure $ f s)
</code></pre>
<h2><a class="header" href="#faabm-using-bind" id="faabm-using-bind">FAABM Using Bind</a></h2>
<p>Notice, however, that the above <code>let ... in</code> syntax is really just a verbose way of doing <code>bind</code>/<code>&gt;&gt;=</code>. If we were to rewrite our instances using <code>bind</code>, they now look like this:</p>
<pre><code class="language-haskell">instance (Monad monad) =&gt; Functor (StateT state monad) where
  map :: forall a b
       . (a -&gt; b)
      -&gt; StateT state monad a
      -&gt; StateT state monad b
  map f (StateT g) = StateT (\s1 -&gt;
      (g s1) &gt;&gt;= (\(Tuple value1 s2) -&gt;
        pure $ Tuple (function value1) s2
      )
    )

instance (Monad monad) =&gt; Apply (StateT state monad) where
  apply :: forall a b
        -- (state -&gt; Tuple (a -&gt; b) state)
         . StateT state monad (a -&gt; b)
        -&gt; StateT state monad a
        -&gt; StateT state monad b
  apply (StateT f) (StateT g) = StateT (\s1 -&gt;
      (g s1) &gt;&gt;= (\(Tuple value1 s2) -&gt;
        (f s2) &gt;&gt;= (\(Tuple function s3) -&gt;
          pure $ Tuple (function value1) s3
        )
      )
    )

instance (Monad monad) =&gt; Applicative (StateT state monad) where
  pure :: forall a. a -&gt; StateT state monad a
  pure a = StateT (\s -&gt; pure $ Tuple a s)

instance (Monad monad) =&gt; Bind (StateT state monad) where
  bind :: forall a b
        . StateT state monad a
       -&gt; (a -&gt; StateT state monad b)
       -&gt; StateT state monad b
  bind (StateT g) f = StateT (\s1 -&gt;
      (g s1) &gt;&gt;= (\(Tuple value1 s2) -&gt;
        let (StateT h) = f value1 in h s2
      )
    )

instance (Monad m) =&gt; Monad (StateT state monad)
</code></pre>
<h2><a class="header" href="#reviewing-statets-bind-instance" id="reviewing-statets-bind-instance">Reviewing StateT's Bind Instance</a></h2>
<p>Let's look in particular at <code>StateT</code>'s <code>bind</code> implmentation as this is crucial to understanding how it enables the syntax we desire:</p>
<pre><code class="language-haskell">instance (Monad monad) =&gt; Bind (StateT state monad) where
  bind :: forall a b
        . StateT state monad a
       -&gt; (a -&gt; StateT state monad b)
       -&gt; StateT state monad b
  bind (StateT g) f = StateT (\s1 -&gt;
      (g s1) &gt;&gt;= (\(Tuple value1 s2) -&gt;
        let
          (StateT h) = f value1
        in
        -- h :: (state -&gt; monad (Tuple value state))
           h s2
      )
    )
</code></pre>
<p>Behind the scenes, <code>StateT</code> is still using <code>Tuple value state</code> as normal. However, the value that is passed to <code>f</code> is the <code>value</code> type (i.e. <code>a</code>) and not <code>Tuple value state</code>.  This is what enables the syntax we desire.</p>
<p>In other words, recall that</p>
<pre><code class="language-haskell">bind (Box 4) (\four -&gt; body)
-- converts to
(Box 4) &gt;&gt;= (\four -&gt; body)
-- which in 'do notation' looks like
four &lt;- (Box 4)
body four
</code></pre>
<p>In the next file, we'll show how this actually works via a graph reduction.</p>
<h1><a class="header" href="#proving-the-syntax" id="proving-the-syntax">Proving the Syntax</a></h1>
<p>This file will prove that the syntax works by doing a graph reduction of</p>
<ul>
<li><code>StateT</code>'s do notation</li>
<li>running a <code>StateT</code> and insuring it type checks.</li>
</ul>
<h2><a class="header" href="#reading-statet-do-notation" id="reading-statet-do-notation">Reading StateT Do Notation</a></h2>
<pre><code class="language-haskell">newtype StateT state monad output = StateT (state -&gt; monad (Tuple output state))

stateT_do_notation :: StateT StateType MonadType ValueType
stateT_do_notation = do

    -- This is what do notation looks like using a StateT monad

    value1 &lt;- state (\initialState -&gt; Tuple value1 state2)
    value2 &lt;- state (\state2       -&gt; Tuple value2 state3)
    value3 &lt;- state (\state3       -&gt; Tuple value3 state4)
    state (\state4 -&gt; Tuple value4 state5)
</code></pre>
<h2><a class="header" href="#reducing-a-statets-do-notation" id="reducing-a-statets-do-notation">Reducing a StateT's Do Notation</a></h2>
<p>It's now time to reduce a simple <code>StateT</code>'s do notation expression into its final result. Here's the simple expression:</p>
<pre><code class="language-haskell">f = do
  value1 &lt;- state (\initialState -&gt; Tuple value1 state2)
  state (\state2 -&gt; Tuple value1 state3)
</code></pre>
<p>It gets ugly pretty quickly, but we present it in a manner that reduces the information overload:</p>
<pre><code class="language-haskell">-- Start!
f = do
  value1 &lt;- state (\initialState -&gt; Tuple value1 state2)
  state (\state2 -&gt; Tuple value1 state3)

-- Turn the &quot;do notation&quot; back to &quot;&gt;&gt;=&quot;
f =
  state (\initialState -&gt; Tuple value1 state2) &gt;&gt;= (\value1 -&gt;
    state (\state2 -&gt; Tuple value1 state3)
  )

-- Convert &quot;&gt;&gt;=&quot; back into &quot;bind&quot;
f =
  bind (state (\initialState -&gt; Tuple value1 state2)) (\value1 -&gt;
    state (\state2 -&gt; Tuple value1 state3)
  )

-- Take the function that is passed to bind, call it &quot;func&quot;,
-- and put it into a 'where' clause:
f = bind (state (\initialState -&gt; Tuple value1 state2)) func
  where
  func = (\value1 -&gt; state (\state2 -&gt; Tuple value2 state3))

-- hide everything but &quot;func&quot;
func = (\value1 -&gt; state (\state2 -&gt; Tuple value2 state3))

-- Recall what StateT's MonadState implementation is...
instance Monad m =&gt; MonadState s (StateT s m) where
  state f = StateT (\sA -&gt; pure $ f sA)
-- ... and use it to replace `state`'s LHS with its RHS
func = (\value1 -&gt; StateT (\sA -&gt; pure $ f sA))
  where
  f = (\state2 -&gt; Tuple value2 state3)

-- bump `f` into `func`
func = (\value1 -&gt; StateT (\sA -&gt; pure $ (\state2 -&gt; Tuple value2 state3) sA ))

-- Rename `pure` to `pureID` to show that it's Identity's &quot;pure&quot;
func = (\value1 -&gt; StateT (\sA -&gt; pureID $ (\state2 -&gt; Tuple value2 state3) sA ))

-- replace &quot;pureID&quot;'s LHS with RHS
func = (\value1 -&gt; StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)))

-- Re-expose main function
f = bind (state (\initialState -&gt; Tuple value1 state2)) func
  where
  func = (\value1 -&gt; StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)))

-- Omit the &quot;where&quot; clause for now,
-- but still keep `func` in the first line so we can come back to it
f = bind (state (\initialState -&gt; Tuple value1 state2)) func

-- Recall what StateT's MonadState implementation is...
instance Monad m =&gt; MonadState s (StateT s m) where
  state f = StateT (\s -&gt; pure $ g s)
-- ... and use it to replace `state`'s LHS with its RHS
f = bind (StateT (\s -&gt; pure $ g s)) func
  where
  g = (\initialState -&gt; Tuple value1 state2)

-- Bump `g` into `f`
f = bind (
      StateT (\sZ -&gt; pure $ (\initialState -&gt; Tuple value1 state2) sZ)
    ) func

-- Rename the &quot;pure&quot; to &quot;pureID&quot; to help us remember that it's Identity's pure
f = bind (
      StateT (\sZ -&gt; pureID $ (\initialState -&gt; Tuple value1 state2) sZ)
    ) func

-- apply &quot;pureID&quot; to its argument
f = bind (
      StateT (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ))
    ) func

-- Recall what StateT's bind instance is...
instance (Monad m) =&gt; Bind (StateT s m) where
  bind :: forall a b. StateT s m a -&gt; (a -&gt; StateT s m b) -&gt; StateT s m b
  bind (StateT g) f = StateT (\sY -&gt; (g sY) &gt;&gt;= func2)
    where
    func2 = (\(Tuple value1 sX) -&gt; let (StateT h) = f    value1 in h sX)
-- ... and replace its LHS with its RHS
f =
    StateT (\sY -&gt; (g sY) &gt;&gt;= func2)
    ) func
    where
    g = (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ)
    func2 = (\(Tuple value1 sX) -&gt; let (StateT h) = func value1 in h sX)

-- Re-expose &quot;func&quot; argument
f = StateT (\sY -&gt; (g sY) &gt;&gt;= func2)
    where
    g = (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ))
    func2 = (\(Tuple value1 sX) -&gt; let (StateT h) = func value1 in h sX)
    func = (\value1 -&gt; StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)))

-- Finished!
finalFunction = StateT (\sY -&gt; (g sY) &gt;&gt;= func2)
    where
    g = (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ))
    func2 = (\(Tuple value1 sX) -&gt; let (StateT h) = func value1 in h sX)
    func = (\value1 -&gt; StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)))
</code></pre>
<h2><a class="header" href="#running-a-statet-with-an-initial-value" id="running-a-statet-with-an-initial-value">Running a StateT with an Initial Value</a></h2>
<p>To run a <code>StateT</code>, we just need to unwarp the <code>StateT</code> newtype wrapper.:</p>
<pre><code class="language-haskell">runStateT :: forall s m a. StateT s m a -&gt; s -&gt; m (Tuple a s)
runStateT (StateT f) initS = f initS
</code></pre>
<h3><a class="header" href="#reducing-a-runstatet-call" id="reducing-a-runstatet-call">Reducing a <code>runStateT</code> Call</a></h3>
<p>We'll run the de-sugared do-notation function from above on some initial state, <code>initS</code>. This won't produce anything important, but shows why/how it still type checks:</p>
<pre><code class="language-haskell">-- From above
f = StateT (\sY -&gt; (g sY) &gt;&gt;= func2)
    where
    g = (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ))
    func2 = (\(Tuple value1 sX) -&gt; let (StateT h) = func value1 in h sX)
    func = (\value1 -&gt; StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)))

-- Now call &quot;runState&quot; with &quot;f&quot; and some initial state
-- where 'm' is Identity
runStateT :: forall s m a. StateFunction s m a -&gt; s -&gt; m (Tuple a s)
runStateT (StateT f) initS = f initS

-- which now becomes
runStateT = (\sY -&gt; (g sY) &gt;&gt;= func2) initS
    where
    g = (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ))
    func2 = (\(Tuple value1 sX) -&gt; let (StateT h) = func value1 in h sX)
    func = (\value1 -&gt; StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)))

-- hide `func2` and `func`
runStateT = (\sY -&gt; (g sY) &gt;&gt;= func2) initS
    where
    g = (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ))

-- apply initialState to the argument
runStateT = (g initS) &gt;&gt;= func2
    where
    g = (\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ))

-- bump &quot;g&quot; to the main function
runStateT = ((\sZ -&gt; Identity ((\initialState -&gt; Tuple value1 state2) sZ)) initS) &gt;&gt;= func2

-- Apply `initS` to the `(\sZ -&gt; body)` function
runStateT = (Identity ((\initialState -&gt; Tuple value1 state2) initS)) &gt;&gt;= func2

-- Apply `initS` to the `(\initialState -&gt; body)` function
runStateT = (Identity (Tuple value1 state2)) &gt;&gt;= func2

-- call Identity's &quot;&gt;&gt;=&quot;
runStateT = func2 (Tuple value1 state2)

-- Re-expose `func2`
runStateT = func2 (Tuple value1 state2)
    where
    func2 = (\(Tuple value1 sX) -&gt; let (StateT h) = func value1 in h sX)

-- bump &quot;func2&quot; into main function
runStateT =
  (\(Tuple value1 sX) -&gt;
        let (StateT h) = func value1
        in h sX
  ) (Tuple value1 initS)

-- apply Tuple argument to the function
runStateT =
  let (StateT h) = func value1
  in h initS

-- Re-expose `func`
runStateT =
  let (StateT h) = func value1
  in h initS

  where
  func = (\value1 -&gt; StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)))

-- bump &quot;func&quot; into main function
runStateT =
  let (StateT h) =
      (\value1 -&gt;
        StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA))
      ) value1
  in h initS

-- apply &quot;value1&quot; to its function
runStateT =
  let (StateT h) =
        StateT (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA))
  in h initS)

-- Use pattern matching to extract the function bound to &quot;h&quot;
runStateT =
  let h = (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA))
  in h initS)

-- and replace the &quot;h&quot; binding with its definition
runStateT =
          (\sA -&gt; Identity ((\state2 -&gt; Tuple value2 state3) sA)) initS

-- Apply &quot;initS&quot; to `(\sA -&gt; body)` function
runStateT =
                  Identity ((\state2 -&gt; Tuple value2 state3) initS))

-- apply &quot;initS&quot; to `(\state2 -&gt; body)` function
runStateT = Identity (Tuple value2 initS)

-- End result!
runStateT :: forall s m a. m (Tuple a s)
runStateT = Identity (Tuple value2 initS)
</code></pre>
<h1><a class="header" href="#overview-2" id="overview-2">Overview</a></h1>
<h2><a class="header" href="#monad-reader" id="monad-reader">Monad Reader</a></h2>
<p><code>MonadAsk</code> is used to expose a read-only value to a monadic context. It's default implmentation is <code>ReaderT</code>:</p>
<pre><code class="language-haskell">             -- r        m     a
newtype ReaderT readOnly monad finalOutput =
  ReaderT (\readOnly -&gt; monad finalOutput)

-- Pseudo-syntax for combining the type class and ReaderT's instance together
class (Monad m) &lt;= MonadAsk r (ReaderT r m) where
  ask   :: forall a. ReaderT r m a
  ask a = ReaderT (\_ -&gt; pure a)
</code></pre>
<h2><a class="header" href="#do-notation" id="do-notation">Do Notation</a></h2>
<p>When writing <code>StateT</code>'s do notation, we have a function called <code>get</code> that does not take any argument but still returns a value:</p>
<pre><code class="language-haskell">stateManipulation :: State Int Int
stateManipulation =
  get
-- which reduces to
  state (\s -&gt; Tuple s s)
-- which reduces to
  StateT (\s -&gt; Identity (Tuple s s))

-- When we run `stateManipulation` with `runState`...
  runState (StateT (\s -&gt; Identity (Tuple s s))) 0
-- it reduces to...
  unboxIdentity $ (\s -&gt; Identity (Tuple s s)) 0
-- which reduces to
  unboxIdentity (Identity (Tuple 0 0))
-- and finally outputs
  Tuple 0 0
</code></pre>
<p><code>MonadAsk</code>'s function works similarly:</p>
<pre><code class="language-haskell">type Settings = { editable :: Boolean, fontSize :: Int }
useSettings :: Reader Settings Settings
useSettings = ask
-- which reduces to...
  ReaderT (\r -&gt; Identity r)

-- When we run `useSettings` with `runReader`
  runReader useSettings { editable: true, fontSize: 12 }
-- it reduces to
  unwrapIdentity $ (\r -&gt; Identity r) { editable: true, fontSize: 12 }
-- which reduces to
  unwrapIdentity (Identity { editable: true, fontSize: 12 })
-- which reduces to
  { editable: true, fontSize: 12 }
</code></pre>
<h2><a class="header" href="#monadreader" id="monadreader">MonadReader</a></h2>
<p><code>MonadReader</code> extends <code>MonadAsk</code> by allowing the read-only value to be modified first before being used in one computation.</p>
<pre><code class="language-haskell">class MonadAsk r m &lt;= MonadReader r m | m -&gt; r where
  local :: forall a. (r -&gt; r) -&gt; m a -&gt; m a
</code></pre>
<h2><a class="header" href="#derived-functions-9" id="derived-functions-9">Derived Functions</a></h2>
<p><code>MonadReader</code> does not have any derived functions.</p>
<p><code>MonadAsk</code> has one derived function:</p>
<ul>
<li><code>asks</code>: apply a function to the read-only value (useful for extracting something out of it, like a field in a settings object)</li>
</ul>
<h2><a class="header" href="#laws-instances-and-miscellaneous-functions" id="laws-instances-and-miscellaneous-functions">Laws, Instances, and Miscellaneous Functions</a></h2>
<p>For the laws, see</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Reader.Class">MonadAsk's docs</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Reader.Class#t:MonadReader">MonadReader's docs</a></li>
</ul>
<p>To see how <code>ReaderT</code> implements its instances</p>
<ul>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L50">Functor instance</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L53">Apply instance</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L56">Applicative instance</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L67">Bind instance</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L100">MonadTell instance</a>, which is implemented using <code>pure</code> (Applicative)</li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L103">MonadReader instance</a>, which is implemented using <a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L45"><code>withReaderT</code> but where <code>r1</code> and <code>r2</code> are the same</a></li>
</ul>
<p>To handle/modify the output of a reader computation:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Reader#v:runReader">Reader</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Reader.Trans#v:runReaderT">ReaderT</a></li>
</ul>
<h1><a class="header" href="#02-monad-ask-examplepurs" id="02-monad-ask-examplepurs">02-Monad-Ask-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadAsk where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Control.Monad.Reader.Class (ask, asks)
import Control.Monad.Reader (Reader, runReader)

main :: Effect Unit
main = log $ runReader useSettings { editable: true, fontSize: 12 }

type Settings = { editable :: Boolean, fontSize :: Int }

                  --   r                 a
            -- ReaderT Settings Identity String
useSettings :: Reader  Settings          String
useSettings = do
  entireSettingsObject &lt;- ask
  specificField &lt;- asks (_.fontSize)

  pure (&quot;Entire Settings Object: &quot; &lt;&gt; show entireSettingsObject &lt;&gt; &quot;\n\
        \Specific Field: &quot; &lt;&gt; show specificField)
</code></pre>
<h1><a class="header" href="#03-monad-reader-examplepurs" id="03-monad-reader-examplepurs">03-Monad-Reader-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadReader where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Control.Monad.Reader.Class (ask, local)
import Control.Monad.Reader (Reader, runReader)

main :: Effect Unit
main = log $ runReader useSettings { editable: true, fontSize: 12 }

type Settings = { editable :: Boolean, fontSize :: Int }

                  --   r                 a
            -- ReaderT Settings Identity String
useSettings :: Reader  Settings          String
useSettings = do
  original &lt;- ask

  output &lt;- local
    -- a function that modifies the read-only value...
    (\settings -&gt; settings { fontSize = 20 })
      -- which is used in only one computation
      ask

  original_ &lt;- ask

  pure (
        &quot;Original: &quot; &lt;&gt; show original &lt;&gt; &quot;\n\
        \Output of computation that uses modified value: &quot; &lt;&gt; show output &lt;&gt; &quot;\n\
        \Back to normal: &quot; &lt;&gt; show original_
        )
</code></pre>
<h1><a class="header" href="#monadstate-1" id="monadstate-1">MonadState</a></h1>
<p><code>MonadState</code> is used to run state manipulating functions. Since only one type implements the class, we'll combine the class' definition and instance into one block:</p>
<pre><code class="language-haskell">newtype StateT state monad output =
  StateT (\state -&gt; monad (Tuple output state))

-- Pseudo syntax: combines class and instance into one block:
class (Monad m) &lt;= MonadState s (StateT s m) where
  state :: forall a. (s -&gt; Tuple a s) -&gt; StateT s m a
  state f = StateT (\s -&gt; pure $ f s)
</code></pre>
<h2><a class="header" href="#reading-its-do-notation" id="reading-its-do-notation">Reading Its Do Notation</a></h2>
<pre><code class="language-haskell">stateT_do_notation :: StateT State Value
stateT_do_notation = do
    value1 &lt;- state (\initialState -&gt; Tuple value1 state2)
    value2 &lt;- state (\state2       -&gt; Tuple value2 state3)
    value3 &lt;- state (\state3       -&gt; Tuple value3 state4)
    state (\state4 -&gt; Tuple value4 state5)
</code></pre>
<h2><a class="header" href="#derived-functions-10" id="derived-functions-10">Derived Functions</a></h2>
<p>As we saw above, whenever we wrote <code>state function</code>, <code>function</code> always had to wrap our output into a <code>Tuple</code> type:</p>
<pre><code class="language-haskell">(\state -&gt; {- do stuff -} Tuple output nextState)
</code></pre>
<p>This gets tedious really fast. Fortunately, <code>MonadState</code>'s derived functions remove that boilerplate and emphasize the developer's intent:</p>
<ul>
<li><code>get</code>: returns the state</li>
<li><code>gets</code>: applies a function to the state and returns the result (useful for extracting some value out of the state)</li>
<li><code>put</code>: overwrites the current state with the argument</li>
<li><code>modify</code>: modify the state and return the updated state</li>
<li><code>modify_</code>: same as <code>modify</code> but return <code>unit</code> so we can ignore the <code>binding &lt;-</code> syntax</li>
</ul>
<pre><code class="language-haskell">sideBySideComparison :: State Int String
sideBySideComparison = do
  state1  &lt;- state (\s -&gt; Tuple s s)
  state2  &lt;- get

  shownI1 &lt;- state (\s -&gt; Tuple (show s) s)
  shownI2 &lt;- gets show

  state (\s -&gt; Tuple unit 5)
  put 5

  added1A &lt;- state (\s -&gt; let s' = s + 1 in Tuple s' s')
  added1B &lt;- modify (_ + 1)

  state (\s -&gt; Tuple unit (s + 1))
  modify_ (_ + 1)

  -- to satisfy the type requirements
  -- in that the function ultimately returns a `String`
  pure &quot;string&quot;
</code></pre>
<p>Returning to our previous example, <code>crazyFunction</code> was implemented like so:</p>
<ol>
<li>Take some <code>initialState</code> value</li>
<li>Pass that value into <code>add1 :: State -&gt; Tuple Int Int</code>, which returns <code>Tuple value1 state2</code></li>
<li>Pass <code>value</code> and <code>state2</code> into <code>addValue1StringLengthTo :: Int -&gt; Int -&gt; Tuple String Int</code> where
<ul>
<li><code>value</code> will be converted into a <code>String</code>, called <code>valueAsString</code></li>
<li>the length of <code>valueAsString</code> will be added to <code>state2</code>, which produces <code>state3</code></li>
<li><code>state3</code> is converted into a <code>String</code>, called <code>value2</code></li>
<li>the function returns <code>Tuple value2 state3</code></li>
</ul>
</li>
<li>Return <code>addStringLengthTo</code>'s output: <code>Tuple value2 nextState3</code></li>
</ol>
<p>With <code>MonadState</code>, we would now write:</p>
<pre><code class="language-haskell">crazyFunction :: State Int String
crazyFunction = do
  value1 &lt;- modify (_ + 1)
  modify_ (_ + (length $ show value1))
  gets show

main :: Effect Unit
main =
  case (runState crazyFunction 0) of
    Tuple theString theInt -&gt; do
      log $ &quot;theString was: &quot; &lt;&gt; theString  -- &quot;2&quot;
      log $ &quot;theInt was: &quot; &lt;&gt; show theInt   --  2

runState :: forall s a. StateT s Identity a -&gt; s -&gt; Tuple a s
runState stateT initialState =
  let (Identity tuple) = runStateT stateT initialState
  in tuple

runStateT :: forall s m a. StateT s m a -&gt; s -&gt; m Tuple a s
runStateT (StateT f) initialState = f initialState
</code></pre>
<h2><a class="header" href="#laws-instances-and-miscellaneous-functions-1" id="laws-instances-and-miscellaneous-functions-1">Laws, Instances, and Miscellaneous Functions</a></h2>
<p>For the laws, see <a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#t:MonadState">MonadState's docs</a></p>
<p>For its instances, see:</p>
<ul>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/State/Trans.purs#L58">Functor</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/State/Trans.purs#L61">Apply</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/State/Trans.purs#L64">Applicative</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/State/Trans.purs#L75">Bind</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/State/Trans.purs#L123">MonadState</a></li>
</ul>
<p>To handle/modify the output of a state computation:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State#v:runState">State</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Trans#v:runStateT">StateT</a></li>
</ul>
<h1><a class="header" href="#02-monad-state-examplepurs" id="02-monad-state-examplepurs">02-Monad-State-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadState where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.Tuple (Tuple(..))
import Data.String.CodePoints (length)
import Control.Monad.State.Class (state, get, gets, put, modify, modify_)
import Control.Monad.State (State, runState)

main :: Effect Unit
main =
  case (runState sideBySideComparison 0) of
    Tuple s i -&gt; do
      log $ &quot;s was: &quot; &lt;&gt; s
      log $ &quot;i was: &quot; &lt;&gt; show i

      case (runState crazyFunction 0) of
        Tuple theString theInt -&gt; do
          log $ &quot;theString was: &quot; &lt;&gt; theString  -- &quot;2&quot;
          log $ &quot;theInt was: &quot; &lt;&gt; show theInt   --  2

crazyFunction :: State Int String
crazyFunction = do
  value1 &lt;- modify (_ + 1)
  modify_ (_ + (length $ show value1))
  gets show

sideBySideComparison :: State Int String
sideBySideComparison = do
  state1  &lt;- state (\s -&gt; Tuple s s)
  state2  &lt;- get

  shownI1 &lt;- state (\s -&gt; Tuple (show s) s)
  shownI2 &lt;- gets show

  state (\s -&gt; Tuple unit 5)
  put 5

  added1A &lt;- state (\s -&gt; let s' = s + 1 in Tuple s' s')
  added1B &lt;- modify (_ + 1)

  state (\s -&gt; Tuple unit (s + 1))
  modify_ (_ + 1)

  -- to satisfy the type requirements
  -- in that the function ultimately returns a `String`
  pure &quot;string&quot;
</code></pre>
<h1><a class="header" href="#overview-3" id="overview-3">Overview</a></h1>
<h2><a class="header" href="#monad-tell" id="monad-tell">Monad Tell</a></h2>
<p><code>MonadTell</code> is used to return additional non-output data that is generated during a computation. It's default implementation is <code>WriterT</code>.</p>
<p>Since we can only return one object and we want to return something in addition to the output, we'll need to return a <code>Tuple</code> that wraps the output and additional data. In cases where we already have non-output data and need to &quot;store&quot; another alue of non-output data, we'll need to combine the two together, which implies a <code>Semigroup</code>. Lastly, to implement <code>Applicative</code>, we will need an &quot;empty&quot; value of that data, which implies <code>Monoid</code>.</p>
<p>Putting this into code, we get this:</p>
<pre><code class="language-haskell">             -- w               m     a
newtype WriterT non_output_data monad output =
  WriterT (monad (Tuple output non_output_data))

-- Pseudo-syntax: combines the type class and instance into one block
class (Monoid w, Monad m) &lt;= MonadTell w (WriterT w m) where
  tell :: w -&gt; m Unit
  tell w = WriterT (pure (Tuple unit w))
</code></pre>
<h2><a class="header" href="#do-notation-1" id="do-notation-1">Do Notation</a></h2>
<p>Since <code>tell</code> returns an <code>m Unit</code>, which will be discarded in do notation, we'll only be writing:</p>
<pre><code class="language-haskell">useReader :: Reader NonOuputData Output
useReader = do                                                          {-
  unit &lt;- tell nonOuputData                                             -}
          tell nonOuputData
  -- without indentation
  tell nonOuputData
</code></pre>
<h2><a class="header" href="#monad-writer" id="monad-writer">Monad Writer</a></h2>
<p><code>MonadWriter</code> extends <code>MonadTell</code> by enabling a computation's non-output data to be</p>
<ul>
<li>appended via <code>tell</code> and then exposed in the do notation for later usage (<code>listen</code>)</li>
<li>appended via <code>tell</code> <strong>after</strong> it is modified by a function (<code>pass</code>)</li>
</ul>
<h2><a class="header" href="#derived-functions-11" id="derived-functions-11">Derived Functions</a></h2>
<p><code>MonadTell</code> does not have any derived functions.</p>
<p><code>MonadWriter</code> has two:</p>
<ul>
<li><code>listens</code>: same as <code>listen</code> but modifies the non-output data before exposing it to the do notation</li>
<li><code>censor</code>: modifies the non-output data returned by a computation before appending it via <code>tell</code>.</li>
</ul>
<h2><a class="header" href="#laws-instances-and-miscellaneous-functions-2" id="laws-instances-and-miscellaneous-functions-2">Laws, Instances, and Miscellaneous Functions</a></h2>
<p>For their laws, see</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Writer.Class#t:MonadTell"><code>MonadTell</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Writer.Class#t:MonadWriter"><code>MonadWriter</code></a></li>
</ul>
<p>For <code>WriterT</code>'s instances:</p>
<ul>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L49">Functor</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L52">Apply</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L57">Applicative</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L68">Bind</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L118">MonadTell</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L121">MonadWriter</a></li>
</ul>
<p>To handle/modify the output of a writer computation:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Writer#v:writer">Writer</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Writer.Trans#v:runWriterT">WriterT</a></li>
</ul>
<h1><a class="header" href="#02-monad-tell-examplepurs" id="02-monad-tell-examplepurs">02-Monad-Tell-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadTell where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.Tuple (Tuple(..))
import Control.Monad.Writer.Class (tell)
import Control.Monad.Writer (Writer, runWriter)

type Output = Int
type OtherUsefulData = String

main :: Effect Unit
main = case runWriter writeStuff of
  Tuple output otherUsefulData -&gt; do
    log $ &quot;Computation's output: &quot; &lt;&gt; show output
    log $ &quot;Other useful data:    &quot; &lt;&gt; otherUsefulData

           -- WriterT w                        a
           -- WriterT String          Identity Int
writeStuff :: Writer  OtherUsefulData          Output
writeStuff = do
  tell &quot;first string! &quot;
  -- some computation happens here
  tell &quot;second string! &quot;
  -- some computation happens here
  tell &quot;third string!&quot;

  pure 5 -- final output of using MonadTell
</code></pre>
<h1><a class="header" href="#03-monad-writer-examplepurs" id="03-monad-writer-examplepurs">03-Monad-Writer-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadWriter where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.Identity (Identity(..))
import Data.Tuple (Tuple(..))
import Control.Monad.Writer.Class (tell, listen, pass, listens, censor)
import Control.Monad.Writer (Writer, runWriter)
import Control.Monad.Writer.Trans (WriterT(..))

main :: Effect Unit
main = case runWriter writeStuff of
  Tuple output otherUsefulData -&gt; do
    log $ &quot;Computation's output: &quot; &lt;&gt; show output
    log $ &quot;Other useful data:\n\n\t&quot; &lt;&gt; otherUsefulData

type Output = Int
type OtherUsefulData = String

                 --   w                 a
           -- WriterT String Identity Int
writeStuff :: Writer  String          Int
writeStuff = do
  (Tuple output1 usefulData) &lt;- listen $ WriterT (
        -- A computation that...
        Identity (
          -- returns this entire object as output,
          -- so that one can use both the computed output
          -- and the OtherUsefulData instance in later computations
          Tuple
            -- the output
            1
            -- the instance, which is appended via `tell` to
            -- the current instance of OtherUsefulData
            &quot;useful data&quot;
        )
    )
  tell $ &quot;\n\n\t&quot; &lt;&gt; &quot;(Listen) 'output1' was: &quot; &lt;&gt; show output1
  tell $ &quot;\n\n\t&quot; &lt;&gt; &quot;(Listen) 'usefulData' was: &quot; &lt;&gt; usefulData
      -- needed to improve reading:
      --  turns &quot;usefulDatasomeData&quot; into
      -- &quot;usefulData&quot; &lt;&gt; &quot;\n\n\t&quot; &lt;&gt; &quot;someData&quot;
      &lt;&gt; &quot;\n\n\t&quot;

  Tuple output2 modifiedData &lt;- listens

    -- 2) ... a modified version of the non-output data
    --          which is not appended via `tell`
    --        before exposing it to the do notation
    (\someData -&gt; &quot;Modified (&quot; &lt;&gt; someData &lt;&gt; &quot;)&quot;) $
    WriterT (
        -- 1) A computation...
        Identity (
          -- 2) that returns this entire object as output...,
          -- so that one can use both the computed output and...
          Tuple
            -- the output (this is `output2`)
            2
            -- the instance, which is appended via `tell` to
            -- the current instance of OtherUsefulData
            &quot;someData&quot;
        )
    )
  tell $ &quot;\n\n\t&quot; &lt;&gt; &quot;(Listens) two: &quot; &lt;&gt; show output2
  tell $ &quot;\n\n\t&quot; &lt;&gt; &quot;(Listens) modified Data: &quot; &lt;&gt; show modifiedData

  output3 &lt;- pass $ WriterT (
      -- A computation...
      Identity (

        -- that returns 3 things using a nested Tuple
        --    nested tuple: (Tuple (Tuple one three) two)
        Tuple
          (Tuple
            -- 1) the computation's output (this is `output3`)
            4
            -- 3) a function which modifies the non-output data
            --    before appending it to the current non-output data
            --    instance
            (\value -&gt; &quot;\n\n\t&quot; &lt;&gt; &quot;(in `pass`) Value is: &quot; &lt;&gt; value)
          )
          -- 2) the non-output data
          &quot;value&quot;
        )
    )

  tell $ &quot;\n\n\t&quot; &lt;&gt; &quot;(Pass) output2 was: &quot; &lt;&gt; show output3
    -- needed to improve reading:
    --  turns &quot;4someData&quot; into
    -- &quot;4&quot; &lt;&gt; &quot;\n\n\t&quot; &lt;&gt; &quot;someData&quot;
    &lt;&gt; &quot;\n\n\t&quot;

  output4 &lt;- censor
      -- 3) a function which modifies the non-output data
      --    before appending it to the current non-output data
      --    instance
      (\value -&gt; &quot;(in `censor`) Value is: &quot; &lt;&gt; value) $ WriterT (
        -- 1) A computation...
        Identity (
          -- ...that returns two things
          Tuple
            -- a) the computation's output (this is `output4`)
            2
            -- b) the non-output data, which is...
            &quot;someData&quot;
        )
      )

  tell $ &quot;\n\n\t&quot; &lt;&gt; &quot;(censor) output3 was: &quot; &lt;&gt; show output4

  pure 0
</code></pre>
<h1><a class="header" href="#overview-4" id="overview-4">Overview</a></h1>
<h2><a class="header" href="#monadthrow" id="monadthrow">MonadThrow</a></h2>
<p><code>MonadThrow</code> is used to immediately stop <code>bind</code>'s sequential computation and return a value of its error type because of some unforeseeable error (e.g. error encountered when connecting to a database, file that was supposed to exist did not exist, etc).</p>
<p>It's default implmentation is <code>ExceptT</code>:</p>
<pre><code class="language-haskell">             -- e     m     a
newtype ExceptT error monad output =
  ExceptT (monad (Either error output))

-- Pseudo-syntax: combines class and instancee together:
class (Monad m) =&gt; MonadThrow e (ExceptT e m) where
  throwError :: forall a. e -&gt; ExceptT e m a
  throwError a = ExceptT (pure $ Left a)
</code></pre>
<h3><a class="header" href="#exceptt-before-and-after" id="exceptt-before-and-after">ExceptT: Before and After</a></h3>
<p>Before using <code>ExceptT</code>, we would write this ugly verbose code:</p>
<pre><code class="language-haskell">getName :: Effect (Either Error String)
getAge :: Effect (Either Error Int)

main :: Effect Unit
main = do
  eitherName &lt;- getName
  case eitherName of
    Left error -&gt; log $ &quot;Error: &quot; &lt;&gt; show error
    Right name -&gt; do
      eitherName &lt;- getAge
      case maybeAge of
        Left error -&gt; log $ &quot;Error: &quot; &lt;&gt; show error
        Right age -&gt; do
          log $ &quot;Got name: &quot; &lt;&gt; name &lt;&gt; &quot; and age &quot; &lt;&gt; show age
</code></pre>
<p>After using <code>ExceptT</code>, we would write this clear readable code:</p>
<pre><code class="language-haskell">getName :: Effect (Either Error String)
getAge :: Effect (Either Error Int)

main :: Effect Unit
main = do
  eitherResult &lt;- runExceptT do
    name &lt;- ExceptT getName
    age &lt;- ExceptT getAge
    pure { name, age }
  case eitherResult of
    Left error -&gt; log $ &quot;Error: &quot; &lt;&gt; show error
    Right rec -&gt; do
      log $ &quot;Got name: &quot; &lt;&gt; rec.name &lt;&gt; &quot; and age &quot; &lt;&gt; show rec.age
</code></pre>
<h2><a class="header" href="#monaderror" id="monaderror">MonadError</a></h2>
<p><code>MonadError</code> extends <code>MonadThrow</code> by enabling a monad to catch the thrown error, attempt to handle it (by changing the error type to an output type), and then continue <code>bind</code>'s sequential computation. If <code>catchError</code> can't handle the error, <code>bind</code>'s sequential computation will still stop at that point and return the value of the error type.</p>
<pre><code class="language-haskell">newtype ExceptT e m a = ExceptT (m (Either e a))

class (Monad m) =&gt; MonadError e (ExceptT e m) where
  catchError :: forall a. ExceptT e m a -&gt; (e -&gt; ExceptT e m a) -&gt; ExceptT e m a
  catchError (ExceptT m) handleError =
    ExceptT (m &gt;&gt;= (\either_E_or_A -&gt; case either_E_or_A of
      Left e -&gt; case handleError e of ExceptT b -&gt; b
      Right a -&gt; pure $ Right a))
</code></pre>
<p>For example,</p>
<pre><code class="language-haskell">getFileContents :: forall m.
                   MonadError m =&gt;
                   String -&gt;
                   m String
getFileContents pathToFile = do
  readFileContents pathToFile `catchError` \fileNotFound -&gt;
    pure defaultValue

  where
    defaultValue = &quot;foo&quot;
</code></pre>
<h2><a class="header" href="#derived-functions-12" id="derived-functions-12">Derived Functions</a></h2>
<p><code>MonadThrow</code> does not have any derived functions.</p>
<p><code>MonadError</code> has 3 functions:</p>
<ul>
<li><code>catchJust</code>: catch only the errors you want to try to handle and ignore the others</li>
<li><code>try</code>: expose the error value (if computation fails) for usage in the do notation</li>
<li><code>withResource</code>: whether a computation fails or succeeds, clean up resources after it is done</li>
</ul>
<h2><a class="header" href="#do-notation-2" id="do-notation-2">Do Notation</a></h2>
<p>Since MonadThrow/MonadError are error-related, we'll show the do notation in meta-language here since it will be harder to do so in the code examples:</p>
<pre><code class="language-haskell">-- MonadThrow
stopped &lt;- throwError e
value1 &lt;- otherComputation stopped
value2 &lt;- otherComputation value1

-- MonadError
mightRun &lt;- computationThatMayFail `catchError` computationWhenPreviousFailed

left_Error   &lt;- try computationThatFails
right_Output &lt;- try computationThatSucceeds

output &lt;- withResource getResource cleanup computationThatUsesResource
</code></pre>
<h2><a class="header" href="#laws-instances-and-miscellaneous-functions-3" id="laws-instances-and-miscellaneous-functions-3">Laws, Instances, and Miscellaneous Functions</a></h2>
<p>For its laws, see</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Error.Class#t:MonadThrow">MonadThrow</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Error.Class#t:MonadError">MonadError</a></li>
</ul>
<p>For <code>ExceptT</code>'s instances, see</p>
<ul>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L55">Functor</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L58">Apply</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L61">Applicative</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L64">Bind</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L111">MonadThrow</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L114">MonadError</a></li>
</ul>
<p>To handle/modify the output of an error computation:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Except#v:runExcept">Except</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Except.Trans#v:runExceptT">ExceptT</a></li>
</ul>
<h1><a class="header" href="#02-monad-throw-examplepurs" id="02-monad-throw-examplepurs">02-Monad-Throw-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadThrow where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.Identity (Identity(..))
import Data.Either (Either(..))
import Control.Monad.Error.Class (throwError)
import Control.Monad.Except (Except, runExcept)
import Control.Monad.Except.Trans (ExceptT(..))

compute :: Except String Int -&gt; Effect Unit
compute theComputation =
  case runExcept theComputation of
    Left error   -&gt; log $ &quot;Failed computation! Error was:  &quot; &lt;&gt; error
    Right output -&gt; log $ &quot;Successful computation! Output: &quot; &lt;&gt; show output

main :: Effect Unit
main = do
  compute $ ExceptT (
    -- A computation
    Identity (
      -- that was successful and produced output
      Right 5
    )
  )

  compute $ ExceptT (
    -- A computation
    Identity (
      -- that failed and produced an error
      Left &quot;Example error!&quot;
    )
  )

  compute (
    -- a successful computation
    (ExceptT (Identity (Right 5))) &gt;&gt;= (\right_five -&gt;
      (throwError &quot;the next bind will never run!&quot;) &gt;&gt;= (\leftE_or_RightA -&gt;
        case leftE_or_RightA of
          Left e -&gt; ExceptT (pure $ Left &quot;This is a different error message!&quot;)
          Right a -&gt; ExceptT (pure $ Right $ a + 5)
      )
    )
  )
</code></pre>
<h1><a class="header" href="#03-monad-error-examplepurs" id="03-monad-error-examplepurs">03-Monad-Error-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadError where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.Identity (Identity(..))
import Data.Either (Either(..))
import Data.Maybe (Maybe(..))
import Control.Monad.Error.Class (catchError, catchJust, try, withResource)
import Control.Monad.Except (Except, runExcept)
import Control.Monad.Except.Trans (ExceptT(..))

main :: Effect Unit
main = do
  runMainFunction
  log &quot;=== Derived Functions ===&quot;
  example_catchJust
  example_try
  example_withResource

computationThatFailsWith :: forall e. e -&gt; Except e Int
computationThatFailsWith error = ExceptT (
    -- A computation
    Identity (
      -- that failed and produced an error
      Left error
    )
  )

computationThatSucceedsWith :: forall e a. a -&gt; Except e a
computationThatSucceedsWith a = ExceptT (
    -- A computation
    Identity (
      -- that succeeded and produced the output
      Right a
    )
  )

compute :: forall e a. Show e =&gt; Show a =&gt; Except e a -&gt; Effect Unit
compute theComputation =
  case runExcept theComputation of
    Left error   -&gt; log $ &quot;Failed computation! Error was:  &quot; &lt;&gt; show error
    Right output -&gt; log $ &quot;Successful computation! Output: &quot; &lt;&gt; show output

runMainFunction :: Effect Unit
runMainFunction = do
  log &quot;catchError:&quot;
  compute (
    catchError
      (computationThatFailsWith &quot;An error string&quot;)

      -- and a function that successfully handles the error
      (\errorString -&gt; ExceptT (pure $ Right 5))
  )

  compute (
    catchError
      (computationThatFailsWith &quot;An error string&quot;)

      -- and a function that cannot handle the error successfully
      (\errorString -&gt; ExceptT (pure $ Left errorString))
  )

-------------------

data ErrorType
  = FailedCompletely
  | CanHandle TheseErrors

data TheseErrors
  = Error1
  | Error2

example_catchJust :: Effect Unit
example_catchJust = do
  log &quot;catchJust:&quot;
  -- fail with an error that we ARE NOT catching...
  compute
    (catchJust
      ignore_FailedCompletely
      (computationThatFailsWith FailedCompletely)

      -- this function is never run because
      -- we ignore the &quot;FailedCompletely&quot; error instance
      handleError
    )

  -- fail with an error that we ARE catching...
  compute
    (catchJust
      ignore_FailedCompletely
      (computationThatFailsWith (CanHandle Error1))

      -- this function is run because we accept the
      -- error instance. It would also work if we threw `Error2`
      handleError
    )


ignore_FailedCompletely :: ErrorType -&gt; Maybe TheseErrors
ignore_FailedCompletely FailedCompletely  = Nothing
ignore_FailedCompletely (CanHandle error) = Just error

handleError :: TheseErrors -&gt; Except ErrorType Int
handleError Error1 = ExceptT (pure $ Right 5)
handleError Error2 = ExceptT (pure $ Right 6)

instance Show ErrorType where
  show FailedCompletely  = &quot;FailedCompletely&quot;
  show (CanHandle error) = &quot;CanHandle2 (&quot; &lt;&gt; show error &lt;&gt; &quot;)&quot;

instance Show TheseErrors where
  show Error1 = &quot;Error1&quot;
  show Error2 = &quot;Error2&quot;

-------------------

example_try :: Effect Unit
example_try = do
  log &quot;try: &quot;
  compute' (try $ computationThatSucceedsWith 5)
  compute' (try $ computationThatFailsWith &quot;an error occurred!&quot;)

-- In `try`, both the error and output isntance is returned,
-- thereby exposing it for usage in the do notation. To account for this,
-- we've modified `compute` slightly below.
-- Also, since we only specify either the error type or the output type above,
-- type inference can't figure out what the other type is. So,
-- it thinks that the unknown type doesn't have a &quot;Show&quot; instance
-- and the compilation fails.
-- Thus, we also specify both types below to avoid this problem.
compute' :: Except String (Either String Int) -&gt; Effect Unit
compute' theComputation =
  case runExcept theComputation of
    Left error   -&gt; log $ &quot;Failed computation! Error was:  &quot; &lt;&gt; show error
    Right e_or_a -&gt; case e_or_a of
      Left e  -&gt; log $ &quot;Exposed error instance in do notation: &quot;  &lt;&gt; show e
      Right a -&gt; log $ &quot;Exposed output instance in do notation: &quot; &lt;&gt; show a

-------------------

data Resource = Resource
instance Show Resource where
  show x = &quot;Resource&quot;

example_withResource :: Effect Unit
example_withResource = do
  log &quot;withResource: &quot;
  compute (
    withResource
      getResource
      cleanupResource
      computationThatUseResource
  )

getResource :: Except String Resource
getResource = computationThatSucceedsWith Resource

cleanupResource :: Resource -&gt; Except String Unit
cleanupResource r =
  -- resource is cleaned up here
  -- and when finished, we return unit
  ExceptT (pure $ Right unit)

computationThatUseResource :: Resource -&gt; Except String Int
computationThatUseResource r = -- do
  -- use resource here to compute some value
  ExceptT (pure $ Right 5)
</code></pre>
<h1><a class="header" href="#an-explanation" id="an-explanation">An Explanation</a></h1>
<p>The following explanation builds upon and modifies <a href="http://www.haskellforall.com/2012/12/the-continuation-monad.html">this article's explanation</a>:</p>
<ul>
<li>Name of original author: Gabriel Gonzalez</li>
<li>License: <a href="https://creativecommons.org/licenses/by/4.0/">CC 4.0 International License</a></li>
<li>Changes:
<ul>
<li>Convert code examples to Purescript</li>
<li>Renamed <code>attackUnit</code> to <code>attack</code> to reduce characters per line in code sections</li>
<li>Omitted section on Algebraic Data Types</li>
<li>Omitted section on Kleisli Composition</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#why-callbacks-exist" id="why-callbacks-exist">Why Callbacks Exist</a></h2>
<p>When writing a library (e.g. GUI toolkit, game engine, etc.), one may want the end-developer to be able to run their own custom code at some point. In the example below, the custom code is represented by the type hole, <code>?doSomething</code>:</p>
<pre><code class="language-haskell">attack :: Target -&gt; Effect Unit
attack target = do
  valid &lt;- isTargetValid target
  if valid
  then ?doSomething target
  else ignoreAttack
</code></pre>
<p>Since the library developer does not know how the end-developer will use this function, they can convert <code>?doSomething</code> into a callback function that the end-developer supplies:</p>
<pre><code class="language-haskell">-- library developer's code
attack :: Target -&gt; (Target -&gt; Effect Unit) -&gt; Effect Unit
attack target doSomething = do
  valid &lt;- isTargetValid target
  if valid
  then doSomething target
  else ignoreAttack

-- end-developer's code
attack orc reduceLifeBy50
</code></pre>
<p>This makes life easy for the library-developer, but not for the end-developer as a large number of nested callbacks can make code very unreadable. (We only need to look at Node.js for an example)</p>
<h2><a class="header" href="#the-continutation-solution" id="the-continutation-solution">The Continutation Solution</a></h2>
<p>The problem is not the callback function; there is no other solution for the library-developer. The problem is &quot;where&quot; that function appears in <code>attackUnit</code>. In short, the type appears in the argument part of the function (<code>attackUnit_arg</code>) instead of in the return part of the function (<code>attackUnit_return</code>):</p>
<pre><code class="language-haskell">-- original version (curried function)
attack ::           Target -&gt;  (Target -&gt; Effect Unit)  -&gt; Effect Unit

-- original version (uncurried function)
attack ::          (Target -&gt;  (Target -&gt; Effect Unit)) -&gt; Effect Unit

-- desugar the last &quot;-&gt;&quot; into &quot;Function&quot;
attack :: Function (Target -&gt;  (Target -&gt; Effect Unit))    Effect Unit

-- make function appear in return type
attack :: Function  Target    ((Target -&gt; Effect Unit)  -&gt; Effect Unit)

-- resugar &quot;-&gt;&quot;
attack ::           Target -&gt; ((Target -&gt; Effect Unit)  -&gt; Effect Unit)
</code></pre>
<p><code>Effect</code> is a monad, so we can chain multiple sequential computations like that together using <code>bind</code>/<code>&gt;&gt;=</code>. If we can do that for <code>Effect</code>, why not do so for every monad? This changes our type signature of <code>attack</code>:</p>
<pre><code class="language-haskell">attack_no_monad ::  Target -&gt; ((Target -&gt; Effect Unit) -&gt; Effect Unit)
attack_monad    ::  Target -&gt; ((Target -&gt; monad  Unit) -&gt; monad  Unit)
</code></pre>
<p>That's a lot of code to write each time, so it can be converted into a <code>newtype</code>:</p>
<pre><code class="language-haskell">newtype ContT return monad input =
  ContT ((input -&gt; monad return) -&gt; monad return)

attack_no_monad ::  Target -&gt; ((Target -&gt; Effect Unit) -&gt; Effect Unit)
attack_monad    ::  Target -&gt; ((Target -&gt; monad  Unit) -&gt; monad  Unit)
attack_cont     ::  Target -&gt; ContT Unit Effect Target
</code></pre>
<p>To create a <code>ContT</code>, we create a function whose only argument is the callback function:</p>
<pre><code class="language-haskell">ContT (\callbackFunction -&gt; do
  -- everything else we did beforehand...
  callbackFunction arg
  -- everything else we did afterwards...
)
</code></pre>
<p>Let's implement it for <code>attack</code> and compare the two approaches:</p>
<pre><code class="language-haskell">attack_original :: Target -&gt; (Target -&gt; Effect Unit) -&gt; Effect Unit
attack_original target doSomething = do
  valid &lt;- isTargetValid target
  if valid
  then doSomething target
  else ignoreAttack

attack_contT ::  Target -&gt; ContT Unit Effect Target
attack_contT target = ContT (\doSomething -&gt; do
    valid &lt;- isTargetValid target
    if valid
    then doSomething target
    else ignoreAttack
  )
</code></pre>
<p>And if we didn't want to use a monad, we could use <code>Identity</code> as a placeholder monad:</p>
<pre><code class="language-haskell">type Cont return input = ContT return Identity input
</code></pre>
<h2><a class="header" href="#comparing-contt-to-another-function" id="comparing-contt-to-another-function">Comparing ContT to Another Function</a></h2>
<p>Let's play with <code>ContT</code> for a bit and see what it reminds us of:</p>
<pre><code class="language-haskell">-- Original version
newtype ContT return monad input =
  ContT ((input -&gt; monad return) -&gt; monad return)

-- Let's newtype a version of `ContT` when `Identity` is its monad:
newtype ContIdentity return input =
  ContIdentity ((input -&gt; Identity return) -&gt; Identity return)

-- Since `Identity` is merely a placeholer monad,
-- let's remove it, and see what the resulting function's signature is:
contDesugared :: forall input return. ((input -&gt; return) -&gt; return)

-- and if we wanted to run `contDesugared`,
-- we'd need an initial `input` value:
runCont :: forall i r. ((i -&gt; r) -&gt; r) -&gt; (i -&gt; r) -&gt; r
runCont contDesugared callbackFunction = contDesugared callbackFunction

-- Hmm... Doesn't that function's type and body look familiar?
--                   ((i -&gt; r) -&gt; r) -&gt; (i -&gt; r) -&gt; r
apply :: forall a b. (a        -&gt; b) -&gt; a        -&gt; b
apply function arg = function arg

infixr 0 apply as $
</code></pre>
<p>Exactly. <code>ContT</code> is just a monad transformer for the <code>apply</code>/<code>$</code> function. Let's compare them further:</p>
<pre><code class="language-haskell">print   10
-- ==
print $ 10
-- ==
apply                print (10)
-- ==
runCont (Cont (\f -&gt; f     (10))) print
-- which reduces to
              (\f -&gt; f     (10))  print
-- which reduces to
                     print (10)
</code></pre>
<h2><a class="header" href="#when-you-need-two-or-more-callback-functions" id="when-you-need-two-or-more-callback-functions">When You Need Two or More Callback Functions</a></h2>
<p>If <code>attack</code> is modified, so that it requires two callback functions, <code>?doSomethingWithDamage</code> and <code>doSomethingWithBoth</code>, it would seem that our nice solution from above would no longer work since we can only specify one of the two functions:</p>
<pre><code class="language-haskell">attackWith :: Target -&gt; Weapon -&gt; ContT Unit Effect Target
attackWith target weapon = ContT (\only1CallbackFunction -&gt; do
    damage &lt;- calculateDamageFor weapon (modifiedBy 1.5)
    ?doSomethingWithDamage damage
    valid &lt;- isTargetValid target
    if valid
    then ?doSomethingWithBoth target damage
    else ignoreAttack
  )
</code></pre>
<p>The solution is to pass in a callback function that takes a sum type as its argument. When using <code>ContT</code>/<code>Cont</code>, the callback function is usually called <code>k</code>, so we'll do that here, too:</p>
<pre><code class="language-haskell">data AllPossibleInputs
  -- where each constructor wraps the arguments
  -- that will be used in a function
  = DoSomethingWithDamage Damage
  | DoSomethingWithBoth Target Damage

-- Note: This approach requires the callback function to return the same
-- `monadType returnType` type for each output.
callbackFunction :: AllPossibleInputs -&gt; Effect Unit
callbackFunction (DoSomethingWithBoth t d) = doSomethingWithBoth t d
callbackFunction (DoSomethingWithDamage d) = doSomethingWithDamage d

doSomethingWithBoth :: Target -&gt; Damage -&gt; Effect Unit
-- implementation

doSomethingWithDamage :: Target -&gt; Effect Unit
-- implementation

attackWith :: Target -&gt; Weapon -&gt; ContT Unit Effect Target
attackWith target weapon = ContT (\callback -&gt; do
    damage &lt;- calculateDamageFor weapon (modifiedBy 1.5)
    callback (DoSomethingWithDamage damage)
    valid &lt;- isTargetValid target
    if valid
    then callback (DoSomethingWithBoth target damage)
    else ignoreAttack
  )
</code></pre>
<p>(I think one might be able to get around the runtime box overhead imposed by <code>AllPossibleInputs</code> by using type-level programming and <code>Variant</code>, the open <code>Either</code> type.)</p>
<h2><a class="header" href="#consider-your-perspective" id="consider-your-perspective">Consider Your Perspective</a></h2>
<table><thead><tr><th>If you are...</th><th>... and you come across a situation where...</th><th>... then you should...</th></tr></thead><tbody>
<tr><td>a library developer</td><td>you want to use a callback function</td><td>move it from the function's LHS to its RHS using <code>ContT</code>. If it should take different kinds of input, define a sum type as demonstrated above.</td></tr>
<tr><td>a developer using a library</td><td>you need to use a function that requires or returns a <code>ContT</code></td><td>understand that you need to specify what to do at specific points by passing in a callback function via <code>runCont</code>/<code>runContT</code>. You may also need to write a callback function that takes a sum type like that demonstrated above as its input</td></tr>
</tbody></table>
<h1><a class="header" href="#monadcont" id="monadcont">MonadCont</a></h1>
<p><code>MonadCont</code>, the Continuation Monad, is used to handle callback hell among other things.</p>
<pre><code class="language-haskell">           -- r      m     a
newtype ContT return monad input =
  ContT ((input -&gt; monad return) -&gt; monad return)

-- Pseudo-Syntax: combine class and instance into one block
-- and &quot;n&quot; represents ContT:
class (Monad m) &lt;= MonadCont r (ContT r m) where
  callCC :: forall a. (forall b. (a -&gt; n b) -&gt; n a) -&gt; n   a
  callCC :: forall a. (forall b. ContT b m a)       -&gt; ContT r m a
</code></pre>
<h2><a class="header" href="#derived-functions-13" id="derived-functions-13">Derived Functions</a></h2>
<p>None!</p>
<h2><a class="header" href="#laws-instances-and-miscellaneous-functions-4" id="laws-instances-and-miscellaneous-functions-4">Laws, Instances, and Miscellaneous Functions</a></h2>
<p>There aren't any laws!</p>
<p>Instances:</p>
<ul>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Cont/Trans.purs#L40">Functor</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Cont/Trans.purs#L43">Apply</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Cont/Trans.purs#L46">Applicative</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Cont/Trans.purs#L49">Bind</a></li>
</ul>
<p>To handle/modify the output of a continuation computation:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Cont#v:cont">Cont</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Cont.Trans#v:runContT">ContT</a></li>
</ul>
<h1><a class="header" href="#03-monad-cont-examplepurs" id="03-monad-cont-examplepurs">03-Monad-Cont-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadCont where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Control.Monad.Cont.Trans (ContT(..), runContT)

-- The sum type example we mentioned beforehand got long
-- and introduces a lot of noise. So, we'll do a very simple
-- example using Effect and `log` instead.
main :: Effect Unit
main = do
  runContT (exampleCallCC 5) log
  log &quot;\n\n&quot;
  runContT (exampleCallCC 20) (\s -&gt; do
    log $ &quot;Indenting the string&quot;
    log $ &quot;\t\t&quot; &lt;&gt; s
    )

exampleCallCC :: Int -&gt; ContT Unit Effect String
exampleCallCC arg = ContT $ \k -&gt; do
  log &quot;do some computations here...&quot;
  k $ &quot;callback with arg: &quot; &lt;&gt; show arg
  log &quot;do some other computations here...&quot;
  k $ &quot;callback with arg: &quot; &lt;&gt; show 1.5
  log &quot;do some other computations here...&quot;
</code></pre>
<h1><a class="header" href="#other-monad-transformers" id="other-monad-transformers">Other Monad Transformers</a></h1>
<h2><a class="header" href="#usable-now" id="usable-now">Usable Now</a></h2>
<h3><a class="header" href="#rws" id="rws">RWS</a></h3>
<p><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.RWS.Trans#t:RWST">RWS</a> a convenience monad that combines <code>ReaderT</code>, <code>WriterT</code>, and <code>StateT</code> into the same monad type</p>
<h3><a class="header" href="#maybet" id="maybet">MaybeT</a></h3>
<p><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Maybe.Trans#t:MaybeT">MaybeT</a>, a computation the returns a <code>Maybe a</code>. The below code snippet shows why you'd use it and when:</p>
<p>Before (ugly verbose code):</p>
<pre><code class="language-haskell">getName :: Effect (Maybe String)
getAge :: Effect (Maybe Int)

main :: Effect Unit
main = do
  maybeName &lt;- getName
  case maybeName of
    Nothing -&gt; log &quot;Didn't work&quot;
    Just name -&gt; do
      maybeAge &lt;- getAge
      case maybeAge of
        Nothing -&gt; log &quot;Didn't work&quot;
        Just age -&gt; do
          log $ &quot;Got name: &quot; &lt;&gt; name &lt;&gt; &quot; and age &quot; &lt;&gt; show age
</code></pre>
<p>After (clear readable code):</p>
<pre><code class="language-haskell">getName :: Effect (Maybe String)
getAge :: Effect (Maybe Int)

main :: Effect Unit
main = do
  result &lt;- runMaybeT do
    name &lt;- MaybeT getName
    age &lt;- MaybeT getAge
    pure { name, age }
  case result of
    Nothing -&gt; log &quot;Didn't work&quot;
    Just rec -&gt; do
      log $ &quot;Got name: &quot; &lt;&gt; rec.name &lt;&gt; &quot; and age &quot; &lt;&gt; show rec.age
</code></pre>
<p>You can refer to <a href="https://mmhaskell.com/monads-6">Monday Morning Haskell's post on MaybeT</a> for more context. Replace <code>IO</code> with <code>Effect</code> and you'll get the idea.</p>
<h3><a class="header" href="#listt" id="listt">ListT</a></h3>
<p><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.List.Trans#t:ListT">ListT</a>, a monad that returns a <code>List a</code>. In addition, it provides the regular list functions you'd expect</p>
<p>It follows the same idea as <code>MaybeT</code> above.</p>
<h3><a class="header" href="#monadgen" id="monadgen">MonadGen</a></h3>
<p><a href="https://pursuit.purescript.org/packages/purescript-gen/2.1.0/docs/Control.Monad.Gen.Class#t:MonadGen">MonadGen</a> (not included in the <code>purescript-transformers</code> library): generates random data. (This is used in the Testing library later. We'll cover it when we get there.)</p>
<h3><a class="header" href="#monadrec" id="monadrec">MonadRec</a></h3>
<p><a href="https://pursuit.purescript.org/packages/purescript-tailrec/4.0.0/docs/Control.Monad.Rec.Class#t:MonadRec">MonadRec</a> (not included in the <code>purescript-transformers</code> library): guarantees stack safety for monad transformers. For a tutorial on this type class, see <code>Design Patterns/Stack Safety.md</code>.</p>
<h2><a class="header" href="#sketches-of-monadic-control-flow" id="sketches-of-monadic-control-flow">Sketches of Monadic Control Flow</a></h2>
<p>I'd like to clean this up and provide more, but I don't know what it's copyright is. Thus, I'm only linking to it here. The below link is a visual idea as to what occurs when one uses some of these monad transformers:
<a href="http://blog.sigfpe.com/2006/10/monads-field-guide.html?m1">Monads, a Field Guide</a></p>
<h2><a class="header" href="#requires-more-understanding" id="requires-more-understanding">Requires More Understanding</a></h2>
<p>We previously mentioned that all lawful type classes that find their roots in Category Theory have duals. The following are monad transformers for the duals of some of the monad transformers we covered here.</p>
<p>To quickly summarize how they work, <code>map</code>ping a monadic function would change its output type whereas <code>map</code>ping a comonadic function would change its input type. If the definition of <code>Functor</code>'s <code>map</code> for a monadic function is <code>compose</code>/<code>&lt;&lt;&lt;</code>, the definition for a comonadic function is <code>composeFlipped</code>/<code>&gt;&gt;&gt;</code>. See the <a href="https://github.com/ChrisPenner/comonads-by-example/tree/master/src/Comonads">CoMonads by Example</a> repository for a better overview of these type classes and their implementations.</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Comonad.Trans.Class">CoMonadTrans</a>, the Transformer type class for Comonads.</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Comonad.Traced.Class#t:ComonadTraced">CoMonadTraced</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Comonad.Store.Class">CoMonadStore</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Comonad.Env.Class#t:ComonadAsk">CoMonadAsk</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Comonad.Env.Class#t:ComonadEnv">CoMonadEnv</a></li>
</ul>
<h1><a class="header" href="#how-monadtrans-works" id="how-monadtrans-works">How MonadTrans Works</a></h1>
<h2><a class="header" href="#reviewing-old-ideas" id="reviewing-old-ideas">Reviewing Old Ideas</a></h2>
<p>Thus far, we've overviewed individual Monad Transformers. However, we have not yet combined them into a &quot;stack&quot; that allows us to write anything useful. It's now time to reveal this. It will look similar to something we've seen before:</p>
<pre><code class="language-haskell">class LiftSourceIntoTargetMonad sourceMonad targetMonad where {-
  liftSourceMonad :: forall a. sourceMonad a -&gt; targetMonad a -}
  liftSourceMonad ::           sourceMonad   ~&gt; targetMonad

instance LiftSourceIntoTargetMonad Box2 Box1 where {-
  liftSourceMonad :: forall a. Box2 a -&gt; Box1 a                      -}
  liftSourceMonad ::           Box2   ~&gt; Box1
  liftSourceMonad (Box2 a) = Box1 a
</code></pre>
<p>When we introduced <code>LiftSourceIntoTargetMonad</code>, we mentioned that implementing this idea for two monads might be much more complicated than the above implementation. Why? Because we were referring to the newtyped function monads we explained in this folder (not exactly something you want to introduce to a new learner immediately).</p>
<p>We stated beforehand that <code>MonadState</code>'s default implmenetation is <code>StateT</code>. <code>bind</code> only returns the same monad type it originally received. Thus, we have a problem if we want to use two effects at once. For example, if we to write a program that uses state manipulation effects (i.e. uses  <code>MonadState</code>) and some other effects in the same computation (i.e. another type class introduced in this folder like <code>MonadReader</code>).</p>
<p>However, because our monadic newtyped functions serve only to &quot;transform&quot; the base monad by handling all the 'behind the scenes' stuff, it's actually possible to support all of these effects within the same monadic type. One monadic type is nested in another. This is where the &quot;stack&quot; idea comes from. In other words, we need to define a way to &quot;lift&quot; a monadic newtyped function into another. However, the direction should go both ways (former lifted into latter and latter lifted into former).</p>
<p>Since this idea is an abstraction that will repeat, will define it as a type class called, <code>MonadTrans</code>:</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a

-- using clearer type names, one should read it as
class MonadTrans transformerCloserToBaseMonad where
  lift :: forall transformerFartherFromBaseMonad a.
          Monad transformerFartherFromBaseMonad =&gt;
          transformerFartherFromBaseMonad a -&gt;
          transformerCloserToBaseMonad transformerFartherFromBaseMonad a
</code></pre>
<h2><a class="header" href="#explaining-its-process" id="explaining-its-process">Explaining Its Process</a></h2>
<ol>
<li>Define a type class (e.g. <code>MonadState</code>) that has a default implementation via (e.g. <code>StateT</code>)</li>
<li>Define a type class (e.g. <code>MonadTrans</code>) that enables one monad to be lifted into another monad</li>
<li>To enable multiple monadic newtyped functions to run in another one (e.g. <code>StateT</code>), implement <code>MonadTrans</code> for that monad (e.g. <a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/State/Trans.purs#L95">StateT's instance</a>)</li>
<li>To grant multiple monadic newtyped functions the capabilities of one type class (e.g. <code>MonadState</code> via <code>StateT</code>), make those other monads implement the one monad's type class (e.g. <code>MonadState</code>) in a special way (see below for a pattern):
<ul>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L106">ReaderT's MonadState Implementation</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L115">WriterT's MonadState Implementation</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L124">ExceptT's MonadState Implementation</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Cont/Trans.purs#L68">ContT's MonadState Implementation</a></li>
</ul>
</li>
</ol>
<p>Looking at those implementations above, we can see a general pattern (there are some exceptions to this due to how the types need to be handled, but this is generally true):</p>
<ul>
<li>Require one of the types in the instance context to be an instance of <code>MonadState</code></li>
<li>Implement the type class by lifting the instance into the monad and delegate that monad's implementation to that instance. Again, the monadic newtyped functions are merely handling the &quot;behind the scenes&quot; stuff of the effects. At the end of the day, it's still the base monad that actually makes the whole thing work.</li>
</ul>
<p>Thus, <code>[Word]T</code> provides a default implementation for <code>Monad[Word]</code> and makes it possible to grant the base monad its capability.</p>
<p>In short, this type class enables us to use all of the functions from each type class explained in this folder</p>
<h1><a class="header" href="#using-monadtrans" id="using-monadtrans">Using MonadTrans</a></h1>
<p>When we wrote code for our <code>MonadState</code> example, we had something that looked like this:</p>
<pre><code class="language-haskell">type Output = Int
type StateType = Int
computation :: State StateType Output
computation = do
  modify_ (_ + 1)
  modify_ (_ * 10)
  modify_ (_ + 1)

main :: Effect Unit
main = case runState computation 0 of
  Tuple output state -&gt; do
    log $ &quot;Result of computation: &quot; &lt;&gt; show output
    log $ &quot;End state of computation: &quot; &lt;&gt; show state
</code></pre>
<p>The above code works because we're using <code>MonadState</code> behind the scenes via <code>StateT</code>'s instance. However, this function's type signature restricts us to only using <code>StateT</code> for computations. If we want to define <code>computation</code>, so that it can use functions from <code>MonadWriter</code>, we'll need to use a different approach. Let's fix this one step at a time.</p>
<p>First, we'll abstract our <code>State</code> type into <code>MonadState</code> by using a type constraint:</p>
<pre><code class="language-haskell">type Output = Int
type StateType = Int
computation :: forall m =&gt; MonadState StateType m =&gt; m Output
computation = do
  modify_ (_ + 1)
  modify_ (_ * 10)
  modify_ (_ + 1)

-- use a helper function to tell the type inferer that
-- `computation`'s `m` type is `StateT`
runProgram :: State StateType Output -&gt; Tuple Output StateType
runProgram s = runState s 0

main :: Effect Unit
main = case runProgram computation of
  Tuple string state -&gt; do
    log $ &quot;Result of computation: &quot; &lt;&gt; string
    log $ &quot;End state of computation: &quot; &lt;&gt; show state
</code></pre>
<p>Second, we'll add another type class constraint for <code>MonadAsk</code> to expose it's <code>tell</code> function:</p>
<pre><code class="language-haskell">type Output = Int
type StateType = Int
type NonOutputData = String
computation :: forall m
          . MonadState StateType m
         =&gt; MonadAsk NonOuputData m
         =&gt; m Output
computation = do
  modify_ (_ + 1)
  tell &quot;Modified state by adding 1&quot;
  currentState &lt;- modify (_ * 10)
  tell $ &quot;Modified state by multiplying by 10. It is now &quot;
    &lt;&gt; show currentState
  modify_ (_ + 1)
</code></pre>
<p>Great! We now have a single computation that can do both state manipulation and use <code>tell</code>. However, how does that affect <code>runProgram</code>?</p>
<pre><code class="language-haskell">runProgram :: StateT_and_WriterT -&gt; StateT_and_WriterT_Output
runProgram s = -- ???
</code></pre>
<p>When we used a monad (e.g. <code>WriterT</code>) to run a computation, we didn't need to specify the monad type being used. So, we used <code>Identity</code> as a placeholder monad and used the type alias, <code>Writer</code>, to make it easier to write. To use another computational monad (e.g. <code>StateT</code>) inside of <code>Writer</code>, we now need to specify what that monad is by re-exposing the <code>T</code> part of <code>WriterT</code> and replacing <code>Identity</code> with <code>StateT</code>. Putting it differently, <code>WriterT</code> is now transforming the monad, <code>StateT</code> with additional effects, which is likewise transforming the base monad, <code>Identity</code> with additional effects:</p>
<pre><code class="language-haskell">-- simple writer computation
writer :: Writer NonOutputData Output -&gt; Tuple NonOuputData Output
writer w = runWriter w

-- re-expose the T part of WriterT
writer :: WriterT NonOutputData Identity Output -&gt; Tuple NonOuputData Output
writer w = runWriter w

-- swap `Identity` with a type alias called Computation
type Computation = Identity
writer :: WriterT NonOutputData Computation Output -&gt; Tuple NonOuputData Output
writer w = runWriterT w

-- Since the types will get long soon, break up the type signature
type Computation = Identity
writer :: WriterT NonOutputData Computation Output
       -&gt; Tuple NonOuputData Output
writer w = runWriterT w

-- StateT with its T exposed but set to Identity still
state :: StateT State Identity Output -&gt; Tuple Output State
state s = runState s initialState

-- re-alias Computation to StateT
-- and use `runWriterT` instead of `runWriter`
type Computation = StateT State Identity Output
writer :: WriterT NonOutputData Computation Output
       -&gt; Tuple NonOuputData Output
writer w = runWriterT w

-- getting rid of the type alias and inlining its type
-- and rename the function's name to 'runProgram'
runProgram :: WriterT NonOutputData (StateT State Identity stateOutput) Output
           -&gt; finalOutput
runProgram ws = ???

-- Realizing that `StateT` with all three of its types specified
-- now has kind &quot;Type&quot; and is thus no longer a monad (&quot;Type -&gt; Type&quot;),
-- we remove the `stateOutput` type to increase
-- StateT's kind from &quot;Type&quot; to &quot;Type -&gt; Type&quot;, making it a monad again
-- so that it satisfies WriterT's monadic type requirement
runProgram :: WriterT NonOutputData (StateT State Identity) Output
           -&gt; finalOutput
runProgram ws = ???

-- To run StateT, we also need an `initialState` argument. Let's add it
runProgram :: WriterT NonOutputData (StateT State Identity) Output
           -&gt; State
           -&gt; finalOutput
runProgram ws initialState = ???
</code></pre>
<p>A few questions arise as we do this:</p>
<ol>
<li>What should <code>finalOutput</code>'s type be if we combine the two monad transformers together?</li>
<li>How should <code>program</code>'s body be implemented?</li>
</ol>
<p>The types give us a few clues for a top-down explanation. First (answering question 2), we realize that <code>State</code>'s monad type is still <code>Identity</code> since no other monad type is inside of <code>StateT</code>. Thus, we know that we'll need to use <code>runState</code> to unpack its results. Using this line of reasoning, we'll also need to use <code>runWriterT</code> instead of <code>runWriter</code> because the <code>WriterT</code> type is using a non-<code>Identity</code> monad.</p>
<p>That leaves us with two possible options:</p>
<ul>
<li><code>runWriterT (runState ws initialState)</code></li>
<li><code>runState (runWriterT ws) initialState</code></li>
</ul>
<p>Second (answering question 1), we know that running a <code>StateT</code> returns <code>Tuple stateOutput state</code> and running a <code>WriterT</code> returns <code>Tuple writerOutput nonOutputData</code>. That means we'll likely get something close to one of these options:</p>
<ol>
<li>Both outputs are returned using a Tuple that groups them together:
<ul>
<li><code>Tuple (Tuple stateOutput state) (Tuple writerOutput nonOutputData)</code> (or vice versa in its order)</li>
</ul>
</li>
<li>The output of one monad is the <code>stateOutput</code> (a) or <code>writerOutput</code> (b) of the other:
<ul>
<li>a: <code>Tuple (Tuple writerOutput nonOutputData) state</code></li>
<li>b: <code>Tuple (Tuple stateOutput  state        ) nonOutputData</code></li>
</ul>
</li>
</ol>
<p>Since we're running one monad inside of another, the second option seems more likely.</p>
<p>The question is, which one is correct?</p>
<p>Let's continue by examining <code>runStateT</code>/<code>runState</code> and <code>runWriterT</code>/<code>runWriter</code>. We know that <code>runMonad</code> is just a wrapper around <code>runMonadT</code> when the monad is <code>Identity</code>:</p>
<pre><code class="language-haskell">newtype StateT s m a =
  StateT (s -&gt; m (Tuple a s))

runState :: StateT state Identity output -&gt; state -&gt; Tuple output state
runState s initialState = unwrapIdentity $ runStateT s initialState

runStateT :: StateT state monad output -&gt; state -&gt; monad Tuple output state
runStateT (StateT function) initialState = function initialState

newtype WriterT w m a =
  WriterT (m (Tuple a w))

runWriter :: WriterT nonOutputData Identity output -&gt; Tuple output nonOutputData
runWriter w = unwrapIdentity $ runWriterT w

runWriterT :: WriterT nonOutputData monad output -&gt; monad Tuple output nonOutputData
runWriterT w = w
</code></pre>
<p>They key takeaway here is that <code>run[Monad]T</code> returns the same monad that is specified in <code>[Monad]T</code>. Looking at our function again...</p>
<pre><code class="language-haskell">runProgram :: WriterT NonOutputData (StateT State Identity) Output
           -&gt; State
           -&gt; finalOutput
runProgram ws initialState = ???
</code></pre>
<p>... running the <code>WriterT NonOuputData monad output</code> via <code>runWriterT</code> will return its <code>monad</code> type. Since that monad type is <code>StateT State Identity Output</code>, we will take the output of running <code>WriterT</code> (which outputs a <code>StateT</code>) and run the output via <code>runState</code> since <code>StateT</code>'s monad type is <code>Identity</code>:</p>
<pre><code class="language-haskell">runProgram :: WriterT NonOutputData (StateT State Identity) Output
           -&gt; finalOutput
runProgram ws = runState (runWriterT ws) initialState
</code></pre>
<p>That answers the second question (how to implement <code>runProgram</code>), but it still leaves us wondering what <code>finalOutput</code> is. This is easier to determine if we just look at <code>runState</code> and <code>runWriterT</code> again:</p>
<pre><code class="language-haskell">runWriterT :: WriterT nonOutputData monad output -&gt; monad Tuple output nonOutputData

-- reducing `monad Tuple output nonOutputData` to something easier, `m a`
type A = Tuple output nonOutputData
runWriterT :: WriterT nonOutputData monad output -&gt; monad A

-- specializing `monad` to `StateT State identity`
type A = Tuple output nonOutputData
runWriterT :: WriterT nonOutputData (StateT state Identity) output
           -&gt; (StateT state Identity A)

-- re-exposing the `a` in `StateT`
runWriterT :: WriterT nonOutputData (StateT state Identity) output
           -&gt; (StateT state Identity (Tuple output nonOutputData))

-- Looking at what `runState` returns, we see
runState :: StateT state Identity output -&gt; state -&gt; Tuple output state

-- Replacing StateT's `output` type with `Tuple output NonOuputData`
-- we get this:
runState :: StateT state Identity (Tuple writerOutput nonOutputData)
         -&gt; state
         -&gt; Tuple (Tuple writerOutput nonOutputData) state

-- Thus, runProgram's type signature is:
runProgram :: WriterT NonOutputData (StateT State Identity Output) Output
           -&gt; State
           -&gt; Tuple (Tuple output NonOuputData) State
runProgram ws initialState =
  runState (runWriterT ws) initialState

-- hidng `StateT`'s monad type, `Identity`, gets us this:
runProgram :: WriterT NonOutputData (State state) Output
           -&gt; state
           -&gt; Tuple (Tuple Output NonOuputData) state
runProgram ws initialState =
  runState (runWriterT ws) initialState
</code></pre>
<h2><a class="header" href="#reordering-the-monad-stack" id="reordering-the-monad-stack">Reordering the Monad Stack</a></h2>
<p>What happens, however, if we flip the order of the stack? We'll see that the arguments get flipped and the output gets flipped.</p>
<pre><code class="language-haskell">runProgram :: StateT state (Writer NonOutputData) Output
           -&gt; state
           -&gt; Tuple (Tuple Output state) NonOuputData
runProgram computation initialState =
  runWriter (runStateT computation initialState)
</code></pre>
<p>While the computation's definition did not change, how the code gets run does change.</p>
<p>This creates one problem with &quot;monad stacks:&quot; the order of how the monad transformers are run can change how the computation is evaluated. We'll cover this in more detail later.</p>
<h1><a class="header" href="#monad-transformer-stacks" id="monad-transformer-stacks">Monad Transformer Stacks</a></h1>
<p>You will want to bookmark this page.</p>
<p>Generalizing the idea we discovered in the previous file into a pattern, we get something like this:</p>
<pre><code class="language-haskell">program :: forall m
         . MonadState StateType m
        =&gt; MonadWriter NonOutputData m
     -- =&gt; other needed type classes here in any order...
        =&gt; m ProgramFinalOutputType
program = do
  -- use all the functions from the type classes

--  StateT state         monad output
-- &quot;IndexN possibleInput monad typeClassOutput&quot;
runProgram :: Index3 input3 (       -- top of the stack
                Index2 input2 (
                  Index1 input1 (
                    Index0 input0   -- =
                      Identity      -- | bottom of the stack (the base monad)
                    output0         -- =
                  ) output1
                ) output2
              ) output3
        -- -&gt; input0      -- =
        -- -&gt; input1      -- | all needed initial args to
        -- -&gt; input2      -- | `run[Word]T`/`runWord` go here
        -- -&gt; input3      -- =
           -&gt; Tuple (
                Tuple (
                  Tuple (
                    Tuple (
                      computationOutput
                      output3
                    )
                    output2
                  )
                  output1
                )
                output0
              )
runProgram program {- args -} =
  runIndex0 (                               -- bottom of the stack
    runIndex1T (
      runIndex2T (
        runIndex3T program index3Args   -- top of the stack
      ) index2Args
    ) index1Args
  ) index0Args
</code></pre>
<p>Note: when using <code>ExceptT</code>, <code>MaybeT</code>, or <code>ListT</code>, the outputs won't necessarily be <code>Tuple</code>s.</p>
<h1><a class="header" href="#monad-trans" id="monad-trans">Monad Trans</a></h1>
<p><code>MonadTrans</code> enables one computational monad to run inside another, thereby exposing multiple type class' functions for usage in <code>bind</code>/<code>&gt;&gt;=</code> / do notation in the same function. It enables one to write an entire program via newtyped function monads (or functions with monadic syntax).</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. m a -&gt; t m a
</code></pre>
<h2><a class="header" href="#laws-10" id="laws-10">Laws</a></h2>
<p><a href="https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.Trans.Class#t:MonadTrans">See its docs</a></p>
<h2><a class="header" href="#instances" id="instances">Instances</a></h2>
<ul>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/State/Trans.purs#L95">StateT</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Reader/Trans.purs#L83">ReaderT</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Writer/Trans.purs#L91">WriterT</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Except/Trans.purs#L99">ExceptT</a></li>
<li><a href="https://github.com/purescript/purescript-transformers/blob/v4.1.0/src/Control/Monad/Cont/Trans.purs#L54">ContT</a></li>
</ul>
<h1><a class="header" href="#02-monad-trans-examplepurs" id="02-monad-trans-examplepurs">02-Monad-Trans-Example.purs</a></h1>
<pre><code class="language-haskell">module ComputingWithMonads.MonadTrans where

import Prelude
import Effect (Effect)
import Effect.Console (log)

import Data.Tuple (Tuple(..))

-- State
import Control.Monad.State.Class (class MonadState, get, gets, modify_)
import Control.Monad.State (State, runState)

-- Writer
import Control.Monad.Writer.Class (class MonadWriter, tell)
import Control.Monad.Writer.Trans (WriterT, runWriterT)

program :: forall m.
           MonadState Int m =&gt;
           MonadWriter String m =&gt;
           m String
program = do
    currentState &lt;- get
    tell $ &quot;Current State is now: &quot; &lt;&gt; show currentState
    modify_ (_ + 10)
    gets show

run :: forall a. WriterT String (State Int) a
    -&gt; Int
    -&gt; Tuple (Tuple a String) Int
run function initialState = runState (runWriterT function) initialState

main :: Effect Unit
main = case run program 0 of
  Tuple (Tuple output nonOutputData) nextState -&gt; do
    log $ &quot;Finished!&quot;
    log $ &quot;(Computation) final output: &quot; &lt;&gt; show output
    log $ &quot;(Writer)   non-output data: &quot; &lt;&gt; show nonOutputData
    log $ &quot;(State)         next state: &quot; &lt;&gt; show nextState

    let (Tuple (Tuple o _ ) _ ) = run program 8
    log $ &quot;Using pattern matching to get the computation's output: &quot; &lt;&gt; show o
</code></pre>
<h1><a class="header" href="#drawbacks-of-mtl" id="drawbacks-of-mtl">Drawbacks of MTL</a></h1>
<p>The following lists some of the issues one will face when using MTL.</p>
<p>Note:</p>
<ul>
<li>Some of the below flaws may be specific only to Haskell and not Purescript.</li>
<li>In the below sources, any mention of Haskell's <code>IORef</code> is equivalent to Purescript's <code>Ref</code>: a global mutable variable.</li>
</ul>
<h2><a class="header" href="#monadstate-allows-only-one-state-manipulation-type" id="monadstate-allows-only-one-state-manipulation-type"><code>MonadState</code> Allows Only One State Manipulation Type</a></h2>
<p>First, due to the functional dependency from <code>m</code> to <code>s</code> in <code>MonadState</code>'s definition, it's impossible to do two different state manipulations within the same function. For example...</p>
<pre><code class="language-haskell">f :: forall m ouput.
  =&gt; MonadState Int m
  =&gt; MonadState String m
  -&gt; m output
f = do
  whichValue &lt;- get
</code></pre>
<p>The compiler will complain because it doesn't know which value it should 'get'. See the answer to <a href="https://stackoverflow.com/a/49782427">Haskell -- Chaining two states using StateT monad transformer</a></p>
<p>One solution to this is to store all states in one larger state type and then use a <code>Lens</code> to access/change it:</p>
<pre><code class="language-haskell">type IntAndString = { i :: Int, s :: String }
f :: forall m output.
  =&gt; MonadState IntAndString m
  -&gt; m output
</code></pre>
<p>The second solution is to use type-level programming to specify which <code>MonadState</code> we are referring to via an <code>id</code> Symbol. This would force us to change <code>MonadState</code>'s definition to:</p>
<pre><code class="language-haskell">class (Monad m) &lt;= MonadState (id :: Symbol) state m | m -&gt; state
  state :: forall a. Proxy id -&gt; (s -&gt; m (Tuple a s)) -&gt; m a

_i :: Proxy &quot;i&quot;
_i = Proxy

_s :: Proxy &quot;s&quot;
_s = Proxy

f :: forall m ouput.
  =&gt; MonadState &quot;i&quot; Int m
  =&gt; MonadState &quot;s&quot; String m
  -&gt; m output
f = do
  theInt &lt;- get _i
  theString &lt;- get _s
</code></pre>
<p>However, I'm not sure what are the pros/cons of this approach, but this is similar to how <code>Run</code> (explained in the <code>Free</code> folder) enables two different state manipulations.</p>
<h2><a class="header" href="#monadstate--monadwriter-lose-their-state-on-a-runtime-error" id="monadstate--monadwriter-lose-their-state-on-a-runtime-error"><code>MonadState</code> &amp; <code>MonadWriter</code> lose their state on a runtime error</a></h2>
<p>If a runtime error occurs in a computation that uses <code>MonadState</code> or <code>MonadWriter</code>, then the states in both <code>MonadState</code> and <code>MonadWriter</code> are lost (because the computation halts).</p>
<h2><a class="header" href="#writert--rwst-has-a-space-leak-problem" id="writert--rwst-has-a-space-leak-problem"><code>WriterT</code> &amp; <code>RWST</code> has a &quot;space leak&quot; problem</a></h2>
<p>This is largely due to <code>WriterT</code>'s usage of <code>Monoid</code>. The 'fix' is to drop some of its features and use a <code>StateT</code> instead. See <a href="https://blog.infinitenegativeutility.com/2016/7/writer-monads-and-space-leaks">Writer Monads and Space Leaks - Infinite Negative Utility</a></p>
<p>Since <code>RWST</code> also encodes things via <code>WriterT</code>, it also suffers from this problem.</p>
<h2><a class="header" href="#n-squared-ish-monad-transformer-instances" id="n-squared-ish-monad-transformer-instances">N-squared-ish Monad Transformer Instances</a></h2>
<p>Whenever one wants to define a new monad transformer (e.g. <code>MonadAuthenticate</code>) to encode some effect, one must define ~<code>n^2</code> instances:</p>
<ul>
<li>1 <code>MonadAuthenticate</code> instance for each <code>[Word]T</code> type via <code>MonadTrans</code> to lift the monadic newtyped <code>AuthenticateT</code> function.</li>
</ul>
<pre><code class="language-haskell">-- Given this stack of monad transformers
runCode :: AuthenticateT Credentials (StateT state (ReaderT value Identity Unit))

-- Each monadic function type (e.g. StateT, ReaderT, etc.) must
-- have an instance for MonadAuthenticate so it can lift the
-- AuthenticateT computation into the next monad.
</code></pre>
<ul>
<li>n instances for the monadic newtyped <code>AuthenticateT</code> function, so that it can lift its computation into all the other monad transformer type classes (e.g. <code>AuthenticateT</code> -&gt; <code>MonadState</code>, <code>MonadWriter</code>, etc.)</li>
</ul>
<pre><code class="language-haskell">-- Given this stack of monad transformers
runCode :: ReaderT Value (StateT state (AuthenticateT Credentials Identity Unit))

-- AuthenticateT must lift ReaderT and StateT into an AuthenticateT
-- monadic type.
</code></pre>
<p>In short, we define that many instances so that the order of the monad stack does not matter <strong>as much</strong>. If our stack has an <code>ExceptT</code> somewhere in there, where that type occurs will change the final output.</p>
<p>Note: I say roughly <strong>~</strong><code>n^2</code> because apparently there are some cases where &quot;lifting&quot; a function would break a law (or something).</p>
<h2><a class="header" href="#monad-transformer-stacks-type-signatures-get-complicated-quickly" id="monad-transformer-stacks-type-signatures-get-complicated-quickly">Monad transformer stacks' type signatures get complicated quickly</a></h2>
<p>Related to the previous point, but the type signatures start getting crazy very quickly. For new beginners who are just learning about monad transformers, this can be quite offsetting:</p>
<pre><code class="language-haskell">-- as an example using pseudo-syntax...
f :: StateT State (ReaderT reader (WriterT writer (ExceptT error Effect output) output))
</code></pre>
<h2><a class="header" href="#the-order-of-the-monad-transformer-stack-matters" id="the-order-of-the-monad-transformer-stack-matters">The Order of the Monad Transformer Stack Matters</a></h2>
<p>We mentioned this previously when covering how to use a monad transformer:</p>
<pre><code class="language-haskell">type Output = Int
type StateType = Int
type NonOutputData = String
computation :: forall m
          . MonadState StateType m
         =&gt; MonadAsk NonOuputData m
         =&gt; m Output
computation = do
  modify_ (_ + 1)
  tell &quot;Modified state by adding 1&quot;
  currentState &lt;- modify (_ * 10)
  tell $ &quot;Modified state by multiplying by 10. It is now &quot;
    &lt;&gt; show currentState
  modify_ (_ + 1)

-- Both `program1` and `program2` support the necessary
-- capabilities to run `computation`.
runProgram1 :: WriterT NonOutputData (State state) Output
            -&gt; state
            -&gt; Tuple (Tuple Output NonOuputData) state
runProgram1 initialState =
  runState (runWriterT computation) initialState

runProgram2 :: StateT state (Writer NonOutputData) Output
            -&gt; state
            -&gt; Tuple (Tuple Output state) NonOuputData
runProgram2 initialState =
  runWriter (runStateT computation initialState)
</code></pre>
<p>Imagine if one of these was <code>ExceptT</code>. That monad transformer's location in the stack can affect how the computation works and whether it works as expected.</p>
<h1><a class="header" href="#the-readertcapability-design-pattern" id="the-readertcapability-design-pattern">The <code>ReaderT</code>/<code>Capability</code> Design Pattern</a></h1>
<h2><a class="header" href="#the-readert-and-capability-design-patterns" id="the-readert-and-capability-design-patterns">The <code>ReaderT</code> and <code>Capability</code> Design Patterns</a></h2>
<p>Some of the drawbacks of MTL (though not all of them) are what led to <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">the <code>ReaderT</code> Design Pattern</a> from which I originally got many of the above problems.</p>
<p>This design pattern was interpreted by others in a different way, so that it led to <a href="https://www.tweag.io/posts/2018-10-04-capability.html">the Capability Design Pattern</a> post.</p>
<p>The main point of the <code>Capability Design Pattern</code> is that the <code>Monad[Word]</code> type classes define what effects will be used in some function, not necessarily how that will be accomplished. This key insight is what makes testing our business logic code much simpler.</p>
<p>For a clearer picture of this idea, see the <a href="https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html">Three Layer Haskell Cake</a>.</p>
<p>Looking at the above from a top-down perspective, we get this:</p>
<table><thead><tr><th>Layer Level</th><th>Onion Architecture Term</th><th>General idea</th></tr></thead><tbody>
<tr><td>Layer 4</td><td>Core</td><td>Strong types with well-defined properties and their pure, total functions that operate on them</td></tr>
<tr><td>Layer 3</td><td>Domain</td><td>the &quot;business logic&quot; code which uses effects</td></tr>
<tr><td>Layer 2</td><td>API</td><td>the &quot;production&quot; or &quot;test&quot; monad which &quot;links&quot; these effects/capabilties to their implementations: (i.e. a newtyped <code>ReaderT</code> and its instances)</td></tr>
<tr><td>Layer 1</td><td>Infrastructure</td><td>the platform-specific framework/monad we'll use to implement some special effects/capabilities (i.e. <code>Node.ReadLine</code>/<code>Halogen</code>/<code>StateT</code>)</td></tr>
<tr><td>Layer 0</td><td>Machine Code<br>(no equivalent onion term)</td><td>the &quot;base&quot; monad that runs the program (i.e. production: <code>Effect</code>/<code>Aff</code>; test: <code>Identity</code>/<code>Trampoline</code>)</td></tr>
</tbody></table>
<p>Putting it into code, we would get something that looks like this:</p>
<pre><code class="language-haskell">-- Layer 4

newtype Name = Name String

getName :: Name -&gt; String
getName (Name s) = s

-- Layer 3

-- Capability type classes:
class (Monad m) &lt;= LogToScreen m where
  log :: String -&gt; m Unit

class (Monad m) &lt;= GetUserName m where
  getUserName :: m Name

-- Business logic that uses these capabilities
-- which makes it easier to test
program :: forall m.
          LogToScreen m =&gt;
          GetUserName m =&gt;
          m Unit
program = do
  log &quot;What is your name?&quot;
  name &lt;- getUserName
  log $ &quot;You name is&quot; &lt;&gt; (getName name)

-- Layer 2 (Production)

-- Environment type
type Environment = { someValue :: Int } -- mutable state, read-only values, etc. go in this record

-- newtyped ReaderT that implements the capabilities
newtype AppM a = AppM (ReaderT Environment Effect a)
derive newtype instance functorTestM    :: Functor AppM
derive newtype instance applyAppM       :: Apply AppM
derive newtype instance Applicative AppM
derive newtype instance bindAppM        :: Bind AppM
derive newtype instance monadAppM       :: Monad AppM
derive newtype instance monadEffect     :: MonadEffect AppM

runApp :: AppM a -&gt; Environment -&gt; Effect a
runApp (AppM reader_T) env = runReaderT reader_T env

-- Layer 1 (the implementations of each instance)
instance LogToScreen AppM where
  log = liftEffect &lt;&lt;&lt; Console.log

instance GetUserName AppM where
  getUserName = liftEffect do
    -- some effectful thing that produces a string
    pure $ Name &quot;some name&quot;

-- Layer 0 (production)
main :: Effect Unit
main = do
  let globalEnvironmentInfo = -- global stuff
  runApp program globalEnvironmentInfo

-----------------------
-- Layer 2 (test)

-- newtyped ReaderT that implements the capabilities for testing
newtype TestM a = TestM (Reader Environment a)
derive newtype instance functorTestM     :: Functor TestM
derive newtype instance applyTestM       :: Apply TestM
derive newtype instance Applicative TestM
derive newtype instance bindTestM        :: Bind TestM
derive newtype instance monadTestM       :: Monad TestM


runTest :: TestM a -&gt; Environment -&gt; a
runTest (TestM reader) env = runReader reader env

-- Layer 1 (test: implementations of instances)
instance LogToScreen TestM where
  log _ = pure unit -- no need to implement this

instance GetUserName TestM where
  getUserName = pure (Name &quot;John&quot;) -- general idea. Don't do this in real code.

-- Layer 0 (test)
main :: Effect Unit
main = do
  let globalEnvironmentInfo = -- mutable state, read-only values, etc.
  assert $ (runTest program globalEnvironmentInfo) == correctValue
</code></pre>
<h2><a class="header" href="#when-to-use-it-readert-design-pattern-vs-monad-transformer-stack" id="when-to-use-it-readert-design-pattern-vs-monad-transformer-stack">When to Use it: ReaderT Design Pattern vs Monad Transformer Stack?</a></h2>
<table><thead><tr><th>Scope of Code</th><th>Example</th><th>Use</th></tr></thead><tbody>
<tr><td>Programming in the large<br>(e.g. Application Structure)</td><td>Connecting impure effects to their pure type classes via an API layer</td><td><code>ReaderT</code></td></tr>
<tr><td>Programming in the small<br>(e.g. a single complicated computation)</td><td>Doing one particular computation that uses a number of effects that others in the surrounding context do not use</td><td>Monad Transformer Stack</td></tr>
</tbody></table>
<h1><a class="header" href="#free-1" id="free-1">Free</a></h1>
<h2><a class="header" href="#overview-5" id="overview-5">Overview</a></h2>
<p>This folder will do 4 things:</p>
<ul>
<li>explain what the Free monad is</li>
<li>explain how it can be used to create a pure abstract syntax tree (AST) and interpret that AST into an impure but useful computation</li>
<li>explain why one should use <code>Run</code> instead of <code>Free</code></li>
<li>explain the limitations of <code>Free</code>/<code>Run</code>.</li>
</ul>
<p><code>Free</code> monads are another way to structure the architecture of your program. However, I wouldn't recommend using this particular way of structuring your program. See this folder's &quot;Drawbacks of Free&quot; for some examples.</p>
<p>Moreover, the gist of <code>Free</code> monads is clearly explained by Nate Faubion in his overview of <code>Free</code> and <code>CoFree</code>: <a href="https://www.youtube.com/watch?v=eKkxmVFcd74&amp;t=18">Unrolling Free &amp; Cofree (stop at 1:19:23)</a> (Actual YouTube video name is &quot;PS Unscripted - Free from Tree &amp; Halogen VDOM&quot;). If you watch that video, you do not need to read through the &quot;Why Use the Free Monad&quot; folder's content.</p>
<p>The <code>Free</code> approach deals with the &quot;<code>bind</code> forces us to return the same monad type it receives&quot; restriction by using only one monad. Rather than building a large function that is composed of smaller functions that runs once the initial arguments are given to it (i.e. <code>MTL</code>), the <code>Free</code> approach will create an Abstract Sytax Tree (AST) that describes the desired computation in a pure way. This tree is later &quot;interpreted&quot; via a <code>NaturalTransformation</code> into a base monad (i.e. <code>Effect</code>) that runs those computations in an inpure way. In other words, something akin to</p>
<pre><code class="language-haskell">type DSL = DomainSpecificLanguage
type AbstractSyntaxTree output = Free DSL output

defineProgram :: AbstractSyntaxTree
defineProgram = -- implementation

runProgram :: AbstractSyntaxTree ~&gt; Effect
runProgram = -- implementation
</code></pre>
<h1><a class="header" href="#what-are-free-sometypeclass-types" id="what-are-free-sometypeclass-types">What Are &quot;Free&quot; <code>SomeTypeClass</code> Types</a></h1>
<p>When we first introduced type classes, we explained that they are an encapsulation of 2-3 things:</p>
<ol>
<li>(always) A definition of 1 or more functions/values' type signatures</li>
<li>(almost always) Laws to which a concrete type's implementation of said type class must adhere</li>
<li>(frequently) Functions that a type obtains for free once the core defintion/values are implemented</li>
</ol>
<p>Moreover, some type classes combine two or more type classes together</p>
<p>Thus, <code>SomeTypeClass</code> isn't so much a 'thing' as much as it is an expectation. We don't say that <code>f</code> <strong>is</strong> a <code>SomeTypeClass</code> (for it could implement it in various ways); rather, we are really saying that <code>f</code> <strong>has</strong> an instance that implements <code>SomeTypeClass</code>'s <code>specialFunction</code> function in such a way that it adheres to <code>SomeTypeClass</code>'s laws. As we saw from the MTL folder, even <code>StateT</code>, a newtyped function, can be called a <code>Functor</code> because it meets all of these requirements.</p>
<p>However, whenever we had a type that we wanted to use in a <code>Functor</code>-like way, we needed to define its <code>Functor</code> instance before we could use it in that way. In other words, we have to write a lot of boilerplate code.</p>
<p>What if we could grant <code>Functor</code>-like capabailities for any type without implementing such an instance? That is the idea behind &quot;free&quot; type classes.</p>
<p>Essentially, a &quot;free&quot; <code>TypeClassName</code> is a box-like type, <code>Wrapper</code>, that grants <code>TypeClassName</code>-capabilities to some other type, <code>A</code>, by providing the necessary structure for implementing a law-abiding <code>TypeClassName</code> instance for <code>Wrapper</code>.</p>
<p>In short, to create a &quot;free&quot; <code>SomeTypeClass</code>, we do 2 things:</p>
<ol>
<li>Translate the type class into a higher-kinded type</li>
<li>Do the following for each of the type class' functions, starting with the easiest function:
<ul>
<li>Translate one type class' function into a constructor for the new type</li>
<li>Try to implement all required instances using the constructor</li>
<li>Fix problems that arise</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#a-free-monoid" id="a-free-monoid">A &quot;Free&quot; Monoid</a></h2>
<p>When we look at <code>Monoid</code>, we see this type class:</p>
<pre><code class="language-haskell">class Monoid a where                                                    {-
  append :: a -&gt; a -&gt; a       -- include Semigroup's function           -}
  mempty :: a

-- &quot;hello&quot; &lt;&gt; &quot;world&quot; == &quot;helloworld&quot;
-- &quot;hello&quot; &lt;&gt; mempty  == &quot;hello&quot;
-- mempty  &lt;&gt; &quot;hello&quot; == &quot;hello&quot;
</code></pre>
<p>Let's follow the instructions from above: First, we'll translate the type class into a data type that can take any type:</p>
<pre><code class="language-haskell">data FreeMonoid a
</code></pre>
<p>Second and starting with the easier function <code>mempty</code>, we'll translate it into a constructor for <code>FreeMonoid</code>. <code>mempty</code> is easy, since it translates into a placeholder constructor:</p>
<pre><code class="language-haskell">data FreeMonoid a
  = Mempty

instance Semigroup (FreeMonoid a) where
  append a Mempty = a
  append Mempty a = a

instance Monoid (FreeMonoid a) where
  mempty = Mempty
</code></pre>
<p><code>append</code> is a bit harder. We need to store a value of type <code>a</code>, so we can try this:</p>
<pre><code class="language-haskell">data FreeMonoid a
  = Mempty
  | Append a
</code></pre>
<p>However, if we try to implement this as <code>(Append a1) &lt;&gt; (Append a2)</code>, we can't combine <code>a1</code> and <code>a2</code>. Rather, we need to store both an <code>a1</code> and an <code>a2</code> in a single <code>Append</code>:</p>
<pre><code class="language-haskell">data FreeMonoid a
  = Mempty
  --       a1 a2
  | Append a  a

-- since `Mempty` is our placeholder instance, we can use it
-- to fill the a2's spot

instance Semigroup (FreeMonoid a) where
  append Mempty Mempty = Mempty
  append a Mempty = a
  append Mempty a = a
  append (Append a1 Mempty) (Append a2 Mempty) = Append a1 a2

-- Works!
(Append a1 Mempty) &lt;&gt; (Append a2 Mempty) == Append a1 a2
-- ...well, not quite!
(Append a1 a2) &lt;&gt; (Append a3 Mempty) == -- ???
</code></pre>
<p>Our previous solution doesn't work either. If the failure case above is just another append, we get something like this:
<code>((Append a1 Mempty) &lt;&gt; (Append a2 Mempty)) &lt;&gt; (Append a3 Mempty)</code>
Rather than defining a second <code>a</code> for <code>Append</code>, what if we nested the types together? This approach makes our code finally work:</p>
<pre><code class="language-haskell">data FreeMonoid a
  = Mempty
  --       a1  Mempty / Append a
  | Append a  (FreeMonoid a     )

instance Semigroup (FreeMonoid a) where
  append Mempty Mempty = Mempty
  append a Mempty = a
  append Mempty a = a
  append (Append a memptyOrAppend) otherAppend =
    Append a (memptyOrAppend &lt;&gt; otherAppend)

instance Monoid (FreeMonoid a) where
  mempty = Mempty
</code></pre>
<p>The above code is the exact same thing as a familiar data type, <code>List</code>:</p>
<pre><code class="language-haskell">data List a
  = Nil
  | Cons a (List a)

instance Semigroup (List a) where
  append Nil Nil = Nil
  append a Nil = a
  append Nil a = a
  append (Cons head tail) otherList =
    Cons head (tail &lt;&gt; otherList)

instance Monoid (List a) where
  mempty = Nil
</code></pre>
<p>Thus, we say that <code>List</code> is a &quot;free&quot; monoid because by wrapping some type (e.g. <code>Fruit</code>) into a <code>List</code>, we get a monoid instance for <code>Fruit</code> for free:</p>
<pre><code class="language-haskell">data Fruit
  = Apple
  | Orange
  | Banana

(Cons (Apple Nil)) &lt;&gt; (Cons Banana Nil) == Cons (Apple (Cons Banana Nil))
</code></pre>
<p>This idea can be useful for when we have types that can't implement specific type classes.</p>
<h1><a class="header" href="#what-is-and-is-not-the-free-monad" id="what-is-and-is-not-the-free-monad">What Is and Is Not The Free Monad</a></h1>
<p>Since <code>List</code> was the free monoid type, what would be the free monad type?</p>
<pre><code class="language-haskell">-- monad class fully expanded...
class Monad f where
  map   :: forall a. (a -&gt; b) -&gt; f a -&gt; f b
  apply :: forall a. f (a -&gt; b) -&gt; f a -&gt; f b
  bind  :: forall a. f a -&gt; (a -&gt; f b) -&gt; f b
  pure  :: forall a. a -&gt; f a
</code></pre>
<p>Using our previous instructions...</p>
<blockquote>
<p>In short, to create a &quot;free&quot; <code>SomeTypeClass</code>, we do 3 things:</p>
<ol>
<li>Translate the type class into a higher-kinded type</li>
<li>Do the following for each of the type class' functions, starting with the easiest function:
<ul>
<li>Translate one type class' function into a constructor for the new type</li>
<li>Try to implement all required instances using the constructor</li>
<li>Fix problems that arise</li>
</ul>
</li>
</ol>
</blockquote>
<p>We'll start with the simplest function, <code>pure</code>:</p>
<pre><code class="language-haskell">data FreeMonad a
  = Pure a

instance Applicative FreeMonad where
  pure a = Pure a

instance Functor FreeMonad where
  map f (Pure a) = Pure (f a)

instance Apply FreeMonad where
  apply (Pure f) (Pure a) = Pure (f a)

instance Bind FreeMonad where
  bind (Pure a) f = f a
</code></pre>
<p>Well, that was easy... Wasn't this the same implementation as <code>Identity</code> from before? You are correct.</p>
<pre><code class="language-haskell">data Identity a = Identity a

instance Applicative Identity where
  pure a = Identity a

instance Functor Identity where
  map f (Identity a) = Identity (f a)

instance Apply Identity where
  apply (Identity f) (Identity a) = Identity (f a)

instance Bind Identity where
  bind (Identity a) f = f a
</code></pre>
<p>We can see here that <code>Identity</code> is a free <code>Functor</code>, <code>Apply</code>, <code>Applicative</code>, <code>Bind</code>, and therefore <code>Monad</code> for any type with kind <code>Type</code>.</p>
<p>However, that's not what others mean when they talk about <strong>the</strong> free <code>Monad</code> type. The <code>Free</code> monad makes any <code>Functor</code> (i.e. type with kind <code>Type -&gt; Type</code>) a monad.</p>
<p>There are other &quot;free&quot; type classes (mentioned below). AFAIK, these types were not discovered at the same time by the same people. Rather, they were discovered over time as solutions to specific problems. See below for these types:</p>
<ul>
<li>Coyoneda - <a href="https://pursuit.purescript.org/packages/purescript-free/5.2.0/docs/Data.Coyoneda#t:Coyoneda">docs</a> &amp; <a href="https://github.com/purescript/purescript-free/blob/v5.1.0/src/Data/Coyoneda.purs#L32">source code</a> - a free <code>Functor</code> for any type of kind <code>Type -&gt; Type</code>.</li>
<li>FreeAp - <a href="https://pursuit.purescript.org/packages/purescript-freeap/5.0.1/docs/Control.Applicative.Free">docs</a> &amp; <a href="https://github.com/ethul/purescript-freeap/blob/v5.0.1/src/Control/Applicative/Free.purs#L22-L25">source code</a> - a free <code>Applicative</code> for any type of kind <code>Type -&gt; Type</code>. Here's the <a href="https://arxiv.org/pdf/1403.0749.pdf">related paper</a>, which will likely make more sense once we explain how the <code>Free</code> monad works.</li>
<li>Free (the original version) - a free <code>Monad</code> for any <code>Functor</code>. Its implementation suffers from big performance problems when run.</li>
<li>Free (reflection without remorse) - <a href="https://pursuit.purescript.org/packages/purescript-free/5.2.0/docs/Control.Monad.Free#t:Free">docs</a> &amp; <a href="https://github.com/purescript/purescript-free/blob/v5.1.0/src/Control/Monad/Free.purs#L37-L37">source code</a> - a free <code>Monad</code> for any <code>Functor</code>. Its implementation removes the performance penalties of the original version and includes all of the optimizations discovered by Oleg Kiselyov (as stated by someone on the Slack channel).</li>
</ul>
<p>At this time, <code>Coyoneda</code> and <code>FreeAp</code> will not be discussed in this folder. Rather, the upcoming files will focus entirely on the <code>Free</code> monad.</p>
<h1><a class="header" href="#the-original-free-monad" id="the-original-free-monad">The Original Free Monad</a></h1>
<p>Rather than explaining how one can eventually reason their way through defining what the type is for the original <code>Free</code> monad (a bottom-up approach), we'll simply show its definition, its instances, and demonstrate why it has to work that way (a top-down approach).</p>
<pre><code class="language-haskell">data Free f a
  = Pure a
  | Impure (f (Free f a))
</code></pre>
<p>Let's say that <code>Identity</code> is our <code>f</code>/<code>Functor</code> type. What does a concrete value of the <code>Free</code> data type look like?</p>
<pre><code class="language-haskell">Impure ( Identity (
  Impure ( Identity (
    Impure ( Identity (
      Pure a
    ))
  ))
))
</code></pre>
<p>In other words, <code>Free</code> is just a tree-like data structure of nested <code>Identity</code> values (the branches in our tree) that eventually wrap a final value (the leaf in our tree). In our current example, the tree is unbalanced, so that it appears more like a linked-list than a tree:</p>
<pre><code class="language-haskell">{- Impure ( -} Identity (
  {- Impure ( -} Identity (
    {- Impure ( -} Identity (
      {- Pure -}     a
    {- ) -}        )
  {- ) -}        )
{- ) -}        )
</code></pre>
<p>The only difference is that <code>Identity</code> itself is wrapped in another type. So how do we change a value that is wrapped in a box-like type? We use <code>Functor</code>'s <code>map</code>, of course! We'll use <code>map</code> in most of <code>Free</code>'s instances for the needed type classes:</p>
<pre><code class="language-haskell">-- easiest one!
instance Applicative (Free f) where
  pure a = Pure a

-- a &lt;#&gt; f == mapFlipped a f == map f a
instance (Functor f) =&gt; Functor (Free f) where
  map f (Pure a) = Pure (f a)
  map f (Impure f_of_Free) =
    Impure (f_of_Free &lt;#&gt; (
      -- recursively call `map` on nested `Impure` values
      -- until we get a `Pure` value of Free
      \pure_A -&gt; map f pure_A
      -- which applies the function to the `a`
      -- and then rewraps the `Impure` values
    ))
</code></pre>
<p>Let's see <code>map</code> in action via a graph reduction:</p>
<pre><code class="language-haskell">-- Start!
map f (
  Impure ( Identity (
    Impure ( Identity (
      Pure 5
    ))
  ))
)
-- Recursively apply `map` until we get a `Pure` value
-- 1.
      (
  Impure ( map f Identity (
    Impure ( Identity (
      Pure 5
    ))
  ))
)
-- 2.
       (
   Impure ( Identity (
     map f Impure ( Identity (
       Pure 5
     ))
   ))
 )
-- 3.
      (
   Impure ( Identity (
     Impure ( map f Identity (
       Pure 5
     ))
   ))
 )
-- 4.
       (
   Impure ( Identity (
     Impure ( Identity (
       map f (Pure 5)
     ))
   ))
 )
-- Now apply the function to pure's value
        (
   Impure ( Identity (
     Impure ( Identity (
       Pure (f 5)
     ))
   ))
 )
-- End definition
map f (
  Impure ( Identity (
    Impure ( Identity (
      Pure a
    ))
  ))
)
==
  Impure ( Identity (
    Impure ( Identity (
      Pure (f a)
    ))
  ))
</code></pre>
<p>Let's look at the <code>Apply</code> instance now:</p>
<pre><code class="language-haskell">instance (Functor f) =&gt; Apply (Free f) where
  apply (Pure f) (Pure a) = Pure (f a)
  apply (Impure f_of_Free_F) pure_A =
    Impure (f_of_Free_F &lt;#&gt; (
      -- recursively call `apply` on nested `Impure` values
      -- until we get a `Pure` value of Free
        \pure_F -&gt; apply pure_F pure_A
      -- apply the function and then rewrap `Impure` values
    ))
  apply pure_F (Impure f_of_Free)  =
    Impure (f_of_Free &lt;#&gt; (
      -- recursively call `apply` on nested `Impure` values
      -- until we get a `Pure` value of Free
        \pure_A -&gt; apply pure_F pure_A
      -- apply the function and then rewrap `Impure` values
    ))
</code></pre>
<p>Let's see <code>apply</code> in action via a graph reduction:</p>
<pre><code class="language-haskell">-- Reminder: function arg == arg # function

-- Start
--    &quot;Left&quot; Impure            &quot;Right&quot; Impure
apply (Impure (Identity (Pure f))) (Impure (Identity (Pure a)))
-- Use `map` to recursively call `apply` on the left Impure until we get the
-- Pure value
Impure ((Identity (Pure f)) &lt;#&gt; (\pure_F  -&gt; apply pure_F (Impure (Identity (Pure a)))))
Impure (Identity ((Pure f)   #  (\pure_F  -&gt; apply pure_F (Impure (Identity (Pure a)))))
-- apply `Pure f` to the function
Impure (Identity (             (\(Pure f) -&gt; apply (Pure f) (Impure (Identity (Pure a)))))
Impure (Identity (                           apply (Pure f) (Impure (Identity (Pure a)))))
-- Remove the extra whitespace
Impure (Identity (apply (Pure f) (Impure (Identity (Pure a)))))

-- Now use `map` to recursiveely call `apply` on the right Impure until we get
-- Pure value
Impure (Identity (Impure ((Identity (Pure a) &lt;#&gt; (\pure_A  -&gt; apply (Pure f) pure_A))))
Impure (Identity (Impure (Identity ((Pure a)  #  (\pure_A  -&gt; apply (Pure f) pure_A))))
-- apply `Pure a` to the function
Impure (Identity (Impure (Identity (            (\(Pure a) -&gt; apply (Pure f) (Pure a))))))
Impure (Identity (Impure (Identity (                          apply (Pure f) (Pure a) ))))
-- Remove thee extra whitespace
Impure (Identity (Impure (Identity (apply (Pure f) (Pure a)))))
-- Look up the instance
--    apply (Pure f) (Pure a) = Pure (f a)
-- and replace the LHS with the RHS
Impure (Identity (Impure (Identity (Pure (f a)))))
</code></pre>
<p>Now let's define <code>Bind</code>, again using the <code>map</code> recursively:</p>
<pre><code class="language-haskell">instance (Functor f) =&gt; Bind (Free f) where
  bind (Pure a) f = f a
  bind (Impure f_of_Free) f =
    Impure (f_of_Free &lt;#&gt; (
      -- recursively call `bind` on nested `Impure` values
      -- until we get a `Pure` value of Free
      \pure_A -&gt; bind pure_A f
      -- apply the function and then rewrap `Impure` values
    ))
</code></pre>
<p>Let's see <code>bind</code> in action via a graph reduction:</p>
<pre><code class="language-haskell">-- Start!
bind (Impure ( Identity (Pure a))) f

-- Recursively call `bind` via `map` until reach a `Pure` value:
bind (Impure ( Identity  (Pure a))) f
      Impure ((Identity  (Pure a)) &lt;#&gt; (\pure_a -&gt; bind pure_a f) )
      Impure ( Identity ((Pure a)   #  (\pure_a -&gt; bind pure_a f)))
-- Apply `Pure a` to the function
      Impure ( Identity (              (           bind (Pure a) f)))
      Impure ( Identity (                          bind (Pure a) f))
-- remove extra white space
Impure ( Identity (bind (Pure a) f))
-- Look up the instance
--    bind (Pure a) f = f a
-- and replace the LHS with the RHS
Impure ( Identity (Pure (f a)))
</code></pre>
<h2><a class="header" href="#definition-of-free-monad" id="definition-of-free-monad">Definition of Free Monad</a></h2>
<p>Putting it all together, we get this:</p>
<pre><code class="language-haskell">data Free f a
  = Pure a
  | Impure (f (Free f a))

instance Applicative (Free f) where
  pure a = Pure a

instance (Functor f) =&gt; Functor (Free f) where
  map f (Pure a) = Pure (f a)
  map f (Impure f_of_Free) =
    Impure (f_of_Free &lt;#&gt; (
      -- recursively call `map` on nested `Impure` values
      -- until we get a `Pure` value of Free
      \pure_A -&gt; map f pure_A
      -- which applies the function to the a
      -- and then rewraps the `Impure` values
    ))

instance (Functor f) =&gt; Apply (Free f) where
  apply (Pure f) (Pure a) = Pure (f a)
  apply (Impure f_of_Free_F) pure_A =
    Impure (f_of_Free_F &lt;#&gt; (
      -- recursively call `apply` on nested `Impure` values
      -- until we get a `Pure` value of Free
        \pure_F -&gt; apply pure_F pure_A
      -- apply the function and then rewrap `Impure` values
    ))
  apply pure_F (Impure f_of_Free)  =
    Impure (f_of_Free &lt;#&gt; (
      -- recursively call `apply` on nested `Impure` values
      -- until we get a `Pure` value of Free
        \pure_A -&gt; apply pure_F pure_A
      -- apply the function and then rewrap `Impure` values
    ))

instance (Functor f) =&gt; Bind (Free f) where
  bind (Pure a) f = f a
  bind (Impure f_of_Free) f =
    Impure (f_of_Free &lt;#&gt; (
      -- recursively call `bind` on nested `Impure` values
      -- until we get a `Pure` value of Free
      \pure_A -&gt; bind pure_A f
      -- apply the function and then rewrap `Impure` values
    ))
</code></pre>
<p>The next file will explain why this implementation has performance problems.</p>
<h1><a class="header" href="#the-remorseless-free-monad" id="the-remorseless-free-monad">The Remorseless Free Monad</a></h1>
<p>What follows is a quick summary of the <a href="http://okmij.org/ftp/Haskell/zseq.pdf">Reflection without Remorse</a> paper. This summary:</p>
<ul>
<li>explains what's at the heart of the original <code>Free</code>'s performance problem</li>
<li>explains using a very high-level &quot;read the paper if you want to understand the 'type magic'&quot; explanation for how the &quot;reflection without remorse&quot; version of <code>Free</code> fixes that performance problem.</li>
</ul>
<h2><a class="header" href="#similar-shapes-the-free-monoid-and-the-free-monad" id="similar-shapes-the-free-monoid-and-the-free-monad">Similar Shapes: The Free Monoid and the Free Monad</a></h2>
<p>Surpisingly, these two &quot;free&quot; types bear a similar resemblence:</p>
<pre><code class="language-haskell">data List a   = Nil    | Cons    a (List a  )
data Free f a = Pure a | Impure (f (Free f a))
</code></pre>
<p>A list is just an unbalanced tree. Thus, <code>Free</code> is essentially the same as <code>List</code>, except that it stores a higher-kinded type (kind <code>Type -&gt; Type</code>) rather than a concrete type (kind <code>Type</code>)</p>
<p>This similarity will be used to explain why <code>Free</code> has performance problems.</p>
<h2><a class="header" href="#the-direction-matters" id="the-direction-matters">The Direction Matters</a></h2>
<p>Let's talk about <code>Semigroup</code>:</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a

infix 4 append as &lt;&gt;

instance Semigroup Int where
  append i1 i2 = i1 + i2
</code></pre>
<p><code>Semigroup</code> requires its implementation to adhere to the law of association, meaning that, when <code>append</code> is used on the output of a previous <code>append</code> and some other value, the location of the parenthenses don't matter:</p>
<pre><code class="language-haskell">1 &lt;&gt; 2 &lt;&gt; 3 &lt;&gt; 4 &lt;&gt; 5 &lt;&gt; 6 &lt;&gt; 7 &lt;&gt; 8

-- no association: Tree-like structure
-- Start
  1 &lt;&gt; 2  &lt;&gt;  3 &lt;&gt; 4   &lt;&gt;   5 &lt;&gt; 6 &lt;&gt;   7 &lt;&gt; 8
-- Add parentheesis, starting from the 'leaves'
 (1 &lt;&gt; 2) &lt;&gt; (3 &lt;&gt; 4)  &lt;&gt;  (5 &lt;&gt; 6) &lt;&gt; (7 &lt;&gt; 8)
((1 &lt;&gt; 2) &lt;&gt; (3 &lt;&gt; 4)) &lt;&gt; ((5 &lt;&gt; 6) &lt;&gt; (7 &lt;&gt; 8))

-- Left association: List-like structure
-- Start
      1 &lt;&gt; 2  &lt;&gt; 3  &lt;&gt; 4  &lt;&gt; 5  &lt;&gt; 6  &lt;&gt; 7  &lt;&gt; 8
-- Add parenthesis, starting from the left
     (1 &lt;&gt; 2) &lt;&gt; 3  &lt;&gt; 4  &lt;&gt; 5  &lt;&gt; 6  &lt;&gt; 7  &lt;&gt; 8
    ((1 &lt;&gt; 2) &lt;&gt; 3) &lt;&gt; 4  &lt;&gt; 5  &lt;&gt; 6  &lt;&gt; 7  &lt;&gt; 8
   (((1 &lt;&gt; 2) &lt;&gt; 3) &lt;&gt; 4) &lt;&gt; 5  &lt;&gt; 6  &lt;&gt; 7  &lt;&gt; 8
  ((((1 &lt;&gt; 2) &lt;&gt; 3) &lt;&gt; 4) &lt;&gt; 5) &lt;&gt; 6  &lt;&gt; 7  &lt;&gt; 8
 (((((1 &lt;&gt; 2) &lt;&gt; 3) &lt;&gt; 4) &lt;&gt; 5) &lt;&gt; 6) &lt;&gt; 7  &lt;&gt; 8
((((((1 &lt;&gt; 2) &lt;&gt; 3) &lt;&gt; 4) &lt;&gt; 5) &lt;&gt; 6) &lt;&gt; 7) &lt;&gt; 8
-- Finish:
((((((1 &lt;&gt; 2) &lt;&gt; 3) &lt;&gt; 4) &lt;&gt; 5) &lt;&gt; 6) &lt;&gt; 7) &lt;&gt; 8

-- Right association: List-like structure
-- Start
1 &lt;&gt; 2 &lt;&gt; 3 &lt;&gt; 4 &lt;&gt; 5 &lt;&gt; 6 &lt;&gt; 7 &lt;&gt; 8
-- add parenthesis, starting from the right
1 &lt;&gt;  2 &lt;&gt;  3 &lt;&gt;  4 &lt;&gt;  5 &lt;&gt;  6 &lt;&gt; (7 &lt;&gt; 8)
1 &lt;&gt;  2 &lt;&gt;  3 &lt;&gt;  4 &lt;&gt;  5 &lt;&gt; (6 &lt;&gt; (7 &lt;&gt; 8))
1 &lt;&gt;  2 &lt;&gt;  3 &lt;&gt;  4 &lt;&gt; (5 &lt;&gt; (6 &lt;&gt; (7 &lt;&gt; 8)))
1 &lt;&gt;  2 &lt;&gt;  3 &lt;&gt; (4 &lt;&gt; (5 &lt;&gt; (6 &lt;&gt; (7 &lt;&gt; 8))))
1 &lt;&gt;  2 &lt;&gt; (3 &lt;&gt; (4 &lt;&gt; (5 &lt;&gt; (6 &lt;&gt; (7 &lt;&gt; 8)))))
1 &lt;&gt; (2 &lt;&gt; (3 &lt;&gt; (4 &lt;&gt; (5 &lt;&gt; (6 &lt;&gt; (7 &lt;&gt; 8))))))
-- Finish:
1 &lt;&gt; (2 &lt;&gt; (3 &lt;&gt; (4 &lt;&gt; (5 &lt;&gt; (6 &lt;&gt; (7 &lt;&gt; 8))))))
</code></pre>
<p>We can see that the output of adding up all these integers, regardless of where we put the parenthesis, will still be the same output value  (that's the law of associativity).</p>
<p>However, functions that are &quot;associative&quot; sometimes take longer to output that value depending on which &quot;direction&quot; it goes. As an example, consider the <code>Semigroup</code> instance for <code>List</code>:</p>
<pre><code class="language-haskell">data List a
  = Nil
  | Cons a (List a)

infix 4 Cons as :
-- Nil == []
-- 1 : Nil == [1]
-- 1 : 2 : 3 : Nil == [1, 2, 3]

-- Right associative: Start
(1 : Nil) &lt;&gt;  (2 : Nil) &lt;&gt;  (3 : Nil) &lt;&gt;  (4 : Nil) &lt;&gt; (5 : Nil)        -- 0
(1 : Nil) &lt;&gt;  (2 : Nil) &lt;&gt;  (3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil))       -- 0
(1 : Nil) &lt;&gt;  (2 : Nil) &lt;&gt; ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil)))      -- 0
(1 : Nil) &lt;&gt; ((2 : Nil) &lt;&gt; ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil))))     -- 0
append (1 : Nil) ((2 : Nil) &lt;&gt; ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil)))) -- 1
1 : (append Nil ((2 : Nil) &lt;&gt; ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil))))) -- 2
1 : ((2 : Nil) &lt;&gt; ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil))))              -- 3
1 : (append (2 : Nil) ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil))))          -- 4
1 : (2 : (append Nil ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil))))           -- 5
1 : (2 : ((3 : Nil) &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil))))                       -- 6
1 : (2 : (3 : (append Nil &lt;&gt; ((4 : Nil) &lt;&gt; (5 : Nil)))))                -- 7
1 : (2 : (3 : ((4 : Nil) &lt;&gt; (5 : Nil)))))                               -- 8
1 : (2 : (3 : (4 : (append Nil (5 : Nil)))))                            -- 9
1 : (2 : (3 : (4 : (5 : Nil))))                                         -- 10
1 : (2 : (3 : (4 : 5 : Nil)))                                           -- 11
1 : (2 : (3 : 4 : 5 : Nil))                                             -- 12
1 : (2 : 3 : 4 : 5 : Nil)                                               -- 13
1 : 2 : 3 : 4 : 5 : Nil                                                 -- 14

-- Left associative: Start
--  List1         List2         List3         List4        List5
   (1 : Nil) &lt;&gt;  (2 : Nil) &lt;&gt;  (3 : Nil) &lt;&gt;  (4 : Nil) &lt;&gt; (5 : Nil)       -- 0
  ((1 : Nil) &lt;&gt;  (2 : Nil)) &lt;&gt;  (3 : Nil) &lt;&gt;  (4 : Nil) &lt;&gt; (5 : Nil)      -- 0
 (((1 : Nil) &lt;&gt;  (2 : Nil)) &lt;&gt;  (3 : Nil)) &lt;&gt;  (4 : Nil) &lt;&gt; (5 : Nil)     -- 0
((((1 : Nil) &lt;&gt;  (2 : Nil)) &lt;&gt;  (3 : Nil)) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)    -- 0
(((append (1 : Nil) (2 : Nil)) &lt;&gt;  (3 : Nil)) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil) -- 1
(((1 : (append Nil (2 : Nil))) &lt;&gt;  (3 : Nil)) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil) -- 2
(((1 : (2 : Nil)) &lt;&gt;  (3 : Nil)) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)              -- 3
(((1 :  2 : Nil ) &lt;&gt;  (3 : Nil)) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)              -- 3
-- At this point, we will need to iterate
-- through the List1 all over again!
((append (1 : 2 : Nil) (3 : Nil)) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)             -- 4
((1 : (append (2 : Nil) (3 : Nil))) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)           -- 5
((1 : 2 : (append Nil (3 : Nil))) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)             -- 6
((1 : 2 : (3 : Nil)) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)                          -- 7
((1 : 2 :  3 : Nil) &lt;&gt;  (4 : Nil)) &lt;&gt; (5 : Nil)                           -- 7
-- At this point, we will need to iterate
-- through the List1 AND List2 all over again!
(append (1 : 2 : 3 : Nil) (4 : Nil)) &lt;&gt; (5 : Nil)                         -- 8
(1 : (append (2 : 3 : Nil) (4 : Nil))) &lt;&gt; (5 : Nil)                       -- 9
(1 : 2 : (append (3 : Nil) (4 : Nil))) &lt;&gt; (5 : Nil)                       -- 10
(1 : 2 : 3 : (append Nil (4 : Nil))) &lt;&gt; (5 : Nil)                         -- 11
(1 : 2 : 3 : (4 : Nil)) &lt;&gt; (5 : Nil)                                      -- 12
(1 : 2 : 3 : 4 : Nil) &lt;&gt; (5 : Nil)                                        -- 12
-- At this point, we will need to iterate
-- through the List1 AND List2 AND List3 all over again!
append (1 : 2 : 3 : 4 : Nil) (5 : Nil)                                    -- 13
1 : (append (2 : 3 : 4 : Nil) (5 : Nil))                                  -- 14
1 : 2 : (append (3 : 4 : Nil) (5 : Nil))                                  -- 15
1 : 2 : 3 : (append (4 : Nil) (5 : Nil))                                  -- 16
1 : 2 : 3 : 4 : (append Nil (5 : Nil))                                    -- 17
1 : 2 : 3 : 4 : (5 : Nil)                                                 -- 18
1 : 2 : 3 : 4 : 5 : Nil                                                   -- 18
</code></pre>
<p>The law of associativity guarantees that the output of a non/left/right-associative function will always be the same. However, the above code demonstrates that one direction of function application (right association) can be faster than another (left association).</p>
<p>So, let's think about why this occured. Due to the way the type is defined, <code>List</code> must use recursion to get to its tail <code>Nil</code> before it can replace that tail, <code>Nil</code>, with the list to which it is being appended. Since <code>List</code> and <code>Free</code> are structured similarly, then <code>Free</code> will also suffer the same performance costs if it uses a left-associative function to reach its tail, <code>Pure</code>. So, which function does <code>Free</code> use that acts just like <code>append</code>? The <code>bind</code> function. Every <code>bind</code>/<code>&gt;&gt;=</code> call will iterate through the entire <code>Free</code> structure, apply the function to its <code>Pure a</code> value and then rewrap everything in an <code>Impure</code> value:</p>
<pre><code class="language-haskell">-- Thus, this code...
freeMonad &gt;&gt;= f &gt;&gt;= g &gt;&gt;= h &gt;&gt;= ...
-- is synonymous with the runtime performance hit as this code...
(((list &lt;&gt; f) &lt;&gt; g) &lt;&gt; h) &lt;&gt; ...
</code></pre>
<p>When we call <code>freeMonad &gt;&gt;= f</code>, we iterate through <code>freeMonad</code>'s entire structure. When we take that output and <code>bind</code>/<code>&gt;&gt;=</code> it to <code>g</code>, we iterate through <code>freeMonad</code>'s entire structure plus any new nesting values that <code>f</code> added to it. When we take that output and <code>bind</code>/<code>&gt;&gt;=</code> it to <code>h</code>, the total cost is <code>freeMonad + f's additional structure + g's additional structure</code>. As a result, <code>Free</code>'s performance suffers because of its recursive nature.</p>
<p>Is recursion by itself bad? No, recursion can be quite helpful; it's not the problem. Rather, the problem with <code>List</code>'s left-associative <code>&lt;&gt;</code> function is the slow recursive-time access to <code>List</code>'s tail. Since <code>List</code> represents a sequence of values, we can fix the <code>append</code> problem by using a different sequence-like data structure that grants fast constant-time access to its tail. Similarly, to fix the problem with <code>Free</code>, we should define it differently, so that the &quot;data structure&quot; to which it is similar also has constant-time tail access (i.e. constant time access to its <code>Pure</code> value).</p>
<p>This sounds easy until you remember what <code>bind</code>'s type signature allows:
<code>bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b</code>.
In other words, <code>bind</code> must work &quot;for all <code>a</code> and <code>b</code> types&quot; where these types can differ in-between multiple <code>bind</code> calls.</p>
<p>Fortunately, the paper's authors figured out how to do this using a <code>FingerTree</code> (data structure with constant time head and tail access) that stores a special type that represents a <code>bind</code>'s type signature and which can be composed just like multiple <code>bind</code> functions. This &quot;type magic&quot; won't be explained here; you'll need to read the paper (see Section 4 and 5) on your own to understand it fully.</p>
<p>To quote from their documentation, Purescript's <code>Free</code> monad is &quot;the Free monad implemented in the spirit of [that] paper.&quot;</p>
<p>Now that we understand what the <code>Free</code> monad is, let's see why it's useful.</p>
<h1><a class="header" href="#the-expression-problem" id="the-expression-problem">The Expression Problem</a></h1>
<h2><a class="header" href="#brief-summary" id="brief-summary">Brief Summary</a></h2>
<p>The <a href="http://www.daimi.au.dk/%7Emadst/tool/papers/expression.txt">Expression Problem</a> can be summarized into three ideas:</p>
<blockquote>
<p>The goal is to define a data type by cases, where</p>
<ol>
<li>one can add new cases to the data type and</li>
<li>(one can add) new functions over the data type,</li>
<li>without recompiling existing code, and</li>
<li>while retaining static type safety.</li>
</ol>
</blockquote>
<table><thead><tr><th></th><th>Pre-existing compiled function</th><th>Function is added</th></tr></thead><tbody>
<tr><td>Pre-existing compiled data type</td><td>All languages</td><td>FP: Add a function in a new file<br> OO: ???</td></tr>
<tr><td>Data type is added</td><td>FP: ???<br>OO: Add a subclass in a new file</td><td>Problem's Solution^^</td></tr>
</tbody></table>
<p>^^ This cannot be defined until the corresponding FP/OO issue (marked as <code>???</code>) is resolved</p>
<h2><a class="header" href="#a-solution-to-the-expression-problem" id="a-solution-to-the-expression-problem">A Solution to the Expression Problem</a></h2>
<p>The paper, <a href="http://www.cs.ru.nl/%7EW.Swierstra/Publications/DataTypesALaCarte.pdf">Data Types  la carte</a>, synthesized a number of known-at-the-time-of-writing ideas into a solution to the Expression problem by figuring out a way to compose complicated data types. When they applied their findings to the <code>Free</code> monad, they found that they could &quot;run&quot; multiple monads inside of one monad.</p>
<p>This folder is a summmary and commentary on the paper linked above. It is meant to be read alongside of or after you read the paper. While you, the reader, could just read the paper and ignore the rest of this folder's contents, there are some advantages to reading through this folder's contents alongside of the paper:</p>
<ul>
<li>Sometimes, the above paper will state that something is true, but not show why. This folder will explore that more and show why it's true.</li>
<li>Sometimes, the paper may use unfamiliar terminology or use symbolic data types. This folder will explain the terminology and use alphabetical names to refer to some data types.</li>
<li>The last file in this folder (i.e. <code>Embedded Compilers.md</code>) explains one of the key features one obtains by using the <code>Free</code> monad approach</li>
</ul>
<h2><a class="header" href="#reading-the-paper-and-this-folder-side-by-side" id="reading-the-paper-and-this-folder-side-by-side">Reading the Paper and This Folder Side-by-Side</a></h2>
<p>Rather than follow the paper exactly, this folder will define and solve a simpler version of the Expression Problem to demonstrate the basic idea of the solution. With that foundation, the paper's real problem will be explored and solved.</p>
<p><strong>In addition, the paper explains how to write a <code>show</code> function that pretty prints the mathetmatical expression. This folder's contents will not overview that part of the paper. The full reasons will be explained when we get to that part.</strong></p>
<h3><a class="header" href="#contents-of-the-paper" id="contents-of-the-paper">Contents of The Paper</a></h3>
<p>The paper above has 8 sections:</p>
<ol>
<li>Introduction (what is the expression problem and an example of it?)</li>
<li>Fixing the Expression Problem (how do we compose data types?)</li>
<li>Evaluation (how do we evaluate composed data types?)</li>
<li>Automating Injections (how do we reduce boilerplate when working with composed data types?)</li>
<li>Examples (Provide a full example of a solution to our problem)</li>
<li>Monads for Free (Why is this relevant to Free monads?)</li>
<li>Applications (Using this approach to define extensible effects by composing Free monads)</li>
<li>Discussion</li>
</ol>
<p>This folder has 8 files:</p>
<ol>
<li>Seeing and Solving a Simple Problem</li>
<li>Reducing boilerplate via Either</li>
<li>Seeing and Solving a Harder Problem</li>
<li>Writing the Evaluate Function</li>
<li>Writing the Show function (optional)</li>
<li>From Expression to Free</li>
<li>Defining Modular Monads</li>
<li>Embedded Compilers</li>
</ol>
<h3><a class="header" href="#correspondance-table" id="correspondance-table">Correspondance Table</a></h3>
<table><thead><tr><th>This Folder</th><th>General Idea</th><th>Corresponding Paper section</th><th>General idea</th></tr></thead><tbody>
<tr><td>1 (File)</td><td>Prep work: Defining and solving a simple version of the problem by composing data types</td><td>Sections 1/2/3/5 (ish)</td><td>Laying a foundation</td></tr>
<tr><td>2 (File)</td><td>Prep work: Abstract data type composition via <code>Either</code></td><td>Section 4 (ish)</td><td>Laying a foundation</td></tr>
<tr><td>3 (File)</td><td>Showing why the paper's problem is hard to solve, but still solvable; reveal <code>Coproduct</code></td><td>Sections 1/2/4/5 (ish)</td><td>-</td></tr>
<tr><td>4 (File)</td><td>-</td><td>Sections 3/5</td><td>Writing the <code>evaluate</code> function</td></tr>
<tr><td>5 (File)</td><td>Optional reading</td><td>Sections 3/5</td><td>Writing the <code>show</code> function</td></tr>
<tr><td>6 (Folder)</td><td>Show that <code>Expression</code> is really <code>Free</code></td><td>Section 6</td><td>-</td></tr>
<tr><td>7 (File)</td><td>Using 'languages' to model effects</td><td>Section 6</td><td>Simulating the State monad</td></tr>
<tr><td>8 File</td><td>Defining abstract syntax trees via <code>Free</code></td><td>Sections 6/7</td><td>Its relevance to and application for <code>Free</code> monads</td></tr>
</tbody></table>
<h1><a class="header" href="#seeing-and-solving-the-problem-in-fp-code" id="seeing-and-solving-the-problem-in-fp-code">Seeing and Solving the Problem in FP Code</a></h1>
<blockquote>
<p>The goal is to define a data type by cases, where</p>
<ol>
<li>one can add new cases to the data type and</li>
<li>(one can add) new functions over the data type,</li>
<li>without recompiling existing code, and</li>
<li>while retaining static type safety.</li>
</ol>
</blockquote>
<h2><a class="header" href="#a-very-simple-example-of-the-problem" id="a-very-simple-example-of-the-problem">A Very Simple Example of The Problem</a></h2>
<p>Given this code</p>
<pre><code class="language-haskell">data Fruit
  = Apple
  | Banana

showFruit :: Fruit -&gt; String
showFruit Apple = &quot;apple&quot;
showFruit Banana = &quot;banana&quot;
</code></pre>
<p>We can easily add a new function to our code without needing to recompile our existing code</p>
<pre><code class="language-haskell">-- in another file...
intFruit :: Fruit -&gt; Int
intFruit Apple = 0
intFruit Banana = 1
</code></pre>
<p>However, if we want to add another data constructor to <code>Fruit</code>, we can only do so by updating <code>Fruit</code> to include <code>Orange</code> <strong>and then</strong> updating all of our functions to include <code>Orange</code> as well:</p>
<pre><code class="language-haskell">data Fruit
  = Apple
  | Banana
  | Orange

showFruit :: Fruit -&gt; String
showFruit Apple = &quot;apple&quot;
showFruit Banana = &quot;banana&quot;
showFruit Orange = &quot;orange&quot;
</code></pre>
<p>Since <code>Fruit</code> has already been compiled, we will need to recompile our code with the updated version of <code>Fruit</code>. Moreover, if we do not update <code>showFruit</code>/<code>intFruit</code>, then we no longer have an exhaustive pattern match. Thus, these functions are no longer pure but are now partial functions.</p>
<h2><a class="header" href="#the-solution" id="the-solution">The Solution</a></h2>
<p>The solution, then, is to be able to define data types in such a way that they &quot;compose&quot;. The best way to compose data types is to group two types into one type via a type wrapper:</p>
<pre><code class="language-haskell">-- original file
data Fruit
  = Apple
  | Banana

-- new file
data Fruit2
  = Orange

data FruitGrouper = -- ???
</code></pre>
<p>How should <code>FruitGrouper</code> be defined? A value of <code>FruitGrouper</code> should only be one of 3 values:</p>
<ol>
<li>FruitGrouper Apple</li>
<li>FruitGrouper Banana</li>
<li>FruitGrouper Orange</li>
</ol>
<p>We can define it using this approach:</p>
<pre><code class="language-haskell">data FruitGrouper
  = Fruit_  Fruit
  | Fruit2_ Fruit2
</code></pre>
<p>This approach will enable <code>showFruit</code> and <code>intFruit</code> to continue to work as expected. If we wanted to define a new function that uses both, we would pass in <code>FruitGrouper</code> instead:</p>
<pre><code class="language-haskell">-- original file. This cannot change once written!
data Fruit
  = Apple
  | Banana

showFruit :: Fruit -&gt; String
showFruit Apple = &quot;apple&quot;
showFruit Banana = &quot;banana&quot;

-- new file
data Fruit2
  = Orange

data FruitGrouper
  = Fruit_  Fruit
  | Fruit2_ Fruit2

showAllFruit :: FruitGrouper -&gt; String
showAllFruit (Fruit_  appleOrBanana) = showFruit appleOrBanana
showAllFruit (Fruit2_ Orange) = &quot;orange&quot;
</code></pre>
<p>Great! We have now seen how to solve a <strong>very simple version</strong> of this problem. Now, let's refine this approach a bit as preparation for a future harder problem.</p>
<h1><a class="header" href="#reducing-boilerplate" id="reducing-boilerplate">Reducing Boilerplate</a></h1>
<p>There are two problems with our current approach that we want to raise.</p>
<p><strong>First</strong>, if we want to add another data constructor <code>Cherry</code>, we now need to nest that type even further using another type wrapper:</p>
<pre><code class="language-haskell">-- original file. This cannot change once written!
data Fruit
  = Apple
  | Banana

showFruit :: Fruit -&gt; String
showFruit Apple = &quot;apple&quot;
showFruit Banana = &quot;banana&quot;

-- File 2. This cannot change once written!
intFruit :: Fruit -&gt; Int
intFruit Apple = 0
intFruit Banana = 1

data Fruit2
  = Orange

data FruitGrouper
  = Fruit_  Fruit
  | Fruit2_ Fruit2

showAllFruit :: FruitGrouper -&gt; String
showAllFruit (Fruit_  appleOrBanana) = showFruit appleOrBanana
showAllFruit (Fruit2_ Orange) = &quot;orange&quot;

-- File 3.
data Fruit3 = Cherry

data FruitGrouper2
  = FruitGrouper_ FruitGrouper
  | Fruit3_       Fruit3

showMoreFruit :: FruitGrouper2 -&gt; String
showMoreFruit (FruitGrouper_ a) = showAllFruit a
showMoreFruit (Fruit3_ Cherry)  = &quot;cherry&quot;
</code></pre>
<p>We see that we keep nesting types inside more type wrappers. If we were to abstract this away into a more general type, we basically have nested <code>Either</code>s:</p>
<pre><code class="language-haskell">data Either a b
  = Left a
  | Right b

Either Fruit (Either Fruit2 Fruit3)
</code></pre>
<p>Anytime we want to add a new data constructor, we need to nest it in another <code>Either</code>:
<code>Either first (Either second (Either third (Either fourth ... (Either _ last))))</code>
If we were to visualize this data structure, it looks like this:</p>
<pre><code>   Either                    Either
   /   \                     /   \
  /     \                   /     \
first  Either         Left first  Right
        /  \                      /  \
       /    \                    /    \
  second   Either       Left second   Right
            /  \                      /  \
           /    \                    /    \
      third    Either        Left third   Right
                /  \                      /  \
               /    \                    /    \
           fourth   last        Left fourth   Right last
</code></pre>
<p>Thus, to access <code>last</code>, we need to call <code>Right (Right (Right (Right last)))</code></p>
<p><strong>Second</strong>, using a value that is wrapped in a nested data structure leads to boilerplate.</p>
<p>Here's an example of putting a value of one of the nested types into the data structure. One needs to write a variant for each type position in our data structure:</p>
<pre><code class="language-haskell">putInsideOf :: forall first second third fourth last
             . last
            -&gt; Either first (Either second (Either third (Either fourth last)))
putInsideOf last = Right (Right (Right (Right last)))
</code></pre>
<p>If we want to extract a value of a type that is in our nested <code>Either</code> value, we need to return <code>Maybe TheType</code> because the value may be of a different type in the nested <code>Either</code> value. Using <code>Maybe</code> makes our code pure:</p>
<pre><code class="language-haskell">extractFrom :: forall first second third fourth last
           . Either first (Either second (Either third (Either fourth last)))
          -&gt; Maybe Result
extractFrom (Right (Right (Right (Right last)))) = Just last
extractFrom _ = Nothing
</code></pre>
<p>Once again, we need to write a variant of this function that works for every type position (e.g. <code>first</code>, <code>second</code>, and <code>third</code>) in our data structure.</p>
<p>In short, this boilerplate gets tedious. However, boilerplate usually implies a pattern we can use. Here's two ways we could make this easier:</p>
<ol>
<li>Rather than using a nested <code>Either</code> type, why not define a type for this specific purpose?</li>
<li>Rather than using <code>extractFrom</code> and <code>putInsideOf</code> , why not define a type class with two functions for this specific purpose?</li>
</ol>
<h2><a class="header" href="#defining-nestedeither" id="defining-nestedeither">Defining NestedEither</a></h2>
<p>Looking at our example of a nested <code>Either</code> below, what is the common structure?</p>
<pre><code class="language-haskell">Either first   (      Either second   (      Either third         last))
Left   first | Right (Left   second | Right (Left   third | Right last))
Left   first | Right (NestedEither second theRemainintTypes            )
</code></pre>
<p>So we come up with this idea, but it doesn't work...</p>
<pre><code class="language-haskell">data NestedEither a b
  = Left a
  | Right (NestedEither b c)
</code></pre>
<p>...because we enter an infinte loop:</p>
<ol>
<li>To define <code>c</code> in the <code>Right</code> value's <code>NestedEither b c</code> argument, we need the type declaraction, <code>data NestedEither a b</code> to include the third type, <code>c</code>. Thus, we go to step 2.</li>
<li>We update the type to <code>data NestedEither a b c</code>. However, now the <code>NestedEither b c</code> in <code>Right</code> value has only two types, not three. Thus, it no longer adheres to its own declaration (i.e. <code>NestedEither b c ?</code> vs <code>NestedEither a b c</code>). To add the type, we need it to be different than the others to enable the recursive idea of a nested <code>Either</code>, so we'll call it <code>d</code>. Thus, we return to step 1 except <code>c</code> is now <code>d</code> in that example.</li>
</ol>
<p>Still, we can clean up the verbosity/readability of nested <code>Either</code>s by creating an infix notation for it:</p>
<pre><code class="language-haskell">infixr 6 type Either as \/

Either Int String == Int \/ String

-- As an example, the first line below reduces to the last line below
first \/  second \/  third \/  fourth \/ last       -- first
first \/  second \/  third \/ (fourth \/ last)
first \/  second \/ (third \/ (fourth \/ last))
first \/ (second \/ (third \/ (fourth \/ last)))    -- last
</code></pre>
<h2><a class="header" href="#defining-injectproject" id="defining-injectproject">Defining InjectProject</a></h2>
<p>When we have to write the same function again and again for different types in FP languages, we convert it into a type class (e.g. <code>Semigroup</code>, <code>Monoid</code>, <code>Functor</code>, etc.). Likewise, when we look at our code below...</p>
<pre><code class="language-haskell">putInsideOf :: forall first second third fourth last
             . last
            -&gt; Either first (Either second (Either third (Either fourth last)))
putInsideOf last = Right (Right (Right (Right last)))
</code></pre>
<p>... we want <code>putInsideOf</code> to mean &quot;if I have a data structure with nested types, take one of those types values and put it into that data structure.&quot; In other words, we want to <code>inject</code> some value into a data structure:</p>
<pre><code class="language-haskell">inject :: forall theType theNestedEitherType
        . theType
       -&gt; theNestedEitherType
</code></pre>
<p>When we look at the other code we had...</p>
<pre><code class="language-haskell">extractFrom :: forall first second third fourth last
             . Either first (Either second (Either third (Either fourth last)))
            -&gt; Maybe last
extractFrom (Right (Right (Right (Right last)))) = Just (f last)
extractFrom _ _ = Nothing
</code></pre>
<p>... we want <code>extractFrom</code> to mean &quot;If I have a data structure with nested types, I want to extract the value of a specific type out of that structure via <code>Just</code> or get <code>Nothing</code> if the value does not exist.&quot; In other words, we want to <code>project</code> some type's value from the data structure into the world:</p>
<pre><code class="language-haskell">project :: forall nestedType theType
         . nestedType
        -&gt; Maybe theType
</code></pre>
<p>Turning this idea into a type class, we get this:</p>
<pre><code class="language-haskell">class InjectAndProject someType nestedType where
  inject :: someType -&gt; nestedType
  project :: nestedType -&gt; Maybe someType
</code></pre>
<h2><a class="header" href="#purescript-either" id="purescript-either"><code>Purescript-Either</code></a></h2>
<p>Indeed, the ideas we've proposed have already been defined by <code>purescript-either</code>:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Nested"><code>\/</code> as a type alias for <code>Either</code></a></li>
<li>The <a href="https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Inject">Inject</a> type class and its <a href="https://github.com/purescript/purescript-either/blob/v4.0.0/src/Data/Either/Inject.purs#L8-L10">implementation via &quot;instance chains&quot;</a> that works for nested <code>Either</code> types.</li>
</ul>
<p>The library provides convenience functions and types for nested <code>Either</code>s, <strong>but only up to 10 total types</strong>:</p>
<ul>
<li>Convenience functions for dealing with injection and projection
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Nested#v:in1">injection - inX</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Nested#v:at1">projection - atX</a></li>
</ul>
</li>
<li>Convenience functions for running code that handles every possible type in the nested Either:
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Nested#v:either1">eitherX</a></li>
</ul>
</li>
<li>Convenience types for writing them in a function's type signature without the <code>\/</code> syntax
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Nested#t:Either1">EitherX</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#seeing-and-solving-a-harder-example" id="seeing-and-solving-a-harder-example">Seeing and Solving a Harder Example</a></h1>
<h2><a class="header" href="#failing-to-solve-a-harder-version" id="failing-to-solve-a-harder-version">Failing to Solve a Harder Version</a></h2>
<p>Let's try using our <code>Either</code>-based solution to solve a harder problem. We'll solve the same problem the paper to which we referred beforehand solved.</p>
<p>They want to define a program that can evaluate an expression that consists of adding and multiplying integers. However, they want to define this program in such a way that it also solves the Expression Problem.</p>
<p>To start, we'll define the <code>Value</code> type that wraps an <code>Int</code> and the <code>Addition</code> type in the &quot;file 1&quot;. An <code>Addition</code> should work in all of these cases:</p>
<ol>
<li>Adds two ints</li>
<li>Adds an int and another add expression</li>
<li>Adds two add expressions.</li>
</ol>
<p>To achieve this result, we'll define our type like so:</p>
<pre><code class="language-haskell">data Expression
  = Value Int
  | Add Expression Expression

evaluate :: Expression -&gt; Int
evaluate (Value i) = i
evaluate (Add x y) = (evaluate x) + (evaluate y)

show2 :: Expression -&gt; String
show2 (Value i) = show i
show2 (Add x y) = &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot; + &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>Now, if we want to add <code>Multiply</code> in &quot;file 2&quot; without changing or recompiling &quot;file 1&quot;, how does that fare? If we define our data type for <code>Multiply</code> like this...</p>
<pre><code class="language-haskell">data Multiply = Multiply Expression Expression
</code></pre>
<p>... then <code>Multiply</code> will work similarly to <code>Add</code>:</p>
<ol>
<li>Multiplies 2 Int values</li>
<li>Multiply an int value and an add expression</li>
<li>Multiply two add expressions</li>
</ol>
<p>The problem with our above definition is that it does not account for two other cases that should work:</p>
<ol>
<li>Multiply two multiply expressions</li>
<li>Add two multiply expresions</li>
</ol>
<h2><a class="header" href="#exploring-our-options" id="exploring-our-options">Exploring Our Options</a></h2>
<p>Let's model these types differently by separating them all into their own types that we can later compose. We won't include <code>Multiply</code> yet:</p>
<pre><code class="language-haskell">data Value = Value Int
data Add = Add Expression Expression

type Expression = Value \/ Add

value :: Int -&gt; Expression
value i = inj (Value i)

add :: Expression -&gt; Expression -&gt; Expression
add x y = inj (Add x y)

show2 :: Expression -&gt; String
show2 (Left (Value i)) = show i
show2 (Right (Add x y)) = &quot;(&quot; &lt;&gt; show2 x &lt;&gt; &quot; + &quot; &lt;&gt; show2 y &lt;&gt; &quot;)&quot;

evaluate :: Expression -&gt; Int
evaluate (Left (Value i)) = i
evaluate (Right (Add x y)) = (evaluate x) + (evaluate y)
</code></pre>
<p>To achieve the capability to add and multiply <code>Multiply</code> expressions, what would we need to do, even if it means breaking the constraints of the Expression Problem?</p>
<pre><code class="language-haskell">-- File 1
data Value = Value Int
data Add = Add Expression Expression

-- File 2
data Multiply = Multiply Expression Expression

-- The problem: this is the final type we need
type Expression = Value \/ Add \/ Multiply
</code></pre>
<p>There are two places where we could define <code>Expression</code>, each with its own problems:</p>
<ul>
<li>If we define it in File 1, then its definition cannot include the <code>Multiply</code> field because File 1 doesn't know about that type.</li>
<li>If we define it in File 2, then File 1 will not compile because the compiler does not know what the type, <code>Expression</code>, is.</li>
</ul>
<p>Hmm... The Expression Problem is more nuanced than first thought. Still, the above refactoring helps shed light on what needs to be done. Let's look back at <code>Add</code>:</p>
<pre><code class="language-haskell">data Add = Add Expression Expression
</code></pre>
<p><code>Add</code> must add 2 Expressions. However, we've hard-coded what <code>Expression</code> means. Since the location declaration of <code>Expression</code> causes a problem, we must turn this hard-coded type into a generic type to enable us to define it at a later time. The same goes for <code>Multiply</code>:</p>
<pre><code class="language-haskell">data Add expression = Add expression expression
-- or a less verbose version
data Multiply e = Multiply e e
</code></pre>
<p>We also know from our previous simpler problem that we will need to eventually compose our data types together into a big <code>Expression</code> type. In other words, we should get something like this:</p>
<pre><code class="language-haskell">--        L             RL  RR
-- Either Value (Either Add Multiply)

              Right ( Left ( Add (
                (Left (Value 1))
                (Right ( Right ( Multiply
                  (Left (Value 1))
                  (Left (Value 1))
                ))
              ))
</code></pre>
<p>To summarize, we need to</p>
<ul>
<li>define the <code>expression</code> type in <code>Add</code>/<code>Multiply</code> generically so we can define it at a later time as a way (avoids the location problem)</li>
<li>define an <code>Expression</code> type that composes data types together but somehow prevents them from knowing about one another. We need something like a &quot;<a href="https://www.wikiwand.com/en/Buffer_zone">buffer zone</a>&quot; but for our types.</li>
</ul>
<h2><a class="header" href="#solving-the-problem" id="solving-the-problem">Solving the Problem</a></h2>
<p>We'll show you how the paper solved this, starting with the type's value and then showing the actual type declaration/definition:</p>
<pre><code class="language-haskell">-- Value of our Expression type with Placeholder commented out
{- Placeholder ( -} Right ( Left ( Add (
  {- (Placeholder -} ( Left  (Value 1))   -- )
  {- (Placeholder -} ( Right ( Right ( Multiply
              {- (Placeholder -} (Left (Value 1))  -- )
              {- (Placeholder -} (Left (Value 1))  -- )
                      )))  -- )
                    )))  -- )

-- A full value
Placeholder ( Right ( Left ( Add (
  (Placeholder ( Left (Value 1)))
  (Placeholder ( Right ( Right ( Multiply
    (Placeholder (Left (Value 1)))
    (Placeholder (Left (Value 1)))
  ))))
))))

-- Define a special &quot;placeholder&quot; type that hides the next
-- `expression` type from the actual data type
-- `f` is a higher-kinded type
data Expression f = Placeholder (f (Expression f))

-- Make the types all higher-kinded by one
data Add e = Add e e
data Multiply e = Multiply e e
-- `e` not used here
-- but needed to make the next type work
data Value e = Value Int

{-
The following is pseudo-code. I don't konw whether it compiles.

Use Either to compose these higher-kinded types:
             Either (Value e) (Either (Add e)    (Multiply e))
type AMV e =        (Value e) \/      (Add e) \/ (Multiply e)
newtype AMV_Expression = AMV_Expression (Expression AMV)
</code></pre>
<h2><a class="header" href="#revealing-coproduct" id="revealing-coproduct">Revealing Coproduct</a></h2>
<p>Above, we wrote this:</p>
<pre><code class="language-haskell">Either (Value e) (Either (Add e)    (Multiply e))
       (Value e) \/      (Add e) \/ (Multiply e)
</code></pre>
<p>However, this is just a more verbose form of <a href="https://pursuit.purescript.org/packages/purescript-functors/3.0.1/docs/Data.Functor.Coproduct#t:Coproduct"><code>Coproduct</code></a>:</p>
<pre><code class="language-haskell">newtype Coproduct f g a = Coproduct (Either (f a) (g a))
</code></pre>
<p>Indeed, just as there was a library for nested <code>Either</code>s via <code>purescript-either</code>, there is also a library for nested <code>Coproduct</code>s: <a href="https://pursuit.purescript.org/packages/purescript-functors/3.0.1/docs/Data.Functor.Coproduct#t:Coproduct"><code>purescript-functors</code></a>, which also includes <a href="https://pursuit.purescript.org/packages/purescript-functors/3.0.1/docs/Data.Functor.Coproduct.Nested">convenience functions and types for dealing with nested versions of <code>Coproduct</code></a> as well as <a href="https://pursuit.purescript.org/packages/purescript-functors/3.0.1/docs/Data.Functor.Coproduct.Inject">inject values into and project values out of it</a>.</p>
<p>To help us understand how to read and write <code>Coproduct</code>, let's compare the <code>Coproduct</code> version to its equivalent <code>Either</code> version:</p>
<pre><code class="language-haskell">-- not nested
Either   (Value e) (Add e)
Coproduct Value     Add e

-- nested
         (Value e) \/        (Add e) \/ (Multiply  e)
Either   (Value e) (Either   (Add e)    (Multiply  e))
Coproduct Value    (Coproduct Add        Multiply) e

-- nested using convenience types from both libraries
Either3   (Value e) (Add e) (Multiply e)
Coproduct3 Value     Add     Multiply e
</code></pre>
<h1><a class="header" href="#writing-the-evaluate-function" id="writing-the-evaluate-function">Writing the Evaluate Function</a></h1>
<p>Since we'll be doing graph reductions later that will get somewhat complicated, we will rename <code>Placeholder</code> to <code>In</code> to make it easier to read. <code>In</code> is the same name used in the paper. This should make reading this &quot;commentary&quot; alongside of the paper easier.</p>
<pre><code class="language-haskell">data Expression f = In (f (Expression f))

-- A full value
In ( Right ( Left ( Add (
  (In ( Left (Value 1)))
  (In ( Right ( Right ( Multiply
    (In (Left (Value 1)))
    (In (Left (Value 1)))
  ))))
))))
</code></pre>
<h2><a class="header" href="#the-types-functor-instances" id="the-types-functor-instances">The Types' Functor Instances</a></h2>
<p>Due to how <code>Value</code>, <code>Add</code>, and <code>Multiply</code> are now defined, they are also <code>Functor</code>s. <code>Add</code> and <code>Multiply</code> implement <code>map</code> as one would expect:</p>
<pre><code class="language-haskell">map :: (e -&gt; z) -&gt; Add e -&gt; Add z
map f (Add e1 e2) = Add (f e1) (f e2)

map :: (e -&gt; z) -&gt; Multiply e -&gt; Multiply z
map f (Multiply e1 e2) = Multiply (f e1) (f e2)
</code></pre>
<p>However, <code>Value</code> implements it differently in an important way. Since <code>Value</code>'s generic type, <code>e</code>, is never used in its value and since the <code>Value</code> constructor can only wrap an <code>Int</code> type, one cannot really &quot;map&quot; a <code>Value</code> (i.e. change the inner <code>Int</code> type) to anything else. Rather, they can only change <code>Value</code>'s <code>e</code> type:</p>
<pre><code class="language-haskell">data Value e = ValueConstructor Int
map :: (e -&gt; z) -&gt; Value e            -&gt;             Value z
map    _          (ValueConstructor x)             = ValueConstructor x
--               ((ValueConstructor x) :: Value e) ((ValueConstructor x) :: Value z)
-- We have to extract the `x` and rewrap it in a different
-- `Value z` type.
</code></pre>
<p>Thus, <code>Value</code> is a no-op <code>Functor</code>: using <code>map</code> on it just returns the same value.</p>
<p>An <code>Either</code> that wraps higher-kinded types implements <code>Functor</code> as we would expect:</p>
<pre><code class="language-haskell">instance (Functor f, Functor g) =&gt; Functor (Either (f e) (g e)) where
  map func (Left f)  = Left  (map func f)
  map func (Right g) = Right (map func g)

instance (Functor f, Functor g) =&gt; Functor Coproduct f g e where
  map func (Coproduct either)  = Coproduct (map func either)
</code></pre>
<h2><a class="header" href="#a-simple-evaluation" id="a-simple-evaluation">A Simple Evaluation</a></h2>
<p>We will soon see why it matters that these types are <code>Functor</code>s.</p>
<p>Let's write a function that can evaluate the simplest version of our nested data structure. We'll exclude <code>Add</code> and <code>Multiply</code> and only focus on <code>Value</code>. To simulate the <code>Left</code> value in <code>Either (Value e) (SomethingElse e)</code>, we'll use <code>BoxF</code>:</p>
<pre><code class="language-haskell">data BoxF f a = BoxF (f a)

instance Functor f =&gt; Functor (Box f) where
  map function (BoxF f_of_a) = Box (map function f_of_a)

-- the `e` type in `Value e` can be anything.
valueExample :: forall e. Expression (BoxF (Value e))
valueExample = In (BoxF (Value 2))
</code></pre>
<p>What do we need to do to take <code>valueExample</code> and evaluate it to <code>2</code>? We need a way to remove the intermediary values: <code>In</code>, <code>BoxF</code>, and <code>Value</code>. There are two ways this could be done:</p>
<ol>
<li>We implement 3 different functions that all unwrap the wrapper type.</li>
<li>We implement a type class that specifies an 'unwrap' function that each implements.</li>
</ol>
<p>We'll take the second approach because it adheres to the idea of adding more types later on:</p>
<pre><code class="language-haskell">class (Functor f) &lt;= Evaluate f where
  evaluate :: forall a. f a -&gt; Int

instance Evaluate Value where
  evaluate (Value x) = x

instance Evaluate f =&gt; Evaluate (BoxF f) where
  evaluate (Boxf f) = evaluate f

instance Evaluate f =&gt; Evaluate (Expression f) where
  evaluate (In f) = evaluate f

-- then we could write:
evaluate valueExample
</code></pre>
<h2><a class="header" href="#including-add-again" id="including-add-again">Including <code>Add</code> again</a></h2>
<p>This solution works until we make our code more complicatd by composing <code>Add</code> with <code>Value</code> via <code>Either</code> again.</p>
<pre><code class="language-haskell">addExample :: Expression (Coproduct Value Add e)
addExample =
  In (Right (Add            -- Coproduct's wrapper value
    (In (Left (Value 2)))   -- is excluded for simplicity
    (In (Left (Value 4)))   -- since it's just an `Either`
  ))
</code></pre>
<p>Returning to the <code>Eval</code> type class, how would we implement an instance for <code>Add</code>?</p>
<pre><code class="language-haskell">class (Functor f) &lt;= Evaluate f where
  evaluate :: forall a. f a -&gt; Int

instance Evaluate Add where
  evaluate (Add x y) = -- ???
</code></pre>
<p>The difficulty above lies in one problem: what is <code>x</code> and <code>y</code> for <code>Add</code>? We might immediately presume that they are another <code>Expression</code>. However, the <code>e</code> in <code>Add e</code> could be anything. Moreover, the <code>Eval</code> type class does not force that <code>e</code> to be anything in particular. Here's the dilemma we run into now:</p>
<ul>
<li>If we use a type class constraint to make <code>a</code> be an <code>Evaluate</code>, so that we could implement <code>Add</code>'s Evaluate instance as <code>(eval x) + (eval y)</code>, then that will force <code>Value</code>'s <code>e</code> type to also satisfy that constraint. How then would we implement an instance for <code>Value</code>?</li>
<li>If we don't constrain the <code>a</code> to be an <code>Evaluate</code>, we cannot evaluate <code>addExample</code>.</li>
</ul>
<p>So, let's look at what we need to do to evaluate <code>Add</code>. We need to</p>
<ul>
<li>remove the <code>In</code> values at every other point: <code>In (f (In (f (In (Value)))))</code></li>
<li>remove the intermediary <code>Left</code>/<code>Right</code> values</li>
<li>convert <code>Value x</code> to <code>x</code></li>
<li>convert <code>Add x y</code> to <code>x + y</code></li>
</ul>
<p>Starting with an easier problem, we could guarantee that all <code>In</code> values are removed by calling an unwrapping function, <code>removeIn</code>, followed by a <code>map</code> call:</p>
<pre><code class="language-haskell">removeIn :: Expression f -&gt; f
removeIn (In f) = map removeIn f
</code></pre>
<p>To see why this works, we'll run this function on <code>addExample</code>:</p>
<pre><code class="language-haskell">-- Start!
removeIn (
  In (Right (Add
    (In (Left (Value 2)))
    (In (Left (Value 4)))
  ))
)
-- call `removeIn` by replacing LHS with RHS
map removeIn (Right (Add
  (In (Left (Value 2)))
  (In (Left (Value 4)))
))
-- call map on Right, which delegates function to Add
Right $ map removeIn (Add
  (In (Left (Value 2)))
  (In (Left (Value 4)))
)
-- call map on Add, which delegates function to both subexpressions
Right $ Add
  (removeIn (In (Left (Value 2))))
  (removeIn (In (Left (Value 4))))
-- call removeIn on both values
Right $ Add
  (map removeIn (Left (Value 2)))
  (map removeIn (Left (Value 4)))
-- call map on both Left values
Right $ Add
  (Left $ map removeIn (Value 2))
  (Left $ map removeIn (Value 4))
-- call map on both `Value` values, which does nothing...
Right $ Add
  (Left $ (Value 2))
  (Left $ (Value 4))
-- remove all of the &quot;$&quot;
Right (Add
  (Left (Value 2))
  (Left (Value 4))
)
</code></pre>
<p>This approach effectively removes all <code>In</code> values. However, we are still left with the same problem above: converting an <code>Add</code> expression into an <code>Int</code> value by defining an <code>Evaluate</code> instance.</p>
<p>However, the reduction of our graph shows something important. What is the type signature for the result of our reduction? We can see it below:</p>
<pre><code class="language-haskell">result :: Coproduct Value Add e
result =
  Right (Add
    (Left (Value 2))
    (Left (Value 4))
  )
</code></pre>
<p>Looking at the <code>Evaluate</code> type class definition again, we can see that we don't force <code>a</code> (which corresponds to our <code>e</code> type in <code>result</code>) to be anything. However, what if we changed it to <code>Int</code>? If we do, it solves our dilemma above:</p>
<pre><code class="language-haskell">class (Functor f) &lt;= Evaluate f where
  evaluate :: f Int -&gt; Int

instance Evaluate Value where
  evaluate (Value x) = x

instance Evaluate Add where
  evaluate :: Add Int -&gt; Int
  evaluate (Add x y) = x + y

instance (Evaluate f, Evaluate g) =&gt; Evaluate (Either f g) where
  evaluate (Left f)  = evaluate f
  evaluate (Right g) = evaluate g
</code></pre>
<p>If we call <code>evaluate</code> on the result of our graph reduction above, what do we get?</p>
<pre><code class="language-haskell">-- Start!
evaluate (Right (Add
  (Left (Value 2))
  (Left (Value 4))
))
-- replace LHS with RHS
evaluate (Add
  (Left (Value 2))
  (Left (Value 4))
)
-- Compiler error! Expected `Add Int` but got `Add (Either (Value e) (Add e))
</code></pre>
<p>The problem with this approach is that the nested <code>Value int</code> values were not evaluated before we evaluated the <code>Add</code>. If we could somehow change how our code works, we need something more like this:</p>
<pre><code class="language-haskell">-- Start!
evaluate (Right (Add
  (evaluate (Left (Value 2)))
  (evaluate (Left (Value 4)))
))
-- Evaluate both Left values
evaluate (Right (Add
  (evaluate (Value 2))
  (evaluate (Value 4))
))
-- Evaluate both Value values
evaluate (Right (Add
  (2)
  (4)
))
-- Since Add is now of type `Add Int`,
-- evaluate the Right value
evaluate (Add
  (2)
  (4)
)
-- Now evaluate the `Add Int` value
2 + 4
-- Reduce
6
</code></pre>
<p>So, how do we use the <code>removeIn</code> approach to remove the <code>In</code> values and also evaluate <code>Value int</code> before evaluating <code>Add</code>, so that the types are correct by the time it happens? We make just a slight change to <code>removeIn</code>. It will now take an &quot;unwrapping&quot; function that gets applied to the result of our mapping. To make it adhere to the paper, we'll rename it to &quot;fold&quot; and explain that name later:</p>
<pre><code class="language-haskell">fold :: Functor f =&gt; (f a -&gt; a) -&gt; Expression f -&gt; a
fold function (In f) = function (map (fold function) f)
</code></pre>
<p>How should this function be understood? Rather than explain it using words, we'll demonstrate it using a graph reduction. Then, we'll explain the name:</p>
<pre><code class="language-haskell">-- Start
fold evaluate addExample
-- replace addExample with its definition
fold evaluate (In (Right (Add
  (In (Left (Val 2)))
  (In (Left (Val 3)))
)))
-- replace fold's LHS with RHS
evaluate (map (fold evaluate) (Right (Add
  (In (Left (Val 2)))
  (In (Left (Val 3)))
)))
-- apply map to Right value by delegating it to Add value
evaluate (Right $ map (fold evaluate) (Add
  (In (Left (Val 2)))
  (In (Left (Val 3)))
))
-- apply map to Add value by delegating it to both expressions
evaluate (Right $ Add
  (fold evaluate (In (Left (Val 2))))
  (fold evaluate (In (Left (Val 3))))
)
-- apply fold to `In` value
evaluate (Right $ Add
  (evaluate (map (fold evaluate) (Left (Val 2))))
  (evaluate (map (fold evaluate) (Left (Val 3))))
)
-- apply map to Left value, which delegates to `Value` value
evaluate (Right $ Add
  (evaluate (Left $ map (fold evaluate) (Val 2)))
  (evaluate (Left $ map (fold evaluate) (Val 3)))
)
-- apply map to `Value` value (no-op!)
evaluate (Right $ Add
  (evaluate (Left $ (Val 2)))
  (evaluate (Left $ (Val 3)))
)
-- remove the &quot;$&quot;
evaluate (Right $ Add
  (evaluate (Left (Val 2)))
  (evaluate (Left (Val 3)))
)
-- evaluate the Left value
evaluate (Right $ Add
  (evaluate (Val 2))
  (evaluate (Val 3))
)
-- evaluate the Value value
evaluate (Right $ Add
  (2)
  (3)
)
-- put everything on one line again
evaluate (Right $ Add (2) (3))
-- remove the $ and extra parenthesis
evaluate (Right (Add 2 3))
-- evaluate the Right value
evaluate (Add 2 3)
-- evaluate the Add value
2 + 3
-- add them up
5
</code></pre>
<h2><a class="header" href="#explaining-terms" id="explaining-terms">Explaining Terms</a></h2>
<p>There's a term we did not explain but which appears in the paper: <code>algebra</code>. An <a href="https://pursuit.purescript.org/packages/purescript-matryoshka/0.3.0/docs/Matryoshka.Algebra#t:Algebra"><code>Algebra</code></a> is merely a special name for a function with a specific type signature: <code>(f a -&gt; a)</code>. It's our <code>evaluate</code> function.</p>
<h2><a class="header" href="#all-code-so-far-and-evaluate" id="all-code-so-far-and-evaluate">All Code So Far and Evaluate</a></h2>
<p><strong>I have not checked whether this code works, but it will serve to give you an idea for how it works.</strong></p>
<pre><code class="language-haskell">-- File 1
data Value e = Value Int
data Add e = Add e e

derive instance Functor Value
derive instance Functor Add

data Expression f = In (f (Expression f))

-- where `f` is a composed data type via Coproduct
value :: forall f. Int -&gt; Expression f
value i = inj (Value i)

add :: forall f. Expression f -&gt; Expression f -&gt; Expression f
add x y = inj (Add x y)

class (Functor f) &lt;= Evaluate f where
  evaluate :: f Int -&gt; Int

instance Evaluate Value where
  evaluate (Value x) = x

instance Evaluate Add where
  evaluate (Add x y) = x + y

fold :: Functor f =&gt; (f a -&gt; a) -&gt; Expression f -&gt; a
fold f (In t) = f (map (fold f) t)

type VA e = Coproduct Value Add e
newtype VA_Expression = VA_Expression (Expression VA)

eval :: forall f. Expression f -&gt; Int
eval expression = fold evaluate expression

-- call `eval` on this
file1Example :: VA_Expression
file1Example = add (value 5) (value 6)

-- File 2
data Multiply e = Multiply e e
derive instance Functor Multiply

multiply :: forall f. Expression f -&gt; Expression f -&gt; Expression f
multiply x y = inj $ Multiply x y

instance Evaluate Multiply where
  evaluate (Multiply x y) = x * y

type VAM e = Coproduct3 Value Add Multiply e
newtype VAM_Expression = VAM_Expression (Expression VAM)

-- call `eval` on this
file2Example :: VAM_Expression
file2Example = add (value 5) (multiply (add (value 2) (value 8)) (value 4))
</code></pre>
<h1><a class="header" href="#writing-the-show-function" id="writing-the-show-function">Writing the Show Function</a></h1>
<hr>
**Thils file is optional reading!**
<p>There are two reasons why:</p>
<ul>
<li>I was not able (i.e. smart enough to initially figure this out on my own) to convert this code into a compilable example</li>
<li>I found that I was able to understand the concept that this folder teaches without ultimately figuring out the below code. For example, the paper only lists the <code>show</code> function as another example about how it is easy to add more functions.</li>
<li>The cost-beneifits weren't worth it. Why spend time on trying to figure out this problem when I could spend time improving some other part of this repo, especially since this detail does not contribute greatly to one's understanding of this concept.</li>
</ul>
<hr>
<p>We still have one more function to define: <code>show2</code> (which is just <code>show</code> but which prevents the name conflict from <code>Prelude</code>). In our original file, <code>show2</code> was defined like this:</p>
<pre><code class="language-haskell">show2 :: Expression -&gt; String
show2 (Value i) = show i
show2 (Add x y) = &quot;(&quot; &lt;&gt; show2 x &lt;&gt; &quot; + &quot; &lt;&gt; show2 y &lt;&gt; &quot;)&quot;
</code></pre>
<p>Since we changed the function, <code>evaluate</code>, into a type class, we should follow suit here. Still, we should diverge from <code>Evaluate</code> in a one way:</p>
<ul>
<li>The types for <code>x</code> and <code>y</code> in <code>Add x y</code> should not be an <code>Int</code>. Rather, it should keep the spirit of the original <code>show2</code> function and be other expression types on which we can recursively call <code>show2</code> to get a full expression.</li>
</ul>
<p><code>Expression</code> in our original <code>show2</code> function meant both <code>Value</code> and <code>Add</code>. To do the same thing in our new code, where these types are composed via <code>Either</code>, we would need to change the signature to <code>f (Expression f)</code>:</p>
<pre><code class="language-haskell">class (Functor f) &lt;= Show2 f where                                {-
  show2 :: AllExpressionTypes -&gt; String                                   -}
  show2 :: f (Expression f)   -&gt; String
</code></pre>
<p>With that being our expression type, what would values for <code>Value</code>, <code>Add</code>, and <code>Multiply</code> look like that fit that signature?</p>
<pre><code class="language-haskell">-- Value
(Value 5)

-- Value does not use the `In` value here
-- so its implementation is trivial
instance Show2 Value where
  show2 (Value x) = show x

-- Add
Add
  (In (Left (Value 5)))
  (In (Right (Right (Multiply
    (In (Left (Value 9)))
    (In (Left (Value 9)))
  ))))

-- Multiply
Multiply
  (In (Left (Value 5)))
  (In (Right (Left (Add
    (In (Left (Value 4)))
    (In (Left (Value 2)))
  ))))
</code></pre>
<p><code>Add</code> and <code>Multiply</code> both have an <code>In</code> value and an <code>Either</code> value separating the next expression. We can remove the <code>In</code> value using a function. However, removing the <code>Either</code> value would be best left to an instance of our own type class that just delegates it to the underlying expression.</p>
<pre><code class="language-haskell">removeInAndShow :: Show2 f =&gt; Expression f -&gt; String
removeInAndShow (In t) = show2 t

instance (Show2 f, Show2 g) =&gt; Show2 (Either f g) where
  show2 (Left f)  = show2 f
  show2 (Right g) = show2 g

-- Now we can define the values for Add and Multiply
instance Show2 Add where
  show2 (Add x y) =
    &quot;(&quot; &lt;&gt; removeInAndShow x &lt;&gt; &quot; + &quot; &lt;&gt; removeInAndShow y &lt;&gt; &quot;)&quot;

instance Show2 Multiply where
  show2 (Multiply x y) =
    &quot;(&quot; &lt;&gt; removeInAndShow x &lt;&gt; &quot; * &quot; &lt;&gt; removeInAndShow y &lt;&gt; &quot;)&quot;
</code></pre>
<h2><a class="header" href="#all-code-so-far-and-show2" id="all-code-so-far-and-show2">All Code So Far and Show2</a></h2>
<p>Again, <strong>I have not checked whether this code works, but it will serve to give you an idea for how it works.</strong></p>
<pre><code class="language-haskell">-- File 1
data Value e = Value Int
data Add e = Add e e

derive instance Functor Value
derive instance Functor Add

data Expression f = In (f (Expression f))

-- where `f` is a composed data type via Coproduct
value :: forall f. Int -&gt; Expression f
value i = inj (Value i)

add :: forall f. Expression f -&gt; Expression f -&gt; Expression f
add x y = inj (Add x y)

class (Functor f) &lt;= Evaluate f where
  evaluate :: f Int -&gt; Int

instance Evaluate Value where
  evaluate (Value x) = x

instance Evaluate Add where
  evaluate (Add x y) = x + y

fold :: Functor f =&gt; (f a -&gt; a) -&gt; Expression f -&gt; a
fold f (In t) = f (map (fold f) t)

type VA e = Coproduct Value Add e
newtype VA_Expression = VA_Expression (Expression VA)

eval :: forall f. Expression f -&gt; Int
eval expression = fold evaluate expression

class (Functor f) &lt;= Show2 f where
  show2 :: forall a. f a -&gt; String

instance Show2 Value where
  show2 (Value x) = show x

removeInAndShow :: Show2 f =&gt; Expression f -&gt; String
removeInAndShow (In t) = show2 t

instance (Show2 f, Show2 g) =&gt; Show2 (Either f g) where
  show2 (Left f)  = show2 f
  show2 (Right g) = show2 g

instance Show2 Add where
  show2 (Add x y) =
    &quot;(&quot; &lt;&gt; removeInAndShow x &lt;&gt; &quot; + &quot; &lt;&gt; removeInAndShow y &lt;&gt; &quot;)&quot;

-- call `eval` and `show2` on this
file1Example :: VA_Expression
file1Example = add (value 5) (value 6)

-- File 2
data Multiply e = Multiply e e
derive instance Functor Multiply

multiply :: forall f. Expression f -&gt; Expression f -&gt; Expression f
multiply x y = inj $ Multiply x y

instance Evaluate Multiply where
  evaluate (Multiply x y) = x * y

instance Show2 Multiply where
  show2 (Multiply x y) =
    &quot;(&quot; &lt;&gt; removeInAndShow x &lt;&gt; &quot; * &quot; &lt;&gt; removeInAndShow y &lt;&gt; &quot;)&quot;

type VAM e = Coproduct3 Value Add Multiply e
newtype VAM_Expression = VAM_Expression (Expression VAM)

-- call `eval` and `show2` on this
file2Example :: VAM_Expression
file2Example = add (value 5) (multiply (add (value 2) (value 8)) (value 4))
</code></pre>
<h1><a class="header" href="#from-expression-to-free" id="from-expression-to-free">From <code>Expression</code> to <code>Free</code></a></h1>
<p>We've been defining the function, <code>fold</code>, the same way for a while. However, there's another way to write the function. To help you understand the upcoming code, we'll rewrite it in this new way:</p>
<pre><code class="language-haskell">fold :: forall f a. Functor f =&gt; (f a -&gt; a) -&gt; Expression f -&gt; a
fold f (In t) = f (map (fold f) t)                                          {-
... which can be rewritten using infix notation                             -}
fold f (In t) = f ((fold f) &lt;$&gt; t)                                          {-
... which can be rewritten to not pass `f` through recursive calls          -}
fold f = go where
  go (In t) = f (go &lt;$&gt; t)                                                  {-
... which can be rewritten to use &quot;case _ of&quot; to pattern match              -}
fold f = go where
  go in_t = case in_t of
    In t -&gt; f (go &lt;$&gt; t)
</code></pre>
<p>With that out of the way, let's compare <code>Expression</code> to <code>Free</code>. We can see that <code>Expression</code> is really just a variant of the <code>Free</code> monad without the <code>Pure</code> constructor.</p>
<pre><code class="language-haskell">newtype Expression f
  -- no pure here...
  = In     (f (Expression f  ))

newtype Free       f a
  = Pure a
  | Impure (f (Free       f a))
</code></pre>
<p>How would we rewrite our solution from before to use <code>Free</code> instead of <code>Expression</code>? <code>Value</code> is replaced with <code>Pure</code>.</p>
<p>To see an example of this for just <code>Value</code> and <code>Add</code> (<code>Multiply</code> is excluded) and to understand its code, refer to the below code and table before viewing <a href="https://github.com/xgrommx/purescript-from-adt-to-eadt/blob/master/src/ADT8.purs">ADT8.purs</a>.</p>
<pre><code class="language-haskell">-- when Value and Add were both `f`
fold    f = go where
  go in_t = case in_t of
    In     t -&gt; f (go &lt;$&gt; t)

-- when Value is simply Pure now
fold    f = go where
  go free = case free of
    Pure   a -&gt; a              -- Value
    Impure t -&gt; f (go &lt;$&gt; t)   -- Add
</code></pre>
<table><thead><tr><th>xgrommx's code</th><th>Our code</th></tr></thead><tbody>
<tr><td><code>Free ExprF a</code><br>or<br><code>Expr</code></td><td><code>Expression (Coproduct Value ExprF) a</code></td></tr>
<tr><td><code>lit</code></td><td><code>value</code></td></tr>
<tr><td><code>iter</code></td><td><code>fold</code></td></tr>
<tr><td><code>iter k go</code></td><td><code>fold algebra expression</code></td></tr>
<tr><td><code>Left f</code><br><code>Right a</code></td><td><code>AddF</code><br><code>ValueF</code></td></tr>
</tbody></table>
<h2><a class="header" href="#a-quick-overview-of-some-of-purescripts-free-api" id="a-quick-overview-of-some-of-purescripts-free-api">A Quick Overview of Some of Purescript's <code>Free</code> API</a></h2>
<p>Purescript's <code>Free</code> monad is implemented in the &quot;reflection without remorse&quot; style, which adds complexity to the implementation. Thus, rather than redirecting you there, we'll explain the general idea of what the code is doing.</p>
<h3><a class="header" href="#liftf" id="liftf">LiftF</a></h3>
<p>The <code>Free</code> monad has its own way of injecting a value into it called <a href="https://pursuit.purescript.org/packages/purescript-free/5.2.0/docs/Control.Monad.Free#v:liftF"><code>liftF</code></a>. It can be understood like this:</p>
<pre><code class="language-haskell">-- Before
someValue :: forall a. a -&gt; Expression SomeFunctor
someValue a =
  In (SomeFunctor a) -- or `inj (SomFunctor a)`

-- After...
liftF :: a -&gt; Free SomeFunctor a
liftF = Impure (SomeFunctor a)
</code></pre>
<h3><a class="header" href="#wrap" id="wrap">Wrap</a></h3>
<p><code>LiftF</code> is useful, but it won't let us compile the examples we will show next because it expects the <code>a</code> to be any <code>a</code>. In cases like <code>AddF</code>/<code>MultiplyF</code>, sometimes that <code>a</code> has to be <code>Free AddF</code>/<code>Free MultiplyF</code> instead of just the <code>Int</code> type. In such cases, we can use <a href="https://pursuit.purescript.org/packages/purescript-free/5.2.0/docs/Control.Monad.Free#v:wrap"><code>wrap</code></a>:</p>
<pre><code class="language-haskell">-- Using `liftF`
add :: Int -&gt; Int -&gt; Free AddF Int
add x y = liftF $ AddF x y

-- the above 'add' definition does not allow us to create
-- nested adds

-- Using `wrap`
add :: Free AddF Int -&gt; Free AddF Int -&gt; Free AddF Int
add x y = wrap $ AddF x y
</code></pre>
<h3><a class="header" href="#other-functions" id="other-functions">Other Functions</a></h3>
<p><a href="https://pursuit.purescript.org/packages/purescript-free/5.2.0/docs/Control.Monad.Free#v:foldFree"><code>foldFree</code></a> interprets the Free into some other monad (e.g. <code>Effect</code>, etc.).</p>
<p><a href="https://pursuit.purescript.org/packages/purescript-free/5.2.0/docs/Control.Monad.Free#v:runFree"><code>runFree</code></a> computes a &quot;pure&quot; program described in <code>Free</code> (by 'pure,' we meant that <code>Free</code> only stores the instructions the program would execute, but does not run them).</p>
<h2><a class="header" href="#compilation-instructions-1" id="compilation-instructions-1">Compilation Instructions</a></h2>
<p>You can run the upcoming code examples using these instructions:</p>
<pre><code class="language-bash">spago run -m Free.AddAndMultiply
</code></pre>
<h1><a class="header" href="#01-valuepurs" id="01-valuepurs">01-Value.purs</a></h1>
<pre><code class="language-haskell">module Free.Value (value, iter) where

import Prelude
import Control.Monad.Free (Free, resume)
import Data.Either (Either(..))

-- First, we define the value smart constructor
value :: forall f a. Functor f =&gt; a -&gt; Free f a
value a = pure a

-- Second, we'll define the `iter` function we saw earlier here.
-- This will allow us to easily reuse it in the upcoming files
iter :: forall f a. Functor f =&gt; (f a -&gt; a) -&gt; Free f a -&gt; a
iter k = go where
  go m = case resume m of
    Left f -&gt; k (go &lt;$&gt; f)
    Right a -&gt; a
</code></pre>
<h1><a class="header" href="#02-addpurs" id="02-addpurs">02-Add.purs</a></h1>
<pre><code class="language-haskell">module Free.Add (AddF(..), add, addAlgebra, showAddExample) where

import Prelude hiding (add)
import Effect (Effect)
import Effect.Console (log)
import Control.Monad.Free (Free, wrap)
import Free.Value (iter, value)

--------------------------------------------------
-- Code in this section will be reused in upcoming file

data AddF e = AddF e e
derive instance Functor AddF

addAlgebra :: AddF Int -&gt; Int
addAlgebra (AddF a b) = a + b

--------------------------------------------------
-- Code in this section will NOT be reused

type AddOnly = Free AddF

add :: forall a. AddOnly a -&gt; AddOnly a -&gt; AddOnly a
add a b = wrap (AddF a b)

evalAdd :: AddOnly Int -&gt; Int
evalAdd = iter addAlgebra

addOnlyExample :: AddOnly Int
addOnlyExample =
  add
    (value 4)
    (add
      (value 8)
      (value 5)
    )

showAddExample :: Effect Unit
showAddExample = do
  log &quot;Add example:&quot;
  log $ show $ evalAdd addOnlyExample
</code></pre>
<h1><a class="header" href="#03-multiplypurs" id="03-multiplypurs">03-Multiply.purs</a></h1>
<pre><code class="language-haskell">module Free.Multiply (MultiplyF(..), multiply, multiplyAlgebra, showMultiplyExample) where

import Prelude hiding (add)
import Effect (Effect)
import Effect.Console (log)
import Control.Monad.Free (Free, wrap)
import Free.Value (iter, value)

--------------------------------------------------
-- Code in this section will be reused in upcoming file

data MultiplyF e = MultiplyF e e
derive instance Functor MultiplyF

multiplyAlgebra :: MultiplyF Int -&gt; Int
multiplyAlgebra (MultiplyF a b) = a * b

--------------------------------------------------
-- Code in this section will NOT be reused

type MultiplyOnly = Free MultiplyF

multiply :: forall a. MultiplyOnly a -&gt; MultiplyOnly a -&gt; MultiplyOnly a
multiply a b = wrap (MultiplyF a b)

evalMultiply :: MultiplyOnly Int -&gt; Int
evalMultiply = iter multiplyAlgebra

multiplyOnlyExample :: MultiplyOnly Int
multiplyOnlyExample =
  multiply
    (value 4)
    (multiply
      (value 8)
      (value 5)
    )

showMultiplyExample :: Effect Unit
showMultiplyExample = do
  log &quot;Multiply example:&quot;
  log $ show $ evalMultiply multiplyOnlyExample
</code></pre>
<h1><a class="header" href="#04-addandmultiplypurs" id="04-addandmultiplypurs">04-AddAndMultiply.purs</a></h1>
<pre><code class="language-haskell">module Free.AddAndMultiply where

import Prelude hiding (add)
import Effect (Effect)
import Effect.Console (log)
import Control.Monad.Free (Free, wrap)
import Data.Functor.Coproduct (Coproduct, coproduct)
import Data.Functor.Coproduct.Inject (class Inject, inj)
import Free.Value (iter, value)
import Free.Add (AddF(..), addAlgebra, showAddExample)
import Free.Multiply (MultiplyF(..), multiplyAlgebra, showMultiplyExample)

-- `Coproduct AddF MultiplyF` is same as `Either (AddF a) (MultiplyF a)`

addAndMultiplyAlgebra :: Coproduct AddF MultiplyF Int -&gt; Int
addAndMultiplyAlgebra =
  -- coproduct handles the Coproduct and Either stuff for us
  coproduct
    -- when the instance is AddF, use this function
    addAlgebra
    -- when the instance is MultiplyF, use this function
    multiplyAlgebra

type AddAndMultiply = Free (Coproduct AddF MultiplyF)

-- Since we're putting AddF into a Coproduct now before we put that
-- into a Free, we need to pass it into 'inj' before it gets passed into `wrap`
add' :: forall a. AddAndMultiply a -&gt; AddAndMultiply a -&gt; AddAndMultiply a
add' a b = wrap $ inj (AddF a b)

-- This function exists for the same reasons as above. However,
-- it also shows that we do not need to hard-code the &quot;AddAndMultiply&quot; type
-- to get this to work.
multiply' :: forall f a.
             Functor f =&gt;
             Inject MultiplyF f =&gt;
             Free f a -&gt; Free f a -&gt; Free f a
multiply' a b = wrap $ inj (MultiplyF a b)

evalAddAndMultiply :: AddAndMultiply Int -&gt; Int
evalAddAndMultiply = iter addAndMultiplyAlgebra

{- Note:
Non-Coproduct version: add   multiply
Coproduction version:  add'  multiply'                                       -}
exampleAddAndMultiply :: AddAndMultiply Int
exampleAddAndMultiply =
  add'
    (multiply'
      (value 4)
      (add'
        (value 8)
        (value 5)
      )
    )
    (value 5)

showAddAndMultiplyExample :: Effect Unit
showAddAndMultiplyExample = do
  log &quot;Add and multiply example:&quot;
  log $ show $ evalAddAndMultiply exampleAddAndMultiply

------------------------------------

main :: Effect Unit
main = do
  showAddExample
  showMultiplyExample
  showAddAndMultiplyExample
</code></pre>
<h1><a class="header" href="#defining-modular-monads" id="defining-modular-monads">Defining Modular Monads</a></h1>
<p><strong>This file has two sections. The first only makes more sense after reading the second. So, be sure to read this file twice.</strong></p>
<p>We can now return to the original question we raised at the start of the <code>Free</code> folder: if we wanted to run a sequential computation (i.e. use a monad) that used multiple effects, could we stop fighting against the &quot;<code>bind</code> returns the same monad type it receives&quot; restriction and simply use just one monad? Yes. Similar to our previous examples, we can use <code>Coproduct</code>s of two or more <code>Free</code> monads.</p>
<h2><a class="header" href="#getting-around-the-non-free-monad-limitation" id="getting-around-the-non-free-monad-limitation">Getting Around The Non-Free-Monad Limitation</a></h2>
<p>Unfortunately, this <code>Coproduct</code> + <code>Free</code> approach only works on <code>Free</code> monads; it does not work for other non-<code>Free</code> monads. As the paper says, the <code>ListT</code> and <code>StateT</code> monads are not free monads. Why? Let's consider the <code>StateT</code> monad. The issue at hand are its laws. If I call <code>set 4</code> and then later call <code>get</code>, <code>get</code> should return <code>4</code>. By using <code>Free</code> as we have so far, we cannot uphold that law.</p>
<p>So, how do we get around that limitation? We can define a type that has an instance for <code>Functor</code> and whose values represent terms in a language (similar to our <code>Add</code>, <code>Multiply</code>, <code>Value</code> language) that provides the operations we would expect from such a monad. The paper's example shows how one could create a <code>State</code> monad using this approach. Since it will follow much of what we have already covered before, we'll just show the Purescript version of their code.</p>
<pre><code class="language-haskell">data Add      theRestOfTheComputation = Add Int theRestOfTheComputation
data GetValue theRestOfTheComputation = GetValue (Int -&gt; theRestOfTheComputation)

-- Why the `a` type is `Pure` will become clear
-- in the next section where we define the
-- `Exec` type class instances
add :: forall f. Int -&gt; Free f Unit
add i = liftF $ Add i (Pure unit)

getValue :: forall f. Free f Int
getValue = liftF $ GetValue Pure

-- The `Free` monad's equivalent of `State StateType OutputType`
-- simulates &quot;function(x) =&gt; {
--    var y = get(x);
--    set(x, x + 1);
--    return y;
-- }&quot;
stateComputation :: Free (Coproduct Add1 GetValue) Int
stateComputation = do
  y &lt;- getValue
  add 1
  pure y

-- Computes the pure description of machine instructions
-- that are stored via `Free f a` down into `b`
-- using the provided functions
foldFree :: Functor f =&gt; (a -&gt; b) -&gt; (f b -&gt; b) -&gt; Free f a -&gt; b
foldFree pure _ (Pure x) = pure x
foldFree pure impure (Impure t) = impure (fmap (foldFree pure impure) t)

newtype Memory = Memory Int

class Functor f =&gt; Free f where
  runAlgebra :: f (Memory -&gt; Tuple a Memory) -&gt; (Memory -&gt; Tuple a Memory)

instance Free Add where
  runAlgebra (Add amount restOfComputation) (Memory i) =
    restOfComputation (Memory (i + amount))
instance Free GetValue where
  runAlgebra (GetValue intToRestOfComputation) (Memory i) =
    (intToRestOfComputation i) (Memory i)

instance (Functor f, Functor g) =&gt; Free (Either f g) where
  runAlgebra (Left r) = runAlgebra r
  runAlgebra (Right r) = runAlgebra r

instance (Functor f, Functor g) =&gt; Free (Coproduct f g) where
  runAlgebra (Coproduct either) = runAlgebra either

run :: Functor f =&gt; Free f a -&gt; Memory -&gt; Tuple a Memory
run =
--          Pure               Impure     computation  initialState
  foldFree (\a b -&gt; Tuple a b) runAlgebra

{- In the REPL
&gt; run stateComputation (Memory 4)
(4, Memory 5)
-}
</code></pre>
<h2><a class="header" href="#modular-effects-via-languages" id="modular-effects-via-languages">Modular Effects via Languages</a></h2>
<p>When we learned about the <code>ReaderT</code> design pattern, we saw that it simply &quot;links&quot; the capabilities we need to run a pure computation with its impure implementations (the type class' instances). As we will show later, this makes it much easier to test our &quot;business logic.&quot;</p>
<p>Similarly, the <code>Free</code> monad is the thing which &quot;links&quot; some capability needed in a pure computation with its impure implementation. Whereas <code>ReaderT</code> used &quot;capability type classes,&quot; <code>Free</code> using &quot;languages&quot; like the state manipulation language, <code>Add</code>/<code>GetValue</code>, demonstrated in the previous section. Thus, we can easily add new &quot;effects&quot; to our <code>Free</code> monad by adding more &quot;languages.&quot;</p>
<p>Whereas the <code>ReaderT</code> design pattern would use type class instances to implement these capabilities, a <code>Free</code> monad will use an interpreter. An interpreter can be a few different hings:</p>
<ul>
<li>the actual machine code layer that runs the computation in <code>Effect</code>/<code>Aff</code></li>
<li>a pure computation (used for testing) that runs in <code>Identity</code></li>
<li>something that pretty prints the instructions the computer would execute</li>
</ul>
<h2><a class="header" href="#defining-and-interpreting-languages-for-the-free-monad" id="defining-and-interpreting-languages-for-the-free-monad">Defining and Interpreting Languages for the Free Monad</a></h2>
<p>When we look at how to define a language data type for the <code>Free</code> monad, it follows this pattern (written in meta-language):</p>
<pre><code class="language-haskell">data Language theRestOfTheComputation
  -- Statement that tells interpreter to do something but
  -- doesn't pass down any arguments into the interpreter
  -- or receive any values from the interpreter
  = Function_No_Arg theRestOfTheComputation

  -- Arg is known by Function and passed down to the interpreter
  | Function_1_Arg Arg_Passed_to_Interpreter theRestOfTheComputation
  | Function_2_Args Arg1 Arg2 theRestOfTheComputation

  -- `Value` is provided by the interpreter
  -- when it finishes interpreting the language
  | Get_1_Value (Value_Provided_By_Interpreter -&gt; theRestOfTheComputation)
  | Get_2_Values (Value1 -&gt; Value2 -&gt; theRestOfTheComputation)

  -- Use both
  | Function_With_Getter Arg_Passed_to_Interpreter (Value_Provided_By_Interpreter -&gt; theRestOfTheComputation)
</code></pre>
<p>So far, we've only defined a data type with one value and composed those data types together. However, what if we treated a data type as a &quot;family&quot; of operations where each value in that data type was an operation? Then our data types might look like this:</p>
<pre><code class="language-haskell">-- A &quot;language&quot; that supports the capabilities of reading from
-- a file and writing to a file
data FileSystem a
  = ReadFromFile FilePath (ContentsOfFile -&gt; a)
  | WriteToFile FilePath NewContents a

-- A &quot;language&quot; that supports the capabilities of reading from
-- the console and writing to the console
data ConsoleIO a
  = ReadFromConsole (String -&gt; a)
  | WriteToConsole String a
  -- This shouldn't be here, but it will show below how code is usually written
  -- via do notation when either one of these argument types is used
  | WriteThenRead String (String -&gt; a)
</code></pre>
<p>Using these data structure, we can &quot;interpret&quot; these non-runnable pure programs into an equivalent runnable impure program (e.g. <code>Effect</code>). Assuming these functions exist...</p>
<pre><code class="language-haskell">consoleRead :: Effect String

consoleWrite :: String -&gt; Effect Unit

readFromFile :: FilePath -&gt; Effect String

writeToFile :: FilePath -&gt; String -&gt; Effect Unit
</code></pre>
<p>... we could take our pure &quot;description&quot; of computations (e.g. <code>Free ConsoleIO a</code>) and &quot;interpret&quot; it into an impure <code>Effect</code> monad:</p>
<pre><code class="language-haskell">class Functor f =&gt; Exec f where                                      {-
  execAlgebra :: f (Effect a) -&gt; Effect a                            -}
  execAlgebra :: f  Effect    ~&gt; Effect

instance Exec ConsoleIO where
  execAlgebra (ReadFromConsole reply) = do
    -- use the `bind` output from `consoleRead` and pass it into `reply`
    -- which will lift the result back into a `Free (Coproduct ...) a`
    -- which will be lifted into the Monadic type via `pure`.
    -- At a later time in the `fold` process,
    -- the `Free (Coproduct ...) a` will be evaluated again
    -- using `fold execAlgebra expression`,
    -- which will start this loop all over again
    -- until the final output is reached
    result &lt;- consoleRead
    pure (reply result)
  execAlgebra (WriteToConsole msg remainingComputation) = do
    consoleWrite msg
    pure remainingComputation
  execAlgebra (WriteThenRead msg reply) = do
    consoleWrite msg
    input &lt;- consoleRead
    pure (reply input)

{- our &quot;run&quot; function but using the `execAlgebra`
exec :: Exec f =&gt; Free f a -&gt; Effect a                          -}
exec :: Exec f =&gt; Free f   ~&gt; Effect
exec = foldFree pure execAlgebra

-- assuming we have smart constructors for each of our data types
writeToConsole :: forall f. String -&gt; Free f Unit
writeToConsole msg = liftF $ WriteToConsole msg

-- we exclude FileSystem from this computation
consoleComputation :: Free ConsoleIO a
consoleComputation = do
  writeToConsole &quot;What is your name?&quot;
  name &lt;- readFromConsole
  writeToConsole $ &quot;You wrote&quot; &lt;&gt; name
  writeToConsole &quot;Now exiting.&quot;

{-
If this could be run in the REPL, it might look like this:
&gt; exec consoleComputation
What is your name?
[User inputs 'mike']
You wrote mike
Now exiting.
-}
</code></pre>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Thus, say we had a program that needed a number of capabilities:</p>
<ul>
<li>read/write to the console</li>
<li>random number generation</li>
<li>gets current date/time</li>
</ul>
<p>That program might look something like this:</p>
<pre><code class="language-haskell">type Message = String
type Prompt = String
type UserInput = String

-- first language family
data ConsoleIO a
  = WriteToConsole Message a
  | ReadFromConsole Prompt (UserInput -&gt; a)

-- second language family
data RandomNumber a
  = GenerateRandomNumber (Int -&gt; a)

-- Third language family
data DateTime a
  = GetCurrentDateTime (DateTime -&gt; a)

-- We could compose these languages/capabilities together via Coproduct
type Language = Coproduct3 ConsoleIO RandomNumber DateTime
type Program = Free Language

-- We can then define a pure computation using our Free monad
        -- Free (Coproduct3 ConsoleIO RandomNumber DateTime) output
program :: Program output
program = do
  -- imagine we defined smart constructors for each language and term above
  dateTime &lt;- getCurrentDateTime
  writeToConsole $ show dateTime &lt;&gt; &quot;: Input your name:&quot;
  name &lt;- readFromConsole &quot;My name: &quot;
  random &lt;- generateRandomNumber
  let encryptedName = encryptNameWith name random
  dateTime' &lt;- getCurrentDateTime
  writeToConsole $ show dateTime' &lt;&gt; &quot;: Your encrypted name is: &quot; &lt;&gt; encryptedName
  pure encryptedName

-- which does not become &quot;impure&quot; until it's actually interpreted
runProgram :: Effect Unit
runProgram = foldFree go program

  -- pseudo-code below!
  where
  go :: Language ~&gt; Effect
  go =
    coproduct3
      (\WriteToConsole msg next) -&gt; do
        Console.log msg
        pure next
      (\ReadFromConsole prompt reply) -&gt; do
        response &lt;- Console.read prompt
        pure (reply response)
      -- etc.
</code></pre>
<h1><a class="header" href="#layered-compilers" id="layered-compilers">Layered Compilers</a></h1>
<p>Previously, we saw that we could &quot;interpret&quot; the <code>Free</code> monad into another monad, namely, <code>Effect</code>, to simulate state manipulation effects. This idea is similar to a compiler: a high-level language (i.e. <code>Free</code>'s languages) get &quot;compiled&quot;/&quot;interpreted&quot; into a lower-level language (i.e. <code>Effect</code>/<code>Aff</code>). However, what if we recursively interpreted the <code>Free</code> monad into another <code>Free</code> monad for a few rounds until the last one gets interpreted into the <code>Effect</code> monad?</p>
<pre><code class="language-haskell">type Free1 = Free f a
type Free2 = Free g a
type Free3 = Free h a

-- assuming there is a natural transformation from one to another...
Free1 ~&gt; Free2
Free2 ~&gt; Free3
Free3 ~&gt; Effect
-- means we can effectively write this
Free1 ~&gt; Effect
</code></pre>
<p>This allows us to write one high-level language that gets &quot;interpreted&quot; into a lower-level language, which itself gets interpreted into an even lower-level language. Each <code>~&gt;</code> is going from a high-level abstract language to a lower-level more-platform-specific language. In other words, a chain of compiler, where the output of the previous is the input of the next. Updating our code above to use meta-language, we would have something like this:</p>
<pre><code class="language-haskell">-- Let your domain experts write their domain-specific &quot;programs&quot;
-- using a familiar domain-specific language...
type HighestLevelLanguage = CoproductN Language1 Language2 Language3 -- ...
type HighestLevelProgram = Free HighestLevelLanguage

type HighLevelLanguage = CoproductN LanguageA LanguageB LanguageC -- ...
type HighLevelProgram = Free HighLevelLanguage

type FirstCompiler = HighestLevelProgram ~&gt; HighLevelProgram

-- and let your technical experts &quot;translate&quot; them into working programs
-- via NaturalTransformations
type LowLevelLanguage = CoproductN LanguageX LangaugeY LanguageZ -- ...
type LowLevelProgram = Free LowLevelLanguage

type SecondCompiler = HighLevelProgram ~&gt; LowLevelProgram
type ThirdCompiler = LowLevelProgram ~&gt; Effect -- or Aff

-- given this...
HighestLevelProgram ~&gt; HighLevelProgram
HighLevelProgram ~&gt; LowLevelProgram
LowLevelProgram ~&gt; Effect -- or Aff
-- we compose them to get this
type RealCompiler = HighestLevelProgram ~&gt; Effect -- or Aff

-- which enables this...
runProgram :: RealCompiler -&gt; HighestLevelProgram e -&gt; Effect e
-- ... a program written by a domain-expert in a domain-specific
-- language who is ignorant of all the technical and platform-specific
-- details that make it work...
--
-- ... that has been optimized and works for numerous backends by
-- your technical experts.
--
-- Similar to the ReaderT design pattern, we can always change
-- the infrastructure code to use a new framework, UI, database, etc.
-- without rewriting any of the domain-specific code.
</code></pre>
<h2><a class="header" href="#free-applicative" id="free-applicative">Free Applicative</a></h2>
<p>Since each <code>~&gt;</code> acts like a compiler that compiles the higher-level language (input) into a lower-level language (output), one can also &quot;optimize&quot; a compiler's output in some cases via <code>FreeAp</code>, the Free Applicative type. Unfortunately, this is not covered here (<em>yet</em>), but one should be aware of it. John De Goes overviews this idea below.</p>
<h2><a class="header" href="#related-posts" id="related-posts">Related Posts</a></h2>
<p>To see some examples and the implications of this idea, read the following links and translate the <code>IO</code> monad to <code>Effect</code> and the mention of Purescript's now-outdated <code>Eff</code> monad to <code>Effect</code>. Also note that <code>MTL</code> works faster than <code>Free</code> on Haskell, but I don't know their performance comparison on Purescript:</p>
<ul>
<li><a href="http://degoes.net/articles/modern-fp">A Modern Architecture for FP: Part 1</a></li>
<li>MTL-version of Onion Architecture
<ul>
<li><a href="https://gist.github.com/ocharles/6b1b9440b3513a5e225e">Original Haskell version</a></li>
<li><a href="https://gist.github.com/JordanMartinez/4eb9dd1f5ac4e5220ab3d2cc500c0fce">My port to Purescript</a></li>
</ul>
</li>
<li>MTL vs Free Deathmatch - <a href="https://www.youtube.com/watch?v=JLevNswzYh8">Video</a> &amp; <a href="https://www.slideshare.net/jdegoes/mtl-versus-free">Slides</a></li>
<li><a href="http://degoes.net/articles/modern-fp-part-2">A Modern Architecture for FP: Part 2</a></li>
<li><a href="https://gist.github.com/ocharles/252bc296b659aa32e915e02d02537064">Free? monads with mtl</a> - Linking to this because it relates, but I'm still understanding it myself.</li>
</ul>
<h1><a class="header" href="#from-free-to-run" id="from-free-to-run">From <code>Free</code> to <code>Run</code></a></h1>
<p><strong>Prerequisite: You must be familiar with type-level programming syntax and understand how type-level programming works. If you are not, read through the corresponding folder on type-level syntax, and skim through the first few files of the next major folder, <code>Type Level Programming</code>.</strong></p>
<p>So far, we've used the <code>Free</code> monad to model effects using <code>Coproduct</code>. However, this approach is not very extensible because <code>Coproduct</code> is the &quot;closed&quot; <code>Type -&gt; Type</code> sum type.</p>
<p>This folder will</p>
<ul>
<li>explain what problem arises by using <code>Either</code>/<code>Coproduct</code>, the &quot;closed&quot; sum types</li>
<li>show how to make these effects more extensible by using <code>Variant</code>/<code>VariantF</code>, the &quot;open&quot; sum types</li>
<li>show how to combine <code>VariantF</code> and <code>Free</code> into a more-readable type via <code>Run</code>.</li>
</ul>
<p>As stated in <a href="content/21-Hello-World/05-Application-Structure/src/03-Free/03-From-Free-to-Run/reasonablypolymorphic.com/blog/freer-monads/index.html">Free Programs, More Better Programs</a>, PureScript's <code>Run</code> is the same idea behind Haskell's <code>Eff</code> monad. Moreover, The pre-<code>0.12.0</code> PureScript release's <code>Eff</code> monad that was later changed to <code>Effect</code> is not the same as Haskell's <code>Eff</code> monad, which is covered in that article.</p>
<h1><a class="header" href="#from-either-to-variant" id="from-either-to-variant">From Either to Variant</a></h1>
<h2><a class="header" href="#adding-more-conditions" id="adding-more-conditions">Adding More Conditions</a></h2>
<p>Let's forget <code>Coproduct</code> for a moment and return back to the <code>Either</code> level. When we are writing code, we often need to refactor things. If we are using nested <code>Either</code> types everywhere, there are three ways we could change our code:</p>
<ol>
<li>Change the order of the types position: <code>Either first second</code> &lt;=&gt; <code>Either second first</code></li>
<li>Add/Remove another type: <code>Either first (Either second third)</code> &lt;=&gt; <code>Either first second</code></li>
<li>Change one type to another: <code>Either Int Int</code> &lt;=&gt; <code>Either Int String</code></li>
</ol>
<p>If we made one of the changes above, we would need to change our function's type signatures slightly just to get the code to compile again. If we must do this after writing 20 functions, that's a lot of wasted development time!</p>
<p>Moreover, <code>purescript-either</code> only grants us the ability to define 10 total types in a nested manner. Once we go above that number, we need to write our own convenience functions. If we do this in multiple projects, that's more wasted developer time.</p>
<p>So, what are our options here? We saw previously that we could not define our own special nested <code>Either</code> type without knowing at the type-declaration-time what the next few types are. However, we do know at compile-time what those types will be. We also know at compile-time how many types will exist in a nested <code>Either</code>-like type. This implies that we might want to stop looking at value-level programming for our solutions and instead look at type-level programming. More specifically, we should look at row kinds.</p>
<p>We can use row kinds specified to type (i.e. <code># Type</code>) to specify n-different types that are known at compile-time. As an example, we can look at <code>Record</code>, which is a nested <code>Tuple</code> that uses row kinds to work:</p>
<pre><code class="language-haskell">-- first AND second AND third AND fourth AND last
Tuple first (Tuple second (Tuple third (Tuple fourth last)))
Record (a :: first, b :: second, c :: third, d :: fourth, e :: last)
-- which is more commonly seen using &quot;{}&quot; syntax
       {a :: first, b :: second, c :: third, d :: fourth, e :: last}
</code></pre>
<p>Is it possible to take this same idea and apply it to <code>Either</code>? Yes, which is what <code>purescript-variant</code> does:</p>
<pre><code class="language-haskell">-- first OR second OR third OR fourth OR last
Either first (Either second (Either third (Either fourth last)))
Variant (a :: first, b :: second, c :: third, d :: fourth, e :: last)
-- Unfortunately, there is no equivalent &quot;{}&quot;-like syntax for variants
</code></pre>
<p>The advantage of using the row kinds via <code># Type</code> is that it makes our nested <code>Either</code> type &quot;open&quot; via row polymorphism. Using <code>Record</code> as an example, we'll see that each of the three &quot;prototype code&quot; requirements from above can be achieved without refactoring!</p>
<p>Looking at our requirements from before...</p>
<ol>
<li>Change the order of the types position: <code>Either first second</code> &lt;=&gt; <code>Either second first</code></li>
<li>Add/Remove another type: <code>Either first (Either second third)</code> &lt;=&gt; <code>Either first second</code></li>
<li>Change one type to another: <code>Either String Boolean</code> &lt;=&gt; <code>Either Int Boolean</code></li>
</ol>
<p>... we can see that <code>Record</code> meets our requirements because of row polymorphism:</p>
<pre><code class="language-haskell">-- the function
getName :: forall allOtherFields. { name :: String | allOtherFields } -&gt; String
getName :: { name: theName } = theName

-- normal version
getName { name: &quot;John&quot;, dogName: &quot;Spot&quot; }
-- 1) changed type's order
getName { dogName: &quot;Spot&quot;, name: &quot;John&quot; }
-- 2a) added a type
getName { name: &quot;John&quot;, dogName: &quot;Spot&quot;, age: 20 }
-- 2b) removed a type
getName { name: &quot;John&quot; }
-- 3) changed &quot;dogName&quot; from type `String` to `DogNames`
getName { name: &quot;John&quot;, dogName: Spot }
</code></pre>
<p>All five exampls from above compile. Since <code>Variant</code> uses row kinds via <code># Type</code>, too, it also benefits from these advantages.</p>
<h2><a class="header" href="#using-variant" id="using-variant">Using Variant</a></h2>
<p>Here's the link to the library: <a href="https://pursuit.purescript.org/packages/purescript-variant/5.0.0"><code>purescript-variant</code></a>.</p>
<p><code>Record</code> has support at the syntax-level in Purescript. So, instead of writing <code>Record (key :: ValueType)</code>, we can write <code>{key :: ValueType}</code>. Unfortunately, <code>Variant</code> is not supported at the syntax-level. Thus, we must be explicit and use type-level programming. The following code shows how to write <code>inject</code> and <code>project</code> via <code>Variant</code> and <code>Symbol</code>s, type-level <code>String</code>s.</p>
<p><strong>If you haven't already done so, read through the Syntax folder on Type-Level Programming Syntax</strong></p>
<h3><a class="header" href="#injection" id="injection">Injection</a></h3>
<pre><code class="language-haskell">injectFruit :: forall v. Fruit -&gt; Variant (fieldName :: Fruit | v)
injectFruit fruit = inj (Proxy :: Proxy &quot;fieldName&quot;) fruit
</code></pre>
<h3><a class="header" href="#projection" id="projection">Projection</a></h3>
<pre><code class="language-haskell">projectFruit :: forall v. Variant (fieldName :: Fruit | v) -&gt; Maybe Fruit
projectFruit variant = prj (Proxy :: Proxy &quot;fieldName&quot;) variant
</code></pre>
<h3><a class="header" href="#pattern-matching-in-variant" id="pattern-matching-in-variant">Pattern Matching in Variant</a></h3>
<p>The other functions that <code>Variant</code> provides can be see via its <a href="https://pursuit.purescript.org/packages/purescript-variant/5.0.0/docs/Data.Variant#v:on">docs</a>. I created the following table after looking at the project's <a href="https://github.com/natefaubion/purescript-variant/blob/v5.0.0/test/Variant.purs">test's source code</a>. Some functions seem to exist to fit different people's syntax preferences:</p>
<table><thead><tr><th>Exhaustively pattern matches types by...</th><th>Allows &quot;open&quot; <code>Variant</code> values?</th><th>Corresponding function's syntax</th></tr></thead><tbody>
<tr><td>Providing default value for missing cases</td><td>Yes</td><td><code>default defaultValue &lt;combinator chain&gt; variantArg</code></td></tr>
<tr><td>Matching all cases</td><td>No</td><td><code>match { eachField: (\a -&gt; {- body for each field -}) } variantArg</code></td></tr>
<tr><td>Matching all cases</td><td>No</td><td><code>case_ &lt;combinator chain&gt; variantArg</code></td></tr>
</tbody></table>
<p>where a <code>&lt;combinator chain&gt;</code> is:</p>
<ul>
<li>single element chain: <code># combinator</code></li>
<li>multi-element chain: <code># combinator1 # combinator2 ... # combinatorN</code></li>
</ul>
<table><thead><tr><th>Combinator</th><th>Expected arguments</th></tr></thead><tbody>
<tr><td><code>on</code></td><td><code>(Proxy :: Proxy &quot;fieldName&quot;) (\value -&gt; {- body -})</code></td></tr>
<tr><td><code>onMatch</code></td><td><code>{ fieldNameN :: (FieldType -&gt; a) }</code></td></tr>
</tbody></table>
<p>Besides those above, <code>Variant</code> also has <code>expand</code> and <code>contract</code>. One takes a <code>Variant</code> that has more fields than just those specified in some function and &quot;expands&quot; it into its full number of nested types. The other takes a fully-expanded <code>Variant</code> and &quot;contracts&quot; it down to a smaller subset of its nested types.</p>
<h2><a class="header" href="#updating-our-solution" id="updating-our-solution">Updating Our Solution</a></h2>
<p>If we return to our <code>FruitGrouper</code> solution from before and use <code>Variant</code> instead of <code>FruitGrouper</code>, here's what we get.</p>
<p>Here's the list of run commands:</p>
<ul>
<li><code>showFruitVariant (injFruit Apple)</code>
<ul>
<li>At step 3 below, only</li>
</ul>
</li>
<li><code>showFruitVariant (injFruit2 Orange)</code>
<ul>
<li>This function <strong>still</strong> works despite <code>showFruitVariant</code> never knowing anything about a <code>Fruit2</code> type!</li>
</ul>
</li>
<li><code>showFruit2Variant (injFruit3 Cherry)</code>
<ul>
<li>This function <strong>still</strong> works despite <code>showFruit2Variant</code> never knowing anything about a <code>Fruit3</code> type!</li>
</ul>
</li>
<li><code>showFruit3Variant (injFruit2 Orange)</code>
<ul>
<li>This function <strong>still</strong> works despite <code>showFruit3Variant</code> never knowing anything about a <code>Fruit2</code> type!</li>
</ul>
</li>
</ul>
<p>For each of the above run commands, do the following to &quot;simulate&quot; one file existing before another one:</p>
<ol>
<li>Start a REPL</li>
<li>Copy and paste each &quot;file&quot; below into the REPL.</li>
<li>Run the commands at the end of this snippet</li>
</ol>
<pre><code class="language-haskell">-- File1's original code: once compiled, it cannot change
import Data.Maybe
import Data.Variant
import Data.Function
import Data.Symbol

data Fruit
  = Apple
  | Banana

showFruit :: Fruit -&gt; String
showFruit Apple = &quot;apple&quot;
showFruit Banana = &quot;banana&quot;

showFruitVariant :: forall v. Variant (fruit :: Fruit | v) -&gt; Maybe String
showFruitVariant = default Nothing
  # onMatch
    { fruit: \appleBanana -&gt; Just (showFruit appleBanana)
    }

injFruit :: forall v. Fruit -&gt; Variant (fruit :: Fruit | v)
injFruit fruit = inj (Proxy :: Proxy &quot;fruit&quot;) fruit

-- File 2. This should work without the previous file being recompiled
data Fruit2 = Orange

showFruit2 :: Fruit2 -&gt; String
showFruit2 Orange = &quot;orange&quot;

showFruit2Variant :: forall v
                     . Variant (fruit2 :: Fruit2 | v)
                    -&gt; Maybe String
showFruit2Variant = default Nothing
  # onMatch
    { fruit2: \orange -&gt; Just (showFruit2 orange)
    }

injFruit2 :: forall v. Fruit2 -&gt; Variant (fruit2 :: Fruit2 | v)
injFruit2 fruit2 = inj (Proxy :: Proxy &quot;fruit2&quot;) fruit2

-- File 3. This should work without the previous 2 files being recompiled
data Fruit3 = Cherry

showFruit3 :: Fruit3 -&gt; String
showFruit3 Cherry = &quot;cherry&quot;

showFruit3Variant :: forall v
                     . Variant (fruit3 :: Fruit3 | v)
                    -&gt; Maybe String
showFruit3Variant = default Nothing
  # onMatch
    { fruit3: \cherry -&gt; Just (showFruit3 cherry)
    }

injFruit3 :: forall v
          -&gt; Fruit3
           . Variant (fruit3 :: Fruit3 | v)
injFruit3 fruit3 = inj (Proxy :: Proxy &quot;fruit3&quot;) fruit3
</code></pre>
<p>Now run the following commands in the REPL:</p>
<p>Amazing!</p>
<h1><a class="header" href="#from-coproduct-to-variantf" id="from-coproduct-to-variantf">From Coproduct to VariantF</a></h1>
<p>Previously, we explained <code>Coproduct</code></p>
<pre><code class="language-haskell">data Either l r = Left l | Right r

newtype Coproduct f g a = Coproduct (Either (f a) (g a))

-- not nested
Either (Value e) (Add e)
Coproduct Value Add e

-- nested
Either   (Value e) (Either   (Add e) (Multiply e))
Coproduct Value    (Coproduct Add     Multiply) e

-- nested using convenience types from both libraries
Either3   (Value e) (Add e) (Multiply e)
Coproduct3 Value     Add     Multiply e
</code></pre>
<p>When covering <code>Either</code>, we explained that it was vulnerable to the following refactoring issues because it is not &quot;open&quot;:</p>
<ol>
<li>Change the order of the types</li>
<li>Add/Remove a type</li>
<li>Change one type to another type</li>
</ol>
<p>Since <code>Coproduct</code> is just a newtype wrapper over an <code>Either</code>, it suffers from the same &quot;closed&quot; problem. Thus, we'll need a corresponding <code>Variant</code>-like type to make it open. That type is <code>VariantF</code>.</p>
<table><thead><tr><th></th><th>Open/Closed</th><th>Kind</th></tr></thead><tbody>
<tr><td><code>Either</code></td><td>Closed</td><td>Type</td></tr>
<tr><td><code>Variant</code></td><td>Open</td><td>Type</td></tr>
<tr><td><code>Coproduct</code></td><td>Closed</td><td>Type -&gt; Type</td></tr>
<tr><td><code>VariantF</code></td><td>Open</td><td>Type -&gt; Type</td></tr>
</tbody></table>
<h2><a class="header" href="#explaining-variantf" id="explaining-variantf">Explaining <code>VariantF</code></a></h2>
<p><a href="https://pursuit.purescript.org/packages/purescript-variant/5.0.0/docs/Data.Functor.Variant#t:VariantF"><code>VariantF</code></a> builds upon <code>Variant</code>. To refresh our memory, <code>Variant</code>...</p>
<ul>
<li>enables us to write nested <code>Either</code>s using row kinds via <code># Type</code> that is refactor-proof due to row polymorphism (i.e. &quot;open&quot; data type).</li>
<li>has two core methods:
<ul>
<li><code>inj</code> (inject): puts a value into a <code>Variant</code></li>
<li><code>prj</code> (project): extracts a value from a <code>Variant</code> if it exists</li>
</ul>
</li>
<li>requires the use of <code>Symbol</code> and <code>Proxy</code> to specify which field within the row is being used</li>
</ul>
<p><code>VariantF</code> adds the additional requirement of using a proxy called <code>FProxy</code> to wrap a type-level higher-kinded type:</p>
<pre><code class="language-haskell">data FProxy (f :: Type -&gt; Type) = FProxy
</code></pre>
<p>Looking at <code>VariantF</code>, we see the following definition, whose type names I have modified to make it look similar to <code>Coproduct</code>:</p>
<pre><code class="language-haskell">data    VariantF (f_and_g :: # Type) a

-- for example
--      VariantF (f :: FProxy F_Type, g :: FProxy G_Type) a
newtype Coproduct f g                a  = Coproduct (Either (f a) (g a))
</code></pre>
<p>Let's see what the code looks like now:</p>
<pre><code class="language-haskell">-- Rather than writing this...
data Fruit_ConcreteType
  = Apple
  | Banana

-- Either Fruit_ConcreteType v
forall v. Variant  (fruit ::        Fruit_ConcreteType     | v)

-- ... we can now write this...
data Fruit_HigherKindedType e
  = Apple
  | Banana
derive instance Functor Fruit_HigherKindedType

-- Either (Fruit_HigherKindedType Int) (v Int)
-- Coproduct Fruit_HigherKindedType v Int
forall v. VariantF (fruit :: FProxy Fruit_HigherKindedType | v) Int
</code></pre>
<h2><a class="header" href="#composing-type-level-types-via-rowapply" id="composing-type-level-types-via-rowapply">Composing Type-Level Types via <code>RowApply</code></a></h2>
<p>When we wanted to compose two or more data types, we used nested <code>Either</code>s. When we wanted to compose two or more higher-kinded data types, we used nested <code>Coproduct</code>s. What, then, do we write to compose two or more type-level higher-kinded types?</p>
<p>We use type aliases for rows and <a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Row#t:RowApply"><code>RowApply</code>/<code>+</code></a> from <code>Prelude</code>:</p>
<pre><code class="language-haskell">import Type.Row (type (+)) -- infix for RowApply
data ValueF e = ValueF Int
data AddF e = AddF e e

-- We create a type alias for a Row that includes
-- that specific higher-kinded type via FProxy
type Value r = (value :: FProxy Valuef | r)
type Add r = (add :: FProxy AddF | r)

-- and then compose the rows together using RowApply / &quot;+&quot;
type ValueAdd r = (Value + Add + r)
-- which desugars ultimately to
type ValueAdd otherRows = (value :: FProxy ValueF, add :: FProxy AddF | otherRows)

-- In our final type, we'll need to use an empty row to &quot;close&quot; the row
-- so that our code compiles
VariantF (ValueAdd + ()) e
</code></pre>
<h2><a class="header" href="#defining-composable-algebras-for-data-types" id="defining-composable-algebras-for-data-types">Defining Composable Algebras for Data Types</a></h2>
<p>To evaluate an expression, we will write this:</p>
<pre><code class="language-haskell">fold (
  case_
    -- valueAlgebra
    # on valueSymbol (\(ValueF x) -&gt; x)                               {-
    # otherAlgebra -- like add or multiply                            -}
  ) expression
</code></pre>
<p>Thus, to make one <code>Algebra</code> (i.e. a fancy name for <code>f a -&gt; a</code>) composable with other algebras of future data types that we might declare, we will write things like this:</p>
<pre><code class="language-haskell">valueAlgebra :: forall r

             -- this is the `case_` function
              . (VariantF r Int -&gt; Int)

             -&gt; (VariantF (Value + r) Int -&gt; Int)
valueAlgebra = on valueSymbol \(ValueF x) -&gt; x
</code></pre>
<h2><a class="header" href="#running-an-algebra-on-an-expression" id="running-an-algebra-on-an-expression">Running an Algebra on an Expression</a></h2>
<p>When we are ready to evaluate an expression, we will need the <code>algebra</code> (<code>f a -&gt; a</code>) that can compute a value when given an expression, and the actual expression. To make it work for all output types, we'll use a generic type. Thus, we get something like this:</p>
<pre><code class="language-haskell">run :: forall f a b output
      . Functor f
     -- |   composed algebra waiting for `case_`     |
     --  |     case_        | # | composed algebra |
     =&gt; ((VariantF () a -&gt; b) -&gt; f output -&gt; output )
     -&gt; Expression f
     -&gt; output
run composedAlgebras expression = fold (case_ # composedAlgebras) expression
</code></pre>
<h2><a class="header" href="#final-result" id="final-result">Final Result</a></h2>
<p>The following files of code are an adapted version of a gist that was sent to me on the Slack channel. The link to the gist will appear after the next few files of code.</p>
<p>The following files can be run using this command below:</p>
<pre><code>spago run -m Free.ExpressionBased.VariantF.Value
spago run -m Free.ExpressionBased.VariantF.Add
spago run -m Free.ExpressionBased.VariantF.Multiply
</code></pre>
<h1><a class="header" href="#01-valuepurs-1" id="01-valuepurs-1">01-Value.purs</a></h1>
<pre><code class="language-haskell">module Free.ExpressionBased.VariantF.Value
  (
  -- data type and VariantF injection stuff
    ValueF, Value, value

  -- eval stuff
  , valueAlgebra, example_value, eval

  -- The &quot;glue&quot; that makes this work (Expression stuff)
  -- Normally, this file would not have these declarations because
  -- a library would provide it and we'd import it here.
  , Expression(..), fold, run
  ) where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.Functor.Variant (VariantF, inj, on, case_)
import Type.Row (type (+))
import Type.Proxy (Proxy(..))

-- Expression, fold, and algebra-unspecific run
-- (These would be imported from the libraries that provide them)
newtype Expression f = In (f (Expression f))

fold :: forall f a. Functor f =&gt; (f a -&gt; a) -&gt; Expression f -&gt; a
fold f (In t) = f (map (fold f) t)

-- see `eval` below
run :: forall f a b output
      . Functor f
      -- |     case_        | # |    algebra       |
     =&gt; ((VariantF () a -&gt; b) -&gt; f output -&gt; output)
     -&gt; Expression f
     -&gt; output
run algebra expression = fold (case_ # algebra) expression

-- data stuff
data ValueF :: Type -&gt; Type
data ValueF e = ValueF Int

derive instance Functor ValueF

-- VariantF stuff
type Value :: Row (Type -&gt; Type) -&gt; Row (Type -&gt; Type)
type Value r = (value :: ValueF | r)

valueSymbol :: Proxy &quot;value&quot;
valueSymbol = Proxy

value :: forall r. Int -&gt; Expression (VariantF (Value + r))
value i = In $ inj valueSymbol (ValueF i)

example_value :: forall r. Expression (VariantF (Value + r))
example_value = value 5

-- eval stuff
valueAlgebra :: forall r
              . (VariantF r Int -&gt; Int)
             -&gt; (VariantF (Value + r) Int -&gt; Int)
valueAlgebra = on valueSymbol \(ValueF x) -&gt; x

-- This function is not necessary.
--
-- It simply makes `run` above seem more sensible by giving you a
-- more familiar name and by defining the output type to be `Int`
eval :: forall f a b
      . Functor f
     =&gt; ((VariantF () a -&gt; b) -&gt; f Int -&gt; Int)
     -&gt; Expression f
     -&gt; Int
eval = run

-- examples
main :: Effect Unit
main = log $ show $ eval valueAlgebra example_value
</code></pre>
<h1><a class="header" href="#02-addpurs-1" id="02-addpurs-1">02-Add.purs</a></h1>
<pre><code class="language-haskell">module Free.ExpressionBased.VariantF.Add
  ( AddF, Add, add
  , example_add, addAlgebra

  , example_value_add, VA, vaAlgebraComposed
  ) where

import Prelude hiding (add)
import Effect (Effect)
import Effect.Console (log)
import Data.Functor.Variant (VariantF, inj, on)
import Type.Row (type (+))
import Type.Proxy (Proxy(..))
import Free.ExpressionBased.VariantF.Value (
    Value, value
  , example_value, valueAlgebra
  , Expression(..), eval
)

-- Data stuff
data AddF e = AddF e e

derive instance Functor AddF

-- Variant Stuff
type Add r = (add :: AddF | r)

addSymbol :: Proxy &quot;add&quot;
addSymbol = Proxy

add :: forall r
       . Expression (VariantF (Add + r))
      -&gt; Expression (VariantF (Add + r))
      -&gt; Expression (VariantF (Add + r))
add x y = In $ inj addSymbol (AddF x y)

example_add :: forall r. Expression (VariantF (Value + Add + r))
example_add = add (value 5) (value 6)

-- Eval stuff
addAlgebra :: forall r
            . (VariantF r Int -&gt; Int)
           -&gt; (VariantF (Add + r) Int -&gt; Int)
addAlgebra = on addSymbol \(AddF x y) -&gt; x + y

-- Composition
type VA r = (Value + Add + r)

example_value_add :: forall r. Expression (VariantF (VA + r))
example_value_add = add (value 4) (add (value 8) example_value)

vaAlgebraComposed :: forall r
                     . (VariantF r Int -&gt; Int)
                    -&gt; (VariantF (VA + r) Int -&gt; Int)
vaAlgebraComposed = valueAlgebra &gt;&gt;&gt; addAlgebra

{-
This could also work if we defined `Add` in the same file as
Value, so that we could use `ValueF`'s data constructor.
It doesn't work here because we did not export
ValueF's data constructor.
To understand why we made this choide,
see &quot;Design Patterns/Smart Constructors&quot;
vaAlgebraBoth :: forall r
                     . (VariantF r Int -&gt; Int)
                    -&gt; (VariantF (VA + r) Int -&gt; Int)
vaAlgebraBoth = onMatch
  { value: \(ValueF x) -&gt; x
  , add: \(AddF x y) -&gt; x + y
  }                                                                 -}

-- Examples
main :: Effect Unit
main = do
  log $ show $ eval vaAlgebraComposed $ example_add
  log $ show $ eval vaAlgebraComposed $ example_value_add

  -- log $ show $ eval vaAlgebraBoth     $ example_add
  -- log $ show $ eval vaAlgebraBoth     $ example_value_add
</code></pre>
<h1><a class="header" href="#03-multiplypurs-1" id="03-multiplypurs-1">03-Multiply.purs</a></h1>
<pre><code class="language-haskell">module Free.ExpressionBased.VariantF.Multiply where

import Prelude hiding (add)
import Effect (Effect)
import Effect.Console (log)
import Data.Functor.Variant (VariantF, inj, on)
import Type.Row (type (+))
import Type.Proxy (Proxy(..))
import Free.ExpressionBased.VariantF.Value (
    Value, value
  , example_value, valueAlgebra

  , Expression(..), eval
)
import Free.ExpressionBased.VariantF.Add (
    Add, add
  , example_add, addAlgebra

  , example_value_add, VA, vaAlgebraComposed
  )

-- data stuff
data MultiplyF e = MultiplyF e e
derive instance Functor MultiplyF

-- VariantF stuff
type Multiply r = (multiply :: MultiplyF | r)

multiplySymbol :: Proxy &quot;multiply&quot;
multiplySymbol = Proxy

multiply :: forall r
       . Expression (VariantF (Multiply + r))
      -&gt; Expression (VariantF (Multiply + r))
      -&gt; Expression (VariantF (Multiply + r))
multiply x y = In $ inj multiplySymbol (MultiplyF x y)

-- eval stuff
multiplyAlgebra :: forall r
                     . (VariantF r Int -&gt; Int)
                    -&gt; (VariantF (Multiply + r) Int -&gt; Int)
multiplyAlgebra =
  on multiplySymbol (\(MultiplyF x y) -&gt; x * y)

-- Composition: Exclude Add - Only Value &amp; Multiply
vmAlgebra :: forall r
              . (VariantF r Int -&gt; Int)
             -&gt; (VariantF (Value + Multiply + r) Int -&gt; Int)
vmAlgebra =
  valueAlgebra &gt;&gt;&gt; multiplyAlgebra

example_value_multiply :: forall r. Expression (VariantF (Value + Multiply + r))
example_value_multiply =
  multiply (value 5) (multiply (value 3) (value 6))

-- Composition: Value, Add, &amp; Multiply
vamAlgebraComposed :: forall r
              . (VariantF r Int -&gt; Int)
             -&gt; (VariantF (Value + Add + Multiply + r) Int -&gt; Int)
vamAlgebraComposed =
  valueAlgebra &gt;&gt;&gt; addAlgebra &gt;&gt;&gt; multiplyAlgebra

-- This approach is not as refactor-resistant
-- to the algebra immediately above
vamAlgebraShorter :: forall r
              . (VariantF r Int -&gt; Int)
             -&gt; (VariantF (VA + Multiply + r) Int -&gt; Int)
vamAlgebraShorter = vaAlgebraComposed &gt;&gt;&gt; multiplyAlgebra

example_value_add_multiply :: forall r. Expression (VariantF (VA + Multiply + r))
example_value_add_multiply =
  add
    (multiply
      (add
        example_value
        (value 8)
      )
      (multiply
        example_value_multiply
        example_add
      )
    )
    example_value_add

main :: Effect Unit
main = do
  log $ show $ eval vmAlgebra          example_value_multiply
  log $ show $ eval vamAlgebraComposed example_value_add_multiply
  log $ show $ eval vamAlgebraShorter  example_value_add_multiply
</code></pre>
<h1><a class="header" href="#original-gist" id="original-gist">Original Gist</a></h1>
<p>My code diverges from the original gist's code by</p>
<ul>
<li>converting the unfamiliar <code>Matryoshka</code>-library types and names into the more familiar types and names we've been using here</li>
<li>defining algebras only via &quot;on&quot; (i.e. <code>on symbol function</code>) rather than using &quot;onMatch&quot; (i.e. <code>onMatch {value: function, add: function}</code>)</li>
<li>the original paper showed how to define an expression that only allowed <code>Value</code> and <code>Multiply</code> operations. xgrommx's original gist did not have this.</li>
</ul>
<p>The following table will help you understand the upcoming links to code:</p>
<table><thead><tr><th>Our Code</th><th>xgrommx's code</th></tr></thead><tbody>
<tr><td><code>newtype Expression f</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-fixed-points/5.1.0/docs/Data.Functor.Mu#t:Mu"><code>newtype Mu f</code></a></td></tr>
<tr><td><code>Expression (VariantF t)</code></td><td><code>MuV t</code></td></tr>
<tr><td><code>In $ inj symbol data</code></td><td><code>injMu symbol data</code></td></tr>
<tr><td><code>f a -&gt; a</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-matryoshka/0.3.0/docs/Matryoshka.Algebra#t:Algebra"><code>Algebra f a</code></a></td></tr>
<tr><td><code>fold</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-matryoshka/0.3.0/docs/Matryoshka.Fold#v:cata"><code>cata</code></a><br><code>Recursive t f</code> can be better understood as <code>t (f t) -&gt; f t</code></td></tr>
</tbody></table>
<p>The links:</p>
<ul>
<li>Read from <code>ADT1.purs</code> to <code>ADT6.purs</code>: <a href="https://github.com/xgrommx/purescript-from-adt-to-eadt/tree/master/src">From Algebraic Data Types (ADTs) to Extensible Algebraic Data Types (EADTs)</a>. This will help us get used to the different names he uses for the same ideas</li>
<li>The <a href="https://gist.github.com/xgrommx/35f912544d37420db5f195c9b515ceb3">original gist</a></li>
</ul>
<h1><a class="header" href="#explaining-run" id="explaining-run">Explaining <code>Run</code></a></h1>
<p>This folder will explain the basic idea of <code>purescript-run</code> and then solve the paper's version of the Expression Problem using it.</p>
<h2><a class="header" href="#what-is-run" id="what-is-run">What is <code>Run</code>?</a></h2>
<p>If you recall, <code>xgrommx</code> mentions <a href="https://pursuit.purescript.org/packages/purescript-run/2.0.0"><code>purescript-run</code></a> in <a href="https://github.com/xgrommx/purescript-from-adt-to-eadt/blob/master/src/ADT8.purs#L11">a comment in <code>ADT8.purs</code></a>. (The ReadMe of this library provides an overview of the ideas we've explained here.)</p>
<p>What is <code>purescript-run</code>? Why would we use that over <code>Free</code>? There are three reasons.</p>
<p>First, let's look at the type of <code>Run</code> :</p>
<pre><code class="language-haskell">newtype Run r a = Run (Free (VariantF r) a)
</code></pre>
<p>We can see that <code>Run</code> is a compile-time-only type that specifies the <code>Functor</code> type of <code>Free</code> to the open <code>CoProduct</code> type: <code>VariantF</code>.</p>
<p>Let's compare the same idea encoded in both forms (note: <code>Run</code> will use naming conventions that will be explained below):</p>
<pre><code class="language-haskell">free :: Free (VariantF (add :: FProxy Add, subtract :: FProxy Subtract)) a
-- is the same as
run  :: Run (ADD + SUBTRACT) a
</code></pre>
<p><strong>In short, <code>Run</code> draws attention to the effects used and eliminates other distracting &quot;noise&quot; that occurs due to a lot of types.</strong></p>
<p>Second, this library exposes helper <a href="https://pursuit.purescript.org/packages/purescript-run/2.0.0/docs/Run#v:interpret">functions</a> that add a <a href="https://pursuit.purescript.org/packages/purescript-tailrec/4.0.0/docs/Control.Monad.Rec.Class#t:MonadRec"><code>MonadRec</code> type class</a> constraint to guarantee that stack overflows won't occur. Due to the recursive nature by which one &quot;interprets&quot; a <code>Free</code> monad, <code>Free</code>-based computations can sometimes result in stack overflows. <strong>These helper functions make it trivial to insure stack-safety.</strong> See the &quot;Stack-Safety&quot; section at the bottom of the project's ReadMe for more info.</p>
<p>Third, <strong>this library already defines types and functions for using and working with different effects</strong> (e.g. <code>StateT</code>, <code>ReaderT</code>, <code>WriterT</code>, etc. but for the <code>Free</code> monad). One does not need to re-implement these types for each project, so that the code works every time. (These are also covered more below)</p>
<h2><a class="header" href="#comparing-run-to-free-and-mtl" id="comparing-run-to-free-and-mtl">Comparing Run to Free and MTL</a></h2>
<h3><a class="header" href="#free-and-run-some-core-functions-compared" id="free-and-run-some-core-functions-compared">Free and Run: Some Core Functions Compared</a></h3>
<p>Let's look at a few core functions (the following block of code is licensed under <a href="https://github.com/natefaubion/purescript-run/blob/v2.0.0/LICENSE">the MIT license</a>:</p>
<pre><code class="language-haskell">newtype Run r a = Run (Free (VariantF r) a)

-- `Run`'s version of `Free`'s `liftF`
lift
    sym r1 r2 f a
  . Row.Cons sym (FProxy f) r1 r2
   IsSymbol sym
   Functor f

   Proxy sym
   f a
   Run r2 a
                    -- Run    (Free    ( VariantF (row :: type)) output)
lift symbol dataType = Run &lt;&lt;&lt; liftF &lt;&lt;&lt; inj symbol dataType

-- This function will appear later in this folder's code
-- | Extracts the value from a purely interpreted program.
extract   a. Run () a  a

-- `Run`'s version of `Free`'s `resume`
peel :: forall a r. Run r a -&gt; Either (VariantF r (Run r a)) a
</code></pre>
<h3><a class="header" href="#naming-conventions-for-effects" id="naming-conventions-for-effects">Naming Conventions for Effects</a></h3>
<p>Let's look at some of the type aliases it provides:</p>
<pre><code class="language-haskell">type EFFECT = FProxy Effect
type AFF = FProxy Aff
</code></pre>
<p>Rather than typing <code>(fieldName :: FProxy Functor)</code>, we use an all-caps type alias: <code>(fieldName :: FUNCTOR)</code>. This improves code readability, so we will follow suit.</p>
<h3><a class="header" href="#similarities-to-mtl" id="similarities-to-mtl">Similarities to MTL</a></h3>
<h4><a class="header" href="#type-aliases" id="type-aliases">Type Aliases</a></h4>
<p><code>purescript-run</code> has a few other type aliases that will look familiar.</p>
<pre><code class="language-haskell">newtype Reader e a = Reader (e  a)
type READER e = FProxy (Reader e)

data State s a = State (s  s) (s  a)
type STATE s = FProxy (State s)

data Writer w a = Writer w a
type WRITER w = FProxy (Writer w)

newtype Except e a = Except e
type EXCEPT e = FProxy (Except e)
type FAIL = EXCEPT Unit
</code></pre>
<p>The takeaways here:</p>
<ul>
<li>As stated above, <code>purescript-run</code> already defines and properly handles the types that make the same effects we saw in the <code>MTL</code> folder work out-of-box.</li>
<li>The <code>a</code> in each type is the output type, so it is excluded.</li>
<li><code>FAIL</code> indicates an error whose type we don't care about.</li>
</ul>
<h4><a class="header" href="#mtl-like-functions" id="mtl-like-functions">MTL-Like Functions</a></h4>
<p>If we look at some of the functions that each of the above MTL-like types provide, we'll notice another pattern. Each type (e.g. <code>Reader</code>) seems to define its own <code>Symbol</code> (e.g. <code>_reader :: Proxy &quot;reader&quot;</code>) for the corresponding type in <code>VariantF</code>'s row type (e.g. <code>READER</code>).</p>
<p>However, if one wanted to use a custom <code>Symbol</code> name for their usage of an MTL-like type (e.g. <code>Reader</code>), they can append <code>at</code> to the function and get the same thing. In other words:</p>
<pre><code class="language-haskell">liftReader readerObj = liftReaderAt _reader readerObj

liftReaderAt symbol readerObj = -- implementation

ask = askAt _reader

askAt symbol = -- implementation
</code></pre>
<p>In short, one can use a <code>Run</code>-based monad to do two different state computations in the same function, something which the unmodified <code>MTL</code> approach via <code>MonadState</code> cannot do.</p>
<h2><a class="header" href="#examples-of-mtl-like-run-based-code" id="examples-of-mtl-like-run-based-code">Examples of MTL-Like Run-Based Code</a></h2>
<ul>
<li>See this project's <code>Hello World/Projects/src/Simplest Program</code> folder for an example of what a very simple program with a <code>Run</code>-based architecture looks like.</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-run/2.0.0/docs/Run#t:Run">A simple program using multiple effects</a></li>
<li>A <a href="https://github.com/natefaubion/purescript-run#free-dsls">short explanation from Free to Run</a> that also covers <code>Coproduct</code>/<code>VariantF</code> and whose code can be found in the project's test directory:
<ul>
<li><a href="https://github.com/natefaubion/purescript-run/blob/master/test/Examples.purs">Examples.purs</a></li>
<li><a href="https://github.com/natefaubion/purescript-run/blob/master/test/Main.purs">Main.purs</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#01-valuepurs-2" id="01-valuepurs-2">01-Value.purs</a></h1>
<pre><code class="language-haskell">module Free.RunBased.Value (main, value, example_value) where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Run (Run, extract)

value :: forall r. Int -&gt; Run r Int
value i = pure i

example_value :: forall r. Run r Int
example_value = value 5

main :: Effect Unit
main = do
  log $ show $ extract example_value
</code></pre>
<h1><a class="header" href="#02-addpurs-2" id="02-addpurs-2">02-Add.purs</a></h1>
<pre><code class="language-haskell">module Free.RunBased.Add
  ( main
  , AddF, ADD, add
  , example_add, addAlgebra
  , eval
  ) where
--
import Prelude hiding (add)
import Effect (Effect)
import Effect.Console (log)
import Data.Either (Either(..))
import Data.Functor.Variant (VariantF, on, case_)
import Type.Row (type (+))
import Type.Proxy (Proxy(..))
import Free.RunBased.Value (value)
import Run (Run, lift, peel)

-- Data stuff
data AddF e = AddF e e

derive instance Functor AddF

-- Variant Stuff
type ADD r = (add :: AddF | r)

_add :: Proxy &quot;add&quot;
_add = Proxy

{-
We know from previous code that we need a type signature like
add :: Expression a
    -&gt; Expression a
    -&gt; Expression a

However, if we follow the same pattern we've been using via `Run.lift`
the return type's `a` will be another &quot;Expression a&quot;
-}
add_problematic :: forall r a
                 . Run (ADD + r) a
                -&gt; Run (ADD + r) a
                -&gt; Run (ADD + r) (Run (ADD + r) a)
add_problematic x y = lift _add (AddF x y)

{-
To get around this problem, we need to remember that
Run is a monad. Thus, the above type signature could look like this:

    add_problematic :: forall m a
                     . Monad m
                    =&gt; m a
                    -&gt; m a
                    -&gt; m (m a)

We need a function whose type signature is...
    m (m a) -&gt; m a
... to get rid of that nested monad.
This is known as 'join' from 'Bind'                                         -}
add_correct :: forall r a
             . Run (ADD + r) a
            -&gt; Run (ADD + r) a
            -&gt; Run (ADD + r) a
add_correct x y = join $ add_problematic x y

-- Putting it all on one line:
add :: forall r a
     . Run (ADD + r) a
    -&gt; Run (ADD + r) a
    -&gt; Run (ADD + r) a
add x y = join $ lift _add (AddF x y)

example_add :: forall r. Run (ADD + r) Int
example_add = add (value 5) (value 6)

-- Eval stuff
addAlgebra :: forall r
            . (VariantF r Int -&gt; Int)
           -&gt; (VariantF (ADD + r) Int -&gt; Int)
addAlgebra = on _add \(AddF x y) -&gt; x + y

-- fold
iter :: forall r a. (VariantF r a -&gt; a) -&gt; Run r a -&gt; a
iter k = go
  where
  go m = case peel m of
    Left f -&gt; k (go &lt;$&gt; f)
    Right a -&gt; a

eval :: forall r a b
      . ((VariantF () a -&gt; b) -&gt; VariantF r Int -&gt; Int)
     -&gt; Run r Int
     -&gt; Int
eval algebra = iter (case_ # algebra)

-- Examples
main :: Effect Unit
main = do
  log $ show $ eval addAlgebra example_add
</code></pre>
<h1><a class="header" href="#03-multiplypurs-2" id="03-multiplypurs-2">03-Multiply.purs</a></h1>
<pre><code class="language-haskell">module Free.RunBased.Multiply where

import Prelude hiding (add)
import Effect (Effect)
import Effect.Console (log)
import Data.Functor.Variant (VariantF, on)
import Type.Row (type (+))
import Type.Proxy (Proxy(..))
import Free.RunBased.Value (value)
import Free.RunBased.Add (ADD, add, addAlgebra, eval)
import Run (Run, lift)

-- Data stuff
data MultiplyF e = MultiplyF e e

derive instance Functor MultiplyF

-- Variant Stuff
type MULTIPLY r = (multiply :: MultiplyF | r)

_multiply :: Proxy &quot;multiply&quot;
_multiply = Proxy

multiply :: forall r a
     . Run (MULTIPLY + r) a
    -&gt; Run (MULTIPLY + r) a
    -&gt; Run (MULTIPLY + r) a
multiply x y = join $ lift _multiply (MultiplyF x y)

example_multiply :: forall r. Run (MULTIPLY + r) Int
example_multiply = multiply (value 5) (value 6)

-- Eval stuff
multiplyAlgebra :: forall r
            . (VariantF r Int -&gt; Int)
           -&gt; (VariantF (MULTIPLY + r) Int -&gt; Int)
multiplyAlgebra = on _multiply \(MultiplyF x y) -&gt; x * y

amAlgebra :: forall r
           . (VariantF r Int -&gt; Int)
          -&gt; (VariantF (ADD + MULTIPLY + r) Int -&gt; Int)
amAlgebra = addAlgebra &gt;&gt;&gt; multiplyAlgebra

-- Examples
main :: Effect Unit
main = do
  log $ show $ eval multiplyAlgebra example_multiply
  log $ show $ eval amAlgebra (multiply (add (value 5) (multiply (value 2) (value 4))) (value 5))
</code></pre>
<h1><a class="header" href="#drawbacks-of-free" id="drawbacks-of-free">Drawbacks of Free</a></h1>
<p>In the below video, John De Goes explains what some of the limitations of the Free monad are, why, how fixes for them can be &quot;hacked in,&quot; and what is needed to ultimately fix them...</p>
<ul>
<li>parallelism</li>
<li>racing</li>
<li>alternatives</li>
<li>e.g. stuff one can't model using just the Monad structure of Free</li>
</ul>
<p>Video Link: <a href="https://www.youtube.com/watch?v=A-lmrvsUi2Y">Beyond Free Monads</a></p>
<h1><a class="header" href="#random-number" id="random-number">Random Number</a></h1>
<p>This folder will show how to build a the infamous &quot;hello world&quot; program using the various approaches (i.e. <code>ReaderT</code>, <code>Free</code>, and <code>Run</code>) to structuring one's application in such a way that the pure domain logic is separated from the impure effects needed to make it work.</p>
<p>This is as simple as can be: the program prints &quot;hello world&quot; to the console and then terminates.</p>
<h2><a class="header" href="#compilation-instructions-2" id="compilation-instructions-2">Compilation Instructions</a></h2>
<p>Run the following while in the <code>Hello World/Application Structure/</code> folder.</p>
<pre><code class="language-bash">spago run -m Examples.HelloWorld.ReaderT
spago run -m Examples.HelloWorld.Free
spago run -m Examples.HelloWorld.Run
</code></pre>
<h1><a class="header" href="#design-thought-process" id="design-thought-process">Design Thought-Process</a></h1>
<p>This program will generate a random number, determine whether that random number is greater than or less to a hard-coded value (to simulate a domain idea) and then print its results.</p>
<h2><a class="header" href="#level-4--core" id="level-4--core">Level 4 / Core</a></h2>
<p>For this program now, there are no domain concepts or rules/relationships.</p>
<h2><a class="header" href="#level-3--domain" id="level-3--domain">Level 3 / Domain</a></h2>
<p>The program consists of 1 steps:</p>
<ol>
<li>log &quot;Hello World&quot; to the console</li>
</ol>
<h2><a class="header" href="#level-2--api" id="level-2--api">Level 2 / API</a></h2>
<p>The &quot;effects&quot; or &quot;capabilities&quot; we need to run this program are relatively simple:</p>
<ul>
<li>The capability to send a message to the user</li>
</ul>
<h2><a class="header" href="#level-1--infrastructure" id="level-1--infrastructure">Level 1 / Infrastructure</a></h2>
<p>This capability can be obtained by the runtime system:</p>
<ul>
<li>For this program, we will only &quot;send a message to the user&quot; in one way: log it to the console. In future projects, we could also use Halogen (or React) to print a message to our web app.</li>
</ul>
<h2><a class="header" href="#level-0--machine-code" id="level-0--machine-code">Level 0 / Machine Code</a></h2>
<p>Production: we'll use <code>Effect</code> as our base monad to run the code</p>
<h1><a class="header" href="#02-readertpurs" id="02-readertpurs">02-ReaderT.purs</a></h1>
<pre><code class="language-haskell">module Examples.HelloWorld.ReaderT where

import Prelude
import Effect (Effect)
import Effect.Console as Console
import Effect.Class (class MonadEffect, liftEffect)
import Control.Monad.Reader.Trans (ReaderT, runReaderT)

-----------------------------------------
-- Core: Define any domain-specific concepts and their rules/relationships to
--         other domain-specific concepts

-- since there are no domain concepts or rules/relationships,
--    we won't include anything here...

-----------------------------------------
-- Domain: define business logic and capabilities need to run it:

-- - define our business logic as one pure function (program)
--      that uses type class constraints to define the effects our
--      program requires to be run
program :: forall m.                -- for any monad supporting these capabilities/effects--
           LogToScreen m =&gt;         --   one of which is logging a message
           m Unit                   -- --running this monad will produce no output.
                                    -- However, running it will produce side-effects
                                    -- that make running this code useful
program = do
  -- use capability to log a message to the console
  logToScreen &quot;Hello World!&quot;

-- - declare what those capabilities are as type classes that require monadic types.
class (Monad m) &lt;= LogToScreen m where
  logToScreen :: String -&gt; m Unit

-----------------------------------------
-- API: define how the pure domain concepts and logic above translate
--        down into pure effects and impure effects via a `ReaderT`-based monad

-- - a newtyped ReaderT monad called &quot;AppM&quot; that hard-codes the Environent
--      type (&quot;Unit&quot; in this case because there is no global config value)
--      and the base monad (Effect in this case)
newtype AppM a = AppM (ReaderT Unit Effect a)

-- - a 'runAppM' function that unwraps the AppM newtype and runs the program
--      in the `Effect` monad, which is transformed/augmented by the ReaderT function
--      Since we don't have any global config being passed into our program,
--        we just pass in &quot;unit&quot;
runAppM :: AppM ~&gt; Effect
runAppM (AppM m) = runReaderT m unit

-- - Since there is no global configuration value for this program
--      we do not need AppM to have an instance for MonadAsk
-- derive newtype instance MonadAsk e AppM

-- - write instances for capabilities above, so that AppM can use them
instance LogToScreen AppM where
  logToScreen :: String -&gt; AppM Unit
  logToScreen message = liftEffect $ Console.log message


-- - derive instances for AppM, so that it is a Monad via ReaderT
derive newtype instance Functor AppM
derive newtype instance Applicative AppM
derive newtype instance Apply AppM
derive newtype instance Bind AppM
derive newtype instance Monad AppM

-- - enable functions that return `Effect a` to be run inside our `AppM` program
--      such as Effect.Console.log
derive newtype instance MonadEffect AppM

-----------------------------------------
-- Infrastructure: any other code (i.e. databases, frameworks, libraries)
--                   that provides effects that do not appear in `Effect.*` modules

-- We aren't using other libraries (Node.ReadLine, Halogen, etc.).
-- Thus, nothing needs to go here for right now

-----------------------------------------
-- Machine Code: set up everything we need and then run the program

main :: Effect Unit
main = do
  -- no global config to set up here

  -- run the program by passing the domain logic into the `runAppM` function
  runAppM program
</code></pre>
<h1><a class="header" href="#03-freepurs" id="03-freepurs">03-Free.purs</a></h1>
<pre><code class="language-haskell">module Examples.HelloWorld.Free where

import Prelude
import Effect (Effect)
import Effect.Console as Console
import Control.Monad.Free (Free, liftF, foldFree)

-----------------------------------------
-- Core: Define any domain-specific concepts and their rules/relationships to
--         other domain-specific concepts

-- define any domain-specif concepts
newtype HardCodedInt = HardCodedInt Int

-- and their rules and relationships to other concepts via
--  - functions
--  - type classes

-- since there are no rules/relationships, we won't include anything here...

-----------------------------------------
-- Domain: define business logic and capabilities need to run it:

-- - define our business logic as one pure function (program)
--      that uses data types that have Functor instances
--      to define the effects our program requires to be run
program :: Free                       -- A program that...
            AllEffects                -- ... given an interpreter for each one of its 'effects'...
            Unit                      -- ... will produce no output.
                                      -- However, running it will produce side-effects
                                      -- that make this program useful
program = do
  -- use capability to log a message to the console
  logToScreen &quot;Hello World!&quot;

-- - define a type alias that defines what all our effects/capabilities are
type AllEffects =
    LogToScreen  -- we only have one, which enables logging to the screen

-- - declare what the capabilities/effects are as data types with
--     derived instances for `Functor` and write their smart constructors.
data LogToScreen a = LogToScreen String a
derive instance Functor LogToScreen

logToScreen :: String -&gt; Free AllEffects Unit
logToScreen message = liftF $ LogToScreen message unit

-----------------------------------------
-- API: define how the pure domain concepts and logic above translate
--        into pure effects and impure effects via
--        &quot;data type interpreters&quot; (i.e. F-Algebras)

-- - an &quot;interpreter&quot; from each data type used above to the base monad, Effect
--    via a Natural Transformation
logToScreenToEffect :: LogToScreen ~&gt; Effect
logToScreenToEffect (LogToScreen msg next) = do
  Console.log msg
  pure next

-- - an interpreter from the (Free AllEffects) type to the base monad, Effect,
--      using `foldFree` and the above interprters.
runProgram :: Free AllEffects ~&gt; Effect
runProgram = foldFree go

  where
  -- - route each data type to its correct interpreter
  go :: AllEffects ~&gt; Effect
  go = logToScreenToEffect

-----------------------------------------
-- Infrastructure: any other code (i.e. databases, frameworks, libraries)
--                   that provides effects that do not appear in `Effect.*` modules

-- We aren't using other libraries (Node.ReadLine, Halogen, etc.).
-- Thus, nothing needs to go here for right now


-----------------------------------------
-- Machine Code: set up everything we need and then run the program

main :: Effect Unit
main = do
  -- no global config to set up here

  -- run the program by passing in the final data type
  -- that includes all the instructions to run via their interpreters.
  runProgram program
</code></pre>
<h1><a class="header" href="#04-runpurs" id="04-runpurs">04-Run.purs</a></h1>
<pre><code class="language-haskell">module Examples.HelloWorld.Run where

import Prelude
import Effect (Effect)
import Effect.Console as Console
import Type.Row (type (+))
import Type.Proxy (Proxy(..))
import Data.Functor.Variant (on)
import Run (Run, lift, interpret, case_)

-----------------------------------------
-- Core: Define any domain-specific concepts and their rules/relationships to
--         other domain-specific concepts

-- since there are no domain concepts or rules/relationships,
--    we won't include anything here...

-----------------------------------------
-- Domain: define business logic and capabilities need to run it:

-- - define our business logic as one pure function (program)
--      that uses data types that have Functor instances
--      to define the effects our program requires to be run
program :: forall r.
           Run                     -- A program that, given an interpreter that...
            ( LOG_TO_SCREEN        --    can enable logging to the screen
            + r                    --    and any other effects/capabilities
            )                      --       we may add later
            Unit                   -- ... will produce no output.
                                   -- However, running it will produce side-effects
                                   -- that make this program useful
program = do
  -- use capability to log a message to the console
  logToScreen &quot;Hello World!&quot;

-- - declare what the capabilities/effects are as data types with
--     derived instances for `Functor`,
--   define their type-level Strings that act as their corresponding label in a row,
--   define a type alias that makes using the data type in rows easier
--   and write their smart constructors.
data LogToScreen a = LogToScreen String a
derive instance Functor LogToScreen

_logToScreen :: Proxy &quot;logToScreen&quot;
_logToScreen = Proxy

type LOG_TO_SCREEN r = (logToScreen :: LogToScreen | r)

logToScreen :: forall r. String -&gt; Run (LOG_TO_SCREEN + r) Unit
logToScreen msg = lift _logToScreen $ LogToScreen msg unit

-----------------------------------------
-- API: define how the pure domain concepts and logic above translate
--        into pure effects and impure effects via
--        &quot;data type interpreters&quot; (i.e. F-Algebras)

-- - an &quot;interpreter&quot; for each data type used above
logToScreenToEffect :: LogToScreen ~&gt; Effect
logToScreenToEffect (LogToScreen msg next) = do
  Console.log msg
  pure next

-- Reader does not need to be done since `purescript-run` already defines
-- an interpreter via `runReader`

-- - an interpreter from the (Run &lt;AllEffects&gt;) type to the base monad, Effect.
--   Since we are not adding, any new effects/capabilities at this time,
--      we close the row kind using an empty row (i.e. &quot;()&quot;)
--   Since we are using &quot;open&quot; row kinds, we need to use &quot;case_&quot; to insure that
--      all effects/capabilities are interpreted.
runProgram :: Run ( LOG_TO_SCREEN
                  + () -- closes the &quot;open&quot; row kinds of &quot;program&quot;
                  )
              ~&gt; Effect
runProgram p =
  p
    -- use &quot;interpret&quot; and &quot;case_&quot; for capabilities
    # interpret (
        case_
          # on _logToScreen logToScreenToEffect
      )

-----------------------------------------
-- Infrastructure: any other code (i.e. databases, frameworks, libraries)
--                   that provides effects that do not appear in `Effect.*` modules

-- We aren't using other libraries (Node.ReadLine, Halogen, etc.).
-- Thus, nothing needs to go here for right now

-----------------------------------------
-- Machine Code: set up everything we need and then run the program

main :: Effect Unit
main = do
  -- no global config to set up here

  -- run the program by passing in the final data type
  -- that includes all the instructions to run via their interpreters.
  runProgram program
</code></pre>
<h1><a class="header" href="#random-number-1" id="random-number-1">Random Number</a></h1>
<p>This folder will show how to build a very simple program using the various approaches (i.e. <code>ReaderT</code>, <code>Free</code>, and <code>Run</code>) to structure one's application in such a way that the pure domain logic is separated from the impure effects needed to make it work.</p>
<p>To keep things simple, this program will only use the <code>Effect</code> monad and basic effects, such as logging to the screen some output and generating a random number. It will not use the slightly more complicated monad, <code>Aff</code>, or other libraries that provide specifc effects like getting the users' input via <code>Node.ReadLine</code> and/or running the application as a web app via <code>Halogen</code>.</p>
<p>As said before, by structuring programs in this style, it makes them easier to test and benchmark the domain logic because these are pure functions, not impure ones. However, tests and benchmarks for this program will not be done.</p>
<p>The upcoming projects will build on this pattern and include tests/benchmarks there.</p>
<h2><a class="header" href="#compilation-instructions-3" id="compilation-instructions-3">Compilation Instructions</a></h2>
<p>Run the following while in the <code>Hello World/Application Structure/</code> folder.</p>
<pre><code class="language-bash">spago run -m Examples.NumberComparison.ReaderT
spago run -m Examples.NumberComparison.Free
spago run -m Examples.NumberComparison.Run
</code></pre>
<h1><a class="header" href="#design-thought-process-1" id="design-thought-process-1">Design Thought-Process</a></h1>
<p>This program will generate a random number, determine whether that random number is greater than or less to a hard-coded value (to simulate a domain idea) and then print its results.</p>
<h2><a class="header" href="#level-4--core-1" id="level-4--core-1">Level 4 / Core</a></h2>
<p>We'll first define the types we'll be using throughout our program. Since the only domain-specifc idea we want to model is a hard-coded number that has no properties or relationships with other values, this will be simple:</p>
<table><thead><tr><th>Type Name</th><th>What it is</th><th>Properties/Purpose</th><th>Implementation</th></tr></thead><tbody>
<tr><td>HardCodedInt</td><td>Something to simulate a domain concept we're trying to model</td><td>it can be less than, equal to, or greater than, a randomly-generated number</td><td>a newtyped <code>Int</code></td></tr>
</tbody></table>
<h2><a class="header" href="#level-3--domain-1" id="level-3--domain-1">Level 3 / Domain</a></h2>
<p>The program consists of 3 steps:</p>
<ol>
<li>generate a random integer</li>
<li>get the hardcoded integer value from the global configuration</li>
<li>log whether the random integer is less than, equal to, or greater than our hard-coded integer</li>
</ol>
<h2><a class="header" href="#level-2--api-1" id="level-2--api-1">Level 2 / API</a></h2>
<p>The &quot;effects&quot; or &quot;capabilities&quot; we need to run this program are relatively simple:</p>
<ul>
<li>The capability to generate a random <code>Int</code> value (Note: this random number generator does not need cryptography-level security)</li>
<li>The capability to send a message to the user</li>
<li>The capability to get the hard-coded value from the global configuration</li>
</ul>
<h2><a class="header" href="#level-1--infrastructure-1" id="level-1--infrastructure-1">Level 1 / Infrastructure</a></h2>
<p>These two capabilities can be obtained by the runtime system:</p>
<ul>
<li>The random number generation can be done via the <code>Effect.Random (randomInt)</code> function</li>
<li>For this program, we will only &quot;send a message to the user&quot; in one way: log it to the console. In future projects, we could also use Halogen (or React) to print a message to our web app.</li>
</ul>
<p>Getting the hard-coded value requires us to use a <code>ReaderT</code>-like approach to getting that value.</p>
<h2><a class="header" href="#level-0--machine-code-1" id="level-0--machine-code-1">Level 0 / Machine Code</a></h2>
<p>Production: we'll use <code>Effect</code> as our base monad to run the code</p>
<h1><a class="header" href="#02-readertpurs-1" id="02-readertpurs-1">02-ReaderT.purs</a></h1>
<pre><code class="language-haskell">module Examples.NumberComparison.ReaderT where

import Prelude
import Effect (Effect)
import Effect.Console as Console
import Effect.Random (randomInt)
import Effect.Class (class MonadEffect, liftEffect)
import Control.Monad.Reader.Trans (ReaderT, runReaderT)
import Control.Monad.Reader.Class (class MonadAsk, asks)
import Type.Equality (class TypeEquals, from)

-----------------------------------------
-- Core: Define any domain-specific concepts and their rules/relationships to
--         other domain-specific concepts

-- define any domain-specif concepts
newtype HardCodedInt = HardCodedInt Int

-- and their rules and relationships to other concepts via
--  - functions
--  - type classes

-- since there are no rules/relationships, we won't include anything here...

-----------------------------------------
-- Domain: define business logic and capabilities need to run it:

-- - define our business logic as one pure function (program)
--      that uses type class constraints to define the effects our
--      program requires to be run
program :: forall m.                -- for any monad supporting these capabilities/effects--
           LogToScreen m =&gt;         --   one of which is logging a message
           GenerateRandomInt m =&gt;   --   one of which is generating a random int
           MonadAsk Environment m =&gt; --   one of which is getting info from a global record/config
                                    --    where that record type is &quot;Environment&quot;
           m Unit                   -- --running this monad will produce no output.
                                    -- However, it will side-effects that make running this code useful
program = do
  -- use capability to generate random int
  randomInt &lt;- generateRandomInt

  -- use Reader effect to get value
  (HardCodedInt hardInt) &lt;- asks \envRecord -&gt; envRecord.hardCodedInt

  -- use &quot;let&quot; syntax to do some intermediary pure computations:
  -- 1. do the comparison and convert the result into something more readable
  let comparisonResult = case compare hardInt randomInt of
          LT -&gt; &quot; &lt; &quot;
          GT -&gt; &quot; &gt; &quot;
          EQ -&gt; &quot; = &quot;

  -- 2. create a message that clearly shows what the output will be
  let message = show hardInt &lt;&gt; comparisonResult &lt;&gt; show randomInt

  -- use capability to log comparison to console
  logToScreen message

-- - define an `Environment` record type alias that includes all things that are
--      available globally at all times. This is only necessary because we're
--      using a ReaderT-like approach.
type Environment = { hardCodedInt :: HardCodedInt }

-- - declare what those capabilities are as type classes.
class (Monad m) &lt;= LogToScreen m where
  logToScreen :: String -&gt; m Unit

class (Monad m) &lt;= GenerateRandomInt m where
  generateRandomInt :: m Int

-----------------------------------------
-- API: define how the pure domain concepts and logic above translate
--        down into pure effects and impure effects via a `ReaderT`-based monad

-- - a newtyped ReaderT monad called &quot;AppM&quot; that hard-codes the Environent
--      type and the base monad (Effect in this case)
newtype AppM a = AppM (ReaderT Environment Effect a)

-- - a 'runAppM' function that unwraps the AppM newtype and runs the program
--      in the `Effect` monad, which is transformed/augmented by the ReaderT function
--      Any values or functions that are needed to provide effects
--      are passed in from the outside (i.e. `envRecord`)
runAppM :: Environment -&gt; AppM ~&gt; Effect
runAppM env (AppM m) = runReaderT m env

-- - a MonadAsk instance that uses TypeEquals to work around a restriction:
--      &quot;cannot use a type alias (i.e. `Environent` type) in type class instance&quot;
instance TypeEquals e Environment =&gt; MonadAsk e AppM where
  ask = AppM $ asks from

-- - write instances for capabilities above, so that AppM can use them
instance LogToScreen AppM where
  logToScreen :: String -&gt; AppM Unit
  logToScreen message = liftEffect $ Console.log message

instance GenerateRandomInt AppM where
  generateRandomInt :: AppM Int
  generateRandomInt = liftEffect $ randomInt bottom top

-- - derive instances for AppM, so that it is a Monad via ReaderT
derive newtype instance Functor AppM
derive newtype instance Applicative AppM
derive newtype instance Apply AppM
derive newtype instance Bind AppM
derive newtype instance Monad AppM
derive newtype instance MonadEffect AppM

-----------------------------------------
-- Infrastructure: any other code (i.e. databases, frameworks, libraries)
--                   that provides effects that do not appear in `Effect.*` modules

-- We aren't using other libraries (Node.ReadLine, Halogen, etc.).
-- Thus, nothing needs to go here for right now

-----------------------------------------
-- Machine Code: set up everything we need and then run the program

main :: Effect Unit
main = do
  -- set up the environment
  let environment = { hardCodedInt: HardCodedInt 4 }

  -- run the program by passing the Environment and the domain logic
  -- into the `runAppM` function
  runAppM environment program
</code></pre>
<h1><a class="header" href="#03-freepurs-1" id="03-freepurs-1">03-Free.purs</a></h1>
<pre><code class="language-haskell">module Examples.NumberComparison.Free where

import Prelude
import Effect (Effect)
import Effect.Console as Console
import Effect.Random (randomInt)
import Control.Monad.Free (Free, liftF, foldFree)
import Data.Functor.Coproduct.Nested (Coproduct3, coproduct3)
import Data.Functor.Coproduct.Inject (inj)

-----------------------------------------
-- Core: Define any domain-specific concepts and their rules/relationships to
--         other domain-specific concepts

-- define any domain-specif concepts
newtype HardCodedInt = HardCodedInt Int

-- and their rules and relationships to other concepts via
--  - functions
--  - type classes

-- since there are no rules/relationships, we won't include anything here...

-----------------------------------------
-- Domain: define business logic and capabilities need to run it:

-- - define our business logic as one pure function (program)
--      that uses data types that have Functor instances
--      to define the effects our program requires to be run
program :: Free                       -- A program that...
            AllEffects                -- ... given an interpreter for each one of its 'effects'...
            Unit                      -- ... will produce no output.
                                      -- However, running it will produce side-effects
                                      -- that make this program useful
program = do
  -- use capability to generate random int
  randomInt &lt;- generateRandomInt

  -- use Reader effect to get value
  (HardCodedInt hardInt) &lt;- asks \envRecord -&gt; envRecord.hardCodedInt

  -- use &quot;let&quot; syntax to do some intermediary pure computations:
  -- 1. do the comparison and convert the result into something more readable
  let comparisonResult = case compare hardInt randomInt of
          LT -&gt; &quot; &lt; &quot;
          GT -&gt; &quot; &gt; &quot;
          EQ -&gt; &quot; = &quot;

  -- 2. create a message that clearly shows what the output will be
  let message = show hardInt &lt;&gt; comparisonResult &lt;&gt; show randomInt

  -- use capability to log comparison to console
  logToScreen message

-- - define a type alias that defines what all our effects/capabilities are
type AllEffects =
  Coproduct3              -- in total, we have 3 effects/capabilities
    LogToScreen           -- one of which enables logging to the screen
    GenerateRandomInt     -- one of which enables generating a random int
    (Reader Environment)  -- one which can get values/functions from the
                          --    global configuration type, Environment

-- - define an `Environment` record type alias that includes all things that are
--      available globally at all times. Note: This is only necessary because we're
--      using a ReaderT-like approach.
type Environment = { hardCodedInt :: HardCodedInt }

-- - declare what the capabilities/effects are as data types with
--     derived instances for `Functor` and write their smart constructors.
data LogToScreen a = LogToScreen String a
derive instance Functor LogToScreen

logToScreen :: String -&gt; Free AllEffects Unit
logToScreen message = liftF $ inj $ LogToScreen message unit
-----
data GenerateRandomInt a = GenerateRandomInt (Int -&gt; a)
derive instance Functor GenerateRandomInt

generateRandomInt :: Free AllEffects Int
generateRandomInt = liftF $ inj $ GenerateRandomInt identity
-----
newtype Reader e a = Reader (e -&gt; a)
derive instance Functor (Reader e)

ask :: Free AllEffects Environment
ask = liftF $ inj $ Reader identity

asks :: forall a. (Environment -&gt; a) -&gt; Free AllEffects a
asks envToValue = liftF $ inj $ Reader envToValue

-----------------------------------------
-- API: define how the pure domain concepts and logic above translate
--        into pure effects and impure effects via
--        &quot;data type interpreters&quot; (i.e. F-Algebras)

-- - an &quot;interpreter&quot; from each data type used above to the base monad, Effect
--    via a Natural Transformation
logToScreenToEffect :: LogToScreen ~&gt; Effect
logToScreenToEffect (LogToScreen msg next) = do
  Console.log msg
  pure next

generateRandomIntToEffect :: GenerateRandomInt ~&gt; Effect
generateRandomIntToEffect (GenerateRandomInt reply) = do
  random &lt;- randomInt bottom top
  pure $ reply random

-- Any values or functions that are needed by Reader are passed in
-- from the outside (i.e. `envRecord`)
readerToEffect :: Environment -&gt; Reader Environment ~&gt; Effect
readerToEffect environment (Reader reply) = do
  pure $ reply environment

-- - an interpreter from the (Free AllEffects) type to the base monad, Effect,
--      using `foldFree` and the above interprters.
--      Any values or functions that are needed by Reader are passed in
--      from the outside (i.e. `envRecord`)
runProgram :: Environment -&gt; Free AllEffects ~&gt; Effect
runProgram envRecord = foldFree go

  where
  -- - route each data type in the containing Coproduct to its correct
  --    interpreter using the convenience function, `coproduct3`
  go :: AllEffects ~&gt; Effect
  go =
    coproduct3
      logToScreenToEffect
      generateRandomIntToEffect
      (readerToEffect envRecord)

-----------------------------------------
-- Infrastructure: any other code (i.e. databases, frameworks, libraries)
--                   that provides effects that do not appear in `Effect.*` modules

-- We aren't using other libraries (Node.ReadLine, Halogen, etc.).
-- Thus, nothing needs to go here for right now


-----------------------------------------
-- Machine Code: set up everything we need and then run the program

main :: Effect Unit
main = do
  -- set up the environment
  let environment = { hardCodedInt: HardCodedInt 4 }

  -- run the program by passing in the environment and the final data type
  -- that includes all the instructions to run via their interpreters.
  runProgram environment program
</code></pre>
<h1><a class="header" href="#04-runpurs-1" id="04-runpurs-1">04-Run.purs</a></h1>
<pre><code class="language-haskell">module Examples.NumberComparison.Run where

import Prelude
import Effect (Effect)
import Effect.Console as Console
import Effect.Random (randomInt)
import Type.Row (type (+))
import Data.Functor.Variant (on)
import Run (Run, lift, interpret, case_)
import Run.Reader (READER, runReader, ask)
import Type.Proxy (Proxy(..))

-----------------------------------------
-- Core: Define any domain-specific concepts and their rules/relationships to
--         other domain-specific concepts

-- define any domain-specif concepts
newtype HardCodedInt = HardCodedInt Int

-- and their rules and relationships to other concepts via
--  - functions
--  - type classes

-- Since there are no rules/relationships, we won't include anything here...

-----------------------------------------
-- Domain: define business logic and capabilities need to run it:

-- - define our business logic as one pure function (program)
--      that uses data types that have Functor instances
--      to define the effects our program requires to be run
program :: forall r.
           Run                     -- A program that, given an interpreter that...
            -- effects go first
            (
            | READER Environment   --    can provide values/functions from the
                                   --       global configuration type, Environment

            -- capabilities go second
            + LOG_TO_SCREEN        --    can enable logging to the screen
            + GENERATE_RANDOM_INT  --    can enable generating a random int
            + r                    --    and any other effects/capabilities
            )                      --       we may add later
            Unit                   -- ... will produce no output.
                                   -- However, running it will produce side-effects
                                   -- that make this program useful
program = do
  -- use capability to generate random int
  randomInt &lt;- generateRandomInt

  -- use Reader effect to get the value
  -- (`purescript-run` does not include 'asks' for its Reader implementation,
  --    so this is the way to do the same thing)
  (HardCodedInt hardInt) &lt;- ask &lt;#&gt; (\envRecord -&gt; envRecord.hardCodedInt)

  -- use &quot;let&quot; syntax to do some intermediary pure computations:
  -- 1. do the comparison and convert the result into something more readable
  let comparisonResult = case compare hardInt randomInt of
          LT -&gt; &quot; &lt; &quot;
          GT -&gt; &quot; &gt; &quot;
          EQ -&gt; &quot; = &quot;

  -- 2. create a message that clearly shows what the output will be
  let message = show hardInt &lt;&gt; comparisonResult &lt;&gt; show randomInt

  -- use capability to log comparison to console
  logToScreen message

-- - define an `Environment` record type alias that includes all things that are
--      available globally at all times. Note: This is only necessary because we're
--      using a ReaderT-like approach.
type Environment = { hardCodedInt :: HardCodedInt }

-- - declare what the capabilities/effects are as data types with
--     derived instances for `Functor`,
--   define their type-level Strings that act as their corresponding label in a row,
--   define a type alias that makes using the data type in rows easier
--   and write their smart constructors.
data LogToScreen a = LogToScreen String a
derive instance Functor LogToScreen

_logToScreen :: Proxy &quot;logToScreen&quot;
_logToScreen = Proxy

type LOG_TO_SCREEN r = (logToScreen :: LogToScreen | r)

logToScreen :: forall r. String -&gt; Run (LOG_TO_SCREEN + r) Unit
logToScreen msg = lift _logToScreen $ LogToScreen msg unit
----
data GenerateRandomInt a = GenerateRandomInt (Int -&gt; a)
derive instance Functor GenerateRandomInt

_generateRandomInt :: Proxy &quot;generateRandomInt&quot;
_generateRandomInt = Proxy

type GENERATE_RANDOM_INT r = (generateRandomInt :: GenerateRandomInt | r)

generateRandomInt :: forall r. Run (GENERATE_RANDOM_INT + r) Int
generateRandomInt = lift _generateRandomInt $ GenerateRandomInt identity
----

-- we do not need to define Reader here since `purescript-run` already does so

-----------------------------------------
-- API: define how the pure domain concepts and logic above translate
--        into pure effects and impure effects via
--        &quot;data type interpreters&quot; (i.e. F-Algebras)

-- - an &quot;interpreter&quot; for each data type used above
logToScreenToEffect :: LogToScreen ~&gt; Effect
logToScreenToEffect (LogToScreen msg next) = do
  Console.log msg
  pure next

generateRandomIntToEffect :: GenerateRandomInt ~&gt; Effect
generateRandomIntToEffect (GenerateRandomInt reply) = do
  random &lt;- randomInt bottom top
  pure $ reply random

-- Reader does not need to be done since `purescript-run` already defines
-- an interpreter via `runReader`

-- - an interpreter from the (Run &lt;AllEffects&gt;) type to the base monad, Effect.
--   Since we are not adding, any new effects/capabilities at this time,
--      we close the row kind using an empty row (i.e. &quot;()&quot;)
--   Since we are using &quot;open&quot; row kinds, we need to use &quot;case_&quot; to insure that
--      all effects/capabilities are interpreted.
--   Any values or functions that are needed by Reader are passed in
--      from the outside (i.e. `envRecord`)
runProgram :: Environment -&gt;
              Run ( 
                  | READER Environment
                  + LOG_TO_SCREEN
                  + GENERATE_RANDOM_INT
                  + () -- closes the &quot;open&quot; row of &quot;program&quot;
                  )
              ~&gt; Effect
runProgram envRecord p =
  p
    -- use &quot;runX&quot; for MTL effects
    # runReader envRecord

    -- use &quot;interpret&quot; and &quot;case_&quot; for capabilities
    # interpret (
        case_
          # on _logToScreen logToScreenToEffect
          # on _generateRandomInt generateRandomIntToEffect
      )

-----------------------------------------
-- Infrastructure: We aren't using other libraries (Node.ReadLine, Halogen, etc.)
-- so nothing needs to go here for right now

-----------------------------------------
-- Machine Code: set up everything we need and then run the program

main :: Effect Unit
main = do
  -- set up the environment
  let environment = { hardCodedInt: HardCodedInt 4 }

  -- run the program by passing in the environment and the final data type
  -- that includes all the instructions to run via their interpreters.
  runProgram environment program
</code></pre>
<h1><a class="header" href="#modern-fp-architecture" id="modern-fp-architecture">Modern FP Architecture</a></h1>
<h2><a class="header" href="#properties-of-effects" id="properties-of-effects">Properties of &quot;Effects&quot;</a></h2>
<p>Now that we have seen the various ways to model &quot;effects,&quot; let's talk about the properties of effects and the tradeoffs one makes when committing to either of these approaches.</p>
<p>Read through the first section of <a href="https://ocharles.org.uk/posts/2016-01-26-transformers-free-monads-mtl-laws.html">Monad transformers, free monads, mtl, laws and a new approach</a>.</p>
<p>We will explain and illustrate what is meant by each property</p>
<h3><a class="header" href="#extensible" id="extensible">Extensible</a></h3>
<p>While the above effects (e.g. <code>MonadState</code>) are pretty obvious, we might one day wish to define a new effect for handling authentication, <code>MonadAuthenticate</code>. If a function that uses state-manipulation effects via <code>MonadState</code> now needs to add the &quot;authenticate&quot; effect, it should be easy to add that and not require us to refactor a whole lot of code.</p>
<p>In other words, going from this function ...</p>
<pre><code class="language-haskell">f :: forall m.
     MonadState m =&gt;
     InitialState -&gt; m OutputtedState
</code></pre>
<p>... to this function...</p>
<pre><code class="language-haskell">f' :: forall m.
      MonadState m =&gt;
      MonadAuthenticate m =&gt;
      InitialState -&gt;
      m OutputtedState
</code></pre>
<p>... should be easy/quick.</p>
<h3><a class="header" href="#composable" id="composable">Composable</a></h3>
<p>Composable means using two or more effects in the same function should be lawful.</p>
<p>For example</p>
<ul>
<li><code>set</code>ting some state to <code>5</code> and later <code>get</code>ting that state should return <code>5</code>, not <code>8</code>, no matter what other effects or computations we run in-between those two calls (e.g. printing some value to the console).</li>
<li><code>catch</code>ing an error cannot occur unless an error was <code>throw</code>n prior to it.</li>
<li><code>ask</code>ing for a configuration value should return the same value each time no matter what happens before/after that call.</li>
</ul>
<h3><a class="header" href="#efficient" id="efficient">Efficient</a></h3>
<p>This can be understood a few different ways:</p>
<ul>
<li>During runtime: the program runs fast (time-efficient) or uses as little memory as possible (space-efficient)</li>
<li>During compile-time: the compiler runs fast (time-efficient) or uses as little memory as possible (space-efficient)</li>
</ul>
<p>I believe the author is referring to the first idea (runtime).</p>
<h3><a class="header" href="#terse" id="terse">Terse</a></h3>
<p>We shouldn't have to write boilerplate-y code</p>
<p>For example, we shouldn't have to write</p>
<ul>
<li>many lines of code to do one thing</li>
<li>many types to do one thing</li>
</ul>
<h3><a class="header" href="#inferrable" id="inferrable">Inferrable</a></h3>
<p>Related to <code>Terse</code>, we shouldn't have to annotate code (e.g. wrapping <code>value</code> with its type annotation: <code>(value :: { name :: String, age :: Int })</code> )</p>
<h2><a class="header" href="#key-articles" id="key-articles">Key Articles</a></h2>
<p>Now might be a good time to re-read these articles:</p>
<ul>
<li><a href="https://ocharles.org.uk/posts/2016-01-26-transformers-free-monads-mtl-laws.html">Monad transformers, free monads, mtl, laws and a new approach</a></li>
<li><a href="https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html">Three Layer Haskell Cake</a></li>
<li><a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">the <code>ReaderT</code> Design Pattern</a></li>
<li><a href="https://www.tweag.io/posts/2018-10-04-capability.html">the Capability Design Pattern</a></li>
<li><a href="http://degoes.net/articles/modern-fp">A Modern Architecture for FP: Part 1</a></li>
<li><a href="http://degoes.net/articles/modern-fp-part-2">A Modern Architecture for FP: Part 2</a></li>
<li><a href="content/21-Hello-World/05-Application-Structure/src/reasonablypolymorphic.com/blog/freer-monads/index.html">Freer Monads, More Better Programs</a></li>
<li><a href="https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501">Freer doesn't come for free</a></li>
</ul>
<h2><a class="header" href="#evaluating-mtl-and-free" id="evaluating-mtl-and-free">Evaluating MTL and Free</a></h2>
<p>Alexis King recently recorded a very clear explanation of some of the tradeoffs of effect systems. While her video is in Haskell, the implications are worth thinking about in PureScript:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=0jI-AlWEwYI">Alexis King - Effects for Less @ ZuriHac 2020</a></li>
</ul>
<p>Let's now use the above post's criteria for each approach. The following is my guess at where things stand^^:</p>
<table><thead><tr><th></th><th>Extensible?</th><th>Composable?</th><th>Efficient?</th><th>Terse?</th><th>Inferrable?</th></tr></thead><tbody>
<tr><td>MTL</td><td>Yes via the Capability Design Pattern</td><td>Yes via newtyped monadic functions?</td><td>?</td><td>~<code>n^2</code> instances for <code>Monad[Word]</code><br>boilerplate capability type classes</td><td>?</td></tr>
<tr><td>Free/Run</td><td>Yes via open rows and <code>VariantF</code></td><td>Yes via embedded domain-specific languages</td><td>?</td><td>boilerplate smart constructors</td><td>?</td></tr>
</tbody></table>
<p>^^ Note: The <code>MTL vs Free</code> debate is pretty heated in FP communities.</p>
<p>In the <code>Hello World/Games</code> folder, we'll implement the same programs for each concept mentioned above as more concrete examples.</p>
<h2><a class="header" href="#reducing-boilerplate-via-atoms-snippets-feature" id="reducing-boilerplate-via-atoms-snippets-feature">Reducing Boilerplate via Atom's Snippets Feature</a></h2>
<p>If you are using Atom as your editor, you can use snippets to help reduce the boilerplate required to write these things.</p>
<ol>
<li>Open the preferences tab (<code>CTRL+,</code>)</li>
<li>Click on the &quot;Open the Config Folder&quot; button</li>
<li>Open the <code>snippets.cson</code> file</li>
<li>Copy and paste the below content into the file</li>
</ol>
<pre><code class="language-cson">'.source.purescript':
  'Run Type':
    'prefix': 'runType'
    'body': &quot;&quot;&quot;
      data ${1:Type_Name} a
        = -- create data constructors via a different snippet

      derive instance Functor ${1:Type_Name}

      _${2:symbol} = Proxy :: Proxy &quot;${2:symbol}&quot;

      type ${3:ALL_CAPS_TYPE_NAME} r = (${2:symbol} :: FProxy $1 | r)
    &quot;&quot;&quot;

  'Run Smart Constructor':
    'prefix': 'runSmartConstructor'
    'body': &quot;&quot;&quot;
      ${1:DataConstructor} ${2:Args}

      ${3:smartConstructorName} :: forall r. ${4:args} Run (${5:Type_Alias} + r) ${6:Return_Type}
      ${3:smartConstructorName} ${7:valueArgs} = lift _${8:symbol} $ ${1:Data_Constructor} ${7:valueArgs} ${9:identityOrUnit}
    &quot;&quot;&quot;

  'ReaderT Design Pattern (AppM)':
    'prefix': 'appM_via_ReaderT'
    'body': &quot;&quot;&quot;
      newtype AppM a = AppM (ReaderT Env Aff a)

      runAppM :: Env -&gt; AppM ~&gt; Aff
      runAppM env (AppM m) = runReaderT m env

      instance TypeEquals e Env =&gt; MonadAsk e AppM where
        ask = AppM $ asks from

      derive newtype instance Functor AppM
      derive newtype instance Apply AppM
      derive newtype instance Applicative AppM
      derive newtype instance Bind AppM
      derive newtype instance Monad AppM
      derive newtype instance MonadEffect AppM
      derive newtype instance MonadAff AppM
      &quot;&quot;&quot;

  'ReaderT Design Pattern (TestM)':
    'prefix': 'testM_via_ReaderT'
    'body': &quot;&quot;&quot;
      newtype TestM a = TestM (ReaderT Env Identity a)

      runTestM :: Env -&gt; TestM a -&gt; a
      runTestM env (TestM program) =
        let (Identity a) = runReaderT program env
        in a

      instance TypeEquals e Env =&gt; MonadAsk e TestM where
        ask = TestM $ asks from

      derive newtype instance Functor TestM
      derive newtype instance Apply TestM
      derive newtype instance Applicative TestM
      derive newtype instance Bind TestM
      derive newtype instance Monad TestM
      &quot;&quot;&quot;
</code></pre>
<h1><a class="header" href="#type-level-programming" id="type-level-programming">Type-Level Programming</a></h1>
<p>This folder assumes you have read through and are familiar with <code>Type Level Syntax</code>. If you aren't, go and read through that first.</p>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<h3><a class="header" href="#a-problem" id="a-problem">A Problem</a></h3>
<p><a href="https://stackoverflow.com/a/24481747">Taken from this SO answer (last paragraph)</a>, type-level programming can be used to:</p>
<blockquote>
<p>restrict certain behavior at the value-level, manage resource finalization, or store more information about data-structures.</p>
</blockquote>
<p>Let's explain a problem that highlights the third point: storing more information about data-structures. Below is one problem that occurs at the runtime that can be fixed with type-level programming.</p>
<p>An <code>Array</code> is a very fast data structure, but it's problematic because we never know its exact size at compile-time. In other words, we don't get a compiler error if we reference an invalid spot in the array, and we won't know about the bug until it occurs when running the program. In short, this kind of function will always be a partial function.</p>
<p>Here's an example in code. If the array is empty or has fewer than <code>n - 1</code> elements, the function can only throw an error when we try to reference a non-existent element at index <code>n</code>. If the array has <code>n - 1</code> or more elements, it can return that element.</p>
<pre><code class="language-haskell">elemAtIndex :: forall a. Partial =&gt; Int -&gt; Array a -&gt; a
elemAtIndex idx [] = Partial.crash &quot;cannot get &quot; &lt;&gt; show idx &lt;&gt; &quot;th element of an empty array&quot;
elemAtIndex index fullArray = unsafePartial $ unsafeIndex fullArray index
</code></pre>
<h3><a class="header" href="#a-solution" id="a-solution">A Solution</a></h3>
<p>What if we could modify the type of <code>Array</code>, so that it included the size of that array at compile-time? Then, the type-checker could ensure that the &quot;elemAtIndex&quot; function described above only receives correct arguments (i.e. specific types) that make the function &quot;total,&quot; meaning the function will always return a valid output and never throw an error. If it receives an invalid argument, it results in a compiler error and we can fix the bug before shipping the code to customers.</p>
<pre><code class="language-haskell">-- This entire block of code is pseduo syntax and does not actually work!
-- Use it only to get the idea and don't hold onto any of the syntax used here.
elemAtIndex :: forall a n. HasElemAtIndex n =&gt; n -&gt; IndexedArray n a
elemAtIndex index array = -- implementation

elemAtIndex 3 (IndexedArray 3 [0, 1, 2, 3]) -- 3
elemAtIndex 3 (IndexedArray 3 [0, 1]) -- compiler error!
elemAtIndex 0 (IndexedArray Empty []) -- compiler error!
</code></pre>
<p>This is exactly what the library <a href="https://pursuit.purescript.org/packages/purescript-sized-vectors/3.1.0/docs/Data.Vec#t:Vec">Vec</a> does.</p>
<h2><a class="header" href="#issues-with-type-level-programming" id="issues-with-type-level-programming">Issues with Type-Level Programming</a></h2>
<ul>
<li>When using type-level programming, the compiler has to do more work. Thus, it will increase the time it takes to compile your program.</li>
<li>Creating a type-level value for a kind can get really tedious and boilerplatey. Either reuse ones that exist in libraries or publish your own library for the benefit of the entire community.</li>
</ul>
<h2><a class="header" href="#other-learning-sources-1" id="other-learning-sources-1">Other Learning Sources</a></h2>
<p>Consider purchasing the <code>Thinking with Types</code> book mentioned in <code>ROOT_FOLDER/Syntax/Type-Level Programming Syntax/ReadMe.md</code></p>
<h2><a class="header" href="#compilation-instructions-4" id="compilation-instructions-4">Compilation Instructions</a></h2>
<pre><code class="language-bash">spago run -m TLP.SymbolExample
spago run -m TLP.RowExample
</code></pre>
<h1><a class="header" href="#understanding-a-type-level-function" id="understanding-a-type-level-function">Understanding a Type-Level Function</a></h1>
<h2><a class="header" href="#tips-on-rows" id="tips-on-rows">Tips on Rows</a></h2>
<p>Rows in particular are where type-level programming gets interesting and fun.</p>
<p>First, there is a long and short way to write <code>Record rowType</code>:</p>
<pre><code class="language-haskell">long :: forall r. Record r

short :: forall r. { | r }
</code></pre>
<p>Since the left part of <code>{ | r}</code> does not contain any rows, this reduces to <code>Record r</code>.</p>
<p>Second, there is syntax sugar via <a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Row#t:RowApply"><code>RowApply</code></a>/<a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Row#t:type%20(+)"><code>+</code></a> for adding additional rows:</p>
<pre><code class="language-haskell">type EmptyRow = ()
type ClosedRow1 = (a :: Int)
type OpenRow1 r = (b :: String | r)
type OpenRow2 r = (OpenRow1 + r)
type ClosedRow2 = (OpenRow2 + ClosedRow1)
type MixedRow r = (a :: Int | OpenRow1 + r)

type Row1 r = (x :: Int | r)
type Row2 r = (y :: Int | r)
type Row3 r = (z :: Int | r)
type SuperMixedOpenRow r = (a :: Int, b :: Int, c :: Int | Row1 + Row2 + Row3 + r)
</code></pre>
<p>Third, we sometimes need to close the &quot;open&quot; row type by using the empty row, <code>()</code>:</p>
<pre><code class="language-haskell">-- Example 1
type Row1 r = (a :: Int | r)
type Row2 r = (b :: Int | r)
type Row3 r = (c :: Int | r)
type Rows1To3__Open r = (Row1 + Row2 + Row3 + r )
type Rows1To3__Closed = (Row1 + Row2 + Row3 + ())

-- Example 2
type OpenRecord r = Record (name :: String, age :: Int | r)

-- If we want to compute something using OpenRecord,
-- we might need to close it by making the `r` an empty row:
finalEval :: OpenRecord () -&gt; Output
</code></pre>
<p>Rows can make our life easier in a number of ways. We'll see some examples before finishing this &quot;Hello World&quot; folder.</p>
<h2><a class="header" href="#reading-a-type-level-function" id="reading-a-type-level-function">Reading a Type-Level Function</a></h2>
<ol>
<li>Ignore the type class constraints and look solely at the function's arguments. Now you know what the starting &quot;inputs&quot; and final &quot;outputs&quot; of the function are.</li>
<li>Ignore the <code>IsKind</code> (e.g. <code>IsSymbol</code>/<code>IsOrdering</code>) type class constraints and look at the type class constraints that actually compute something (e.g. <code>Add</code>, <code>Append</code>, <code>Compare</code>, <code>Cons</code>, etc.) Now you have an understanding of what the type-level function does.</li>
<li>Look at the <code>IsKind</code> constraints and any <code>Proxy</code> types to see how the function type checks.</li>
</ol>
<p>For example, look at <a href="https://pursuit.purescript.org/builtins/docs/Prim.Row">Prim.Row</a> to understand the relationships used below and then use the above guidelines to understand this type-level computation:</p>
<pre><code class="language-haskell">f :: forall row1 row2 row1And2 row1And2PlusAge nubbedRow1And2PlusAge finalRow.
  Union row1 row2 row1And2 =&gt;
  Cons &quot;age&quot; Int row1And2 row1And2PlusAge =&gt;
  Nub row1And2PlusAge nubbedRow1And2PlusAge =&gt;
  Union nubbedRow1And2PlusAge (otherField :: String) finalRow =&gt;

  RProxy row1 -&gt; RProxy row2 -&gt; RProxy finalRow
f _ _ = RProxy
</code></pre>
<p>What is <code>finalRow</code> when <code>row1</code> is <code>(name :: String, age :: Int)</code> and <code>row2</code> is <code>(pets :: Array Pet)</code>?</p>
<h2><a class="header" href="#writing-a-type-level-function" id="writing-a-type-level-function">Writing a Type-Level Function</a></h2>
<p>There are generally five stages when writing a type-level expression:</p>
<ol>
<li>Write the needed type-level function's type signature without any proxies, type class constraints, forall syntax, etc.</li>
<li>Add constraints to &quot;compute&quot; specific values in the type-level expression</li>
<li>Wrap the types in their <code>Proxy</code> types where needed</li>
<li>Add the <code>forall</code> syntax</li>
<li>Write the value-level code that makes it work/compile
<ul>
<li>add <code>IsKind</code> constraints when needed</li>
<li>use <code>unsafeCoerce</code> when needed (explained more in next section)</li>
</ul>
</li>
</ol>
<p>For example, let's say we were trying to write a simple expression using <code>Symbol</code>. Our goal is to append two symbols together. The following code block demonstrates the process one might go through in writing the function:</p>
<pre><code class="language-haskell">-- we want to append two symbols together into one
-- It's the type-level expression of: &quot;some string&quot; &lt;&gt; &quot;another string&quot;

-- given this type-level relationship:
class Append (left :: Symbol) (right :: Symbol) (appended :: Symbol)
  | left  right    -&gt; appended
  , right appended -&gt; left
  , left  appended -&gt; right

-- 1. Write the function's type signature
combineSymbol :: left -&gt; right -&gt; combination
combineSymbol l r = -- TODO

-- 2. Add the type class constraints to compute type-level values
combineSymbol :: Append left right combination
              =&gt; left -&gt; right -&gt; combination
combineSymbol l r = -- TODO

-- 3. Add in the `Proxy` types
combineSymbol :: Append left right combination
              =&gt; Proxy left -&gt; Proxy right -&gt; Proxy combination
combineSymbol l r = -- TODO

-- 4. Add the `forall` syntax
combineSymbol :: forall left right combination
               . Append left right combination
              =&gt; Proxy left -&gt; Proxy right -&gt; Proxy combination
combineSymbol l r = -- TODO

-- 5. Implement the value-level code
combineSymbol :: forall left right combination
               . Append left right combination
              =&gt; Proxy left -&gt; Proxy right -&gt; Proxy combination
combineSymbol _ _ = Proxy
</code></pre>
<h3><a class="header" href="#unsafecoerce" id="unsafecoerce">UnsafeCoerce</a></h3>
<p>In a Javascript backend, <a href="https://pursuit.purescript.org/packages/purescript-unsafe-coerce/3.0.0/docs/Unsafe.Coerce#v:unsafeCoerce">unsafeCoerce</a> is just the <a href="https://github.com/purescript/purescript-unsafe-coerce/blob/v4.0.0/src/Unsafe/Coerce.js">identity function</a>. This is sometimes the only way to get type-level expressions to compile/work in certain cases; however, things can also go wrong if one uses this incorrectly, so any code should be proven to work via tests.</p>
<p>For example, the library, <code>purescript-variant</code>, uses <code>unsafeCoerce</code> to coerce a runtime representation type to a more user-friendly compile-time type as seen here:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-variant/5.0.0/docs/Data.Variant.Internal#t:VariantRep">VariantRep</a></li>
<li><a href="https://github.com/natefaubion/purescript-variant/blob/v5.0.0/src/Data/Variant.purs#L34-L67">Variant and two functions</a></li>
<li>the <a href="https://github.com/natefaubion/purescript-variant/blob/v5.0.0/src/Data/Variant.purs#L69-L90">on function</a></li>
</ul>
<h1><a class="header" href="#02-symbol-examplepurs" id="02-symbol-examplepurs">02-Symbol-Example.purs</a></h1>
<pre><code class="language-haskell">module TLP.SymbolExample where

import Prelude
import Data.Tuple(Tuple(..))
import Data.Symbol (class IsSymbol, reflectSymbol)
import Effect (Effect)
import Effect.Console (log)
import Prim.Symbol as Symbol
import Type.Proxy (Proxy(..))
import Type.Data.Ordering (class IsOrdering, reflectOrdering)

main :: Effect Unit
main = do
  printAppend
  printCons
  printCompare

--- Append ---

apple :: Proxy &quot;apple&quot;
apple = Proxy

app :: Proxy &quot;app&quot;
app = Proxy

le :: Proxy &quot;le&quot;
le = Proxy

combine :: forall l r both
         . Symbol.Append l r both
        =&gt; Proxy l -&gt; Proxy r -&gt; Proxy both
combine _ _ = Proxy

prefix :: forall prefix suffix string
        . Symbol.Append prefix suffix string
       =&gt; Proxy string -&gt; Proxy suffix -&gt; Proxy prefix
prefix _ _ = Proxy

suffix :: forall prefix suffix string
        . Symbol.Append prefix suffix string
       =&gt; Proxy string -&gt; Proxy prefix -&gt; Proxy suffix
suffix _ _ = Proxy

printAppend :: Effect Unit
printAppend = do
    printHeader &quot;Append&quot;
    printSymbol &quot;combine: &quot; $ combine apple apple
    printSymbol &quot;suffix:  &quot; $ suffix apple app
    printSymbol &quot;prefix:  &quot; $ prefix apple le

--- Cons ---

symbolHead :: forall head tail string
            . Symbol.Cons head tail string
           =&gt; Proxy string -&gt; Proxy head
symbolHead _ = Proxy

symbolTail :: forall head tail string
            . Symbol.Cons head tail string
           =&gt; Proxy string -&gt; Proxy tail
symbolTail _ = Proxy

symbolHeadTail :: forall head tail string
                . Symbol.Cons head tail string
               =&gt; Proxy string -&gt; Tuple (Proxy head) (Proxy tail)
symbolHeadTail _ = Tuple Proxy Proxy

appleHead :: Proxy &quot;a&quot;
appleHead = Proxy

appleTail :: Proxy &quot;pple&quot;
appleTail = Proxy

showHeadTail :: forall head tail
              . IsSymbol head
             =&gt; IsSymbol tail
             =&gt; Tuple (Proxy head) (Proxy tail) -&gt; String
showHeadTail (Tuple h t) =
  &quot;(&quot; &lt;&gt; reflectSymbol h &lt;&gt; &quot;, &quot; &lt;&gt; reflectSymbol t &lt;&gt; &quot;)&quot;

symbolCons :: forall head tail string
            . Symbol.Cons head tail string
           =&gt; Proxy head -&gt; Proxy tail -&gt; Proxy string
symbolCons _ _ = Proxy

printCons :: Effect Unit
printCons = do
  printHeader &quot;Cons&quot;
  printSymbol &quot;head: &quot; $ symbolHead apple
  printSymbol &quot;tail: &quot; $ symbolTail apple
  printSymbol &quot;cons: &quot; $ symbolCons appleHead appleTail
  log $ &quot;head tail: &quot; &lt;&gt; (showHeadTail $ symbolHeadTail apple)

--- Compare ---

banana :: Proxy &quot;banana&quot;
banana = Proxy

symbolCompare :: forall left right ordering
               . Symbol.Compare left right ordering
              =&gt; Proxy left -&gt; Proxy right -&gt; Proxy ordering
symbolCompare _ _ = Proxy

printCompare :: Effect Unit
printCompare = do
  printHeader &quot;Compare&quot;
  printOrdering &quot;EQ: &quot; $ symbolCompare apple apple
  printOrdering &quot;LT: &quot; $ symbolCompare apple banana
  printOrdering &quot;GT: &quot; $ symbolCompare banana apple

-------------

printHeader :: String -&gt; Effect Unit
printHeader s = log $ &quot;=== &quot; &lt;&gt; s &lt;&gt; &quot; ===&quot;

printOrdering :: forall a. IsOrdering a =&gt; String -&gt; Proxy a -&gt; Effect Unit
printOrdering subhead ord = printLine subhead $ show $ reflectOrdering ord

printSymbol :: forall a. IsSymbol a =&gt; String -&gt; Proxy a -&gt; Effect Unit
printSymbol subhead sym = printLine subhead $ reflectSymbol sym

printLine :: String -&gt; String -&gt; Effect Unit
printLine s computation = log $ s &lt;&gt; computation
</code></pre>
<h1><a class="header" href="#03-row-examplepurs" id="03-row-examplepurs">03-Row-Example.purs</a></h1>
<pre><code class="language-haskell">module TLP.RowExample where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Prim.Row (class Union, class Nub, class Cons)
import Type.Proxy (Proxy(..))

{-
`f` does the following type-level computation:
    - combine two rows using union
    - add another field using cons (age :: Int)
    - remove a duplicate field using Nub
    - union the result with something else                                    -}
f :: forall row1 row2 row1And2 row1And2PlusAge nubbedRow1And2PlusAge finalRow.
  Union row1 row2 row1And2 =&gt;
  Cons &quot;age&quot; Int row1And2 row1And2PlusAge =&gt;
  Nub row1And2PlusAge nubbedRow1And2PlusAge =&gt;
  Union nubbedRow1And2PlusAge (otherField :: String) finalRow =&gt;

  Proxy row1 -&gt; Proxy row2 -&gt; Proxy finalRow
f _ _ = Proxy

first :: Proxy (name :: String, age :: Int)
first = Proxy

second :: Proxy (pets :: Array Pet)
second = Proxy

-- A function that can change what the outputted Record type must be
-- based on the row type it receives.
g :: forall finalRow a. Proxy finalRow -&gt; a -&gt; (a -&gt; Record finalRow) -&gt; Record finalRow
g _ a function = function a

-- Same thing as `g` but uses shorter type names and the shorter Record syntax
z :: forall r        a. Proxy r        -&gt; a -&gt; (a -&gt; { | r }        ) -&gt; { | r }
z _ a function = function a

main :: Effect Unit
main = do
  -- These examples show that the type of the returned record differs
  -- depending on what the two rows we pass to `f` are
  log $ show $ g (f first second) 5
    (\five -&gt; { age: five, name: &quot;John&quot;, pets: [Pet], otherField: &quot;other&quot;})

  log $ show $ g (f first (Proxy :: Proxy (singlePet :: Pet))) 5
    (\five -&gt; { age: five, name: &quot;John&quot;, singlePet: Pet, otherField: &quot;other&quot;})

  -- These examples show that the output is the same regardless of
  -- whether we use the short/long Record syntax
  -- in our function's type signature.
  log $ show $ g (Proxy :: Proxy (name :: String)) 5 (\five -&gt; { name: &quot;a&quot;})
  log $ show $ z (Proxy :: Proxy (name :: String)) 5 (\five -&gt; { name: &quot;a&quot;})

-- needed to compile

data Pet = Pet
instance Show Pet where
  show _ = &quot;Pet&quot;
</code></pre>
<h1><a class="header" href="#type-level-primitives" id="type-level-primitives">Type-Level Primitives</a></h1>
<p>In addition to Custom Type Errors, the Prim module has sub modules that are not imported by default. Within these modules, Prim defines a few more things for type-level programming. These type classes' instances are <a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#compiler-solvable-type-classes">derived by the compiler</a></p>
<h2><a class="header" href="#types-of-relationships" id="types-of-relationships">Types of Relationships</a></h2>
<p>As explained in the Syntax folder, we use logic programming and unification to compute type-level expressions. To define type-level functions, we define a relationship and the various ways (functional dependencies) that the types can unify. However, there are actually two types of relationships in type-level programming:</p>
<ol>
<li>A relationship that can define multiple type-level functions.</li>
<li>A relationship that can assert that something is true.</li>
</ol>
<p>The first one is easy to understand and is used frequently. However, we have never mentioned assertion relationships. For some examples, see these type classes:</p>
<ul>
<li><a href="https://pursuit.purescript.org/builtins/docs/Prim.Row#t:Lacks">Lacks</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Row.Homogeneous#t:Homogeneous">Homogenous</a></li>
</ul>
<p>In my current understanding, I'd guess that these likely do not appear that often in type-level code, but they may be critical for some use cases.</p>
<h2><a class="header" href="#type-level-types-values-and-proxies" id="type-level-types-values-and-proxies">Type-Level Types, Values, and Proxies</a></h2>
<p>In the below table, <strong>&quot;ValueTypeN&quot; was abbreviated to VTN</strong></p>
<table><thead><tr><th>Value-Level Type</th><th>Value-Level Value(s)</th><th>Kind Name<br>(Corresponding TypeLevel Type)</th><th>Kind Values</th><th>Proxy</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.Ordering">Ordering</a></td><td><code>LT</code> <code>GT</code> <code>EQ</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.Ordering">Ordering</a></td><td><code>LT</code> <code>GT</code> <code>EQ</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Data.Ordering">OProxy</a></td></tr>
<tr><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#t:String">String</a></td><td><code>&quot;literal string&quot;</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#k:Symbol">Symbol</a></td><td><code>&quot;literal symbol&quot;</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.Symbol#t:Proxy">Proxy</a></td></tr>
<tr><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#t:Record">Record</a><br>(closest idea)</td><td><code>Record (keyN :: VTN, ...)</code></td><td><a href="https://github.com/purescript/documentation/blob/master/language/Types.md#rows">row kinds</a></td><td><code>(keyN :: Kind, ...)</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Type.Data.Row#t:RProxy">RProxy</a></td></tr>
<tr><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#t:Boolean">Boolean</a></td><td><code>true</code>/<code>false</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.Boolean">Boolean</a></td><td><code>True</code>/<code>False</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/4.0.0/docs/Type.Data.Boolean#t:BProxy">BProxy</a></td></tr>
<tr><td>List ( keyN :: VTN, ... )<br>(analogy; not real type)</td><td><code>Nil</code><br><br><code>Cons a (ListR a)</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.RowList#k:RowList">RowList</a></td><td><code>Nil</code><br><br><code>Cons :: Symbol -&gt; Type -&gt; RowList</code></td><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Type.Data.RowList#t:RLProxy">RLProxy</a></td></tr>
</tbody></table>
<h2><a class="header" href="#type-level-modules" id="type-level-modules">Type-Level Modules</a></h2>
<p>Rather than explaining things, read through the source code of these modules and you should be able to get a good intuition for how this stuff works. For additional examples, see the Ecosystem folder and check out some of the data structures (e.g. Array, Matrix) that have been augmented with type-level programming.</p>
<table><thead><tr><th>Kind</th><th>Modules</th></tr></thead><tbody>
<tr><td>Boolean</td><td><a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Data.Boolean">Prim.Boolean</a></td></tr>
<tr><td>Ordering</td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.Ordering">Prim.Ordering</a><br></td></tr>
<tr><td>Symbol</td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.Symbol">Prim.Symbol</a><br> <a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Data.Symbol">Type.Data.Symbol</a></td></tr>
<tr><td>Number</td><td><a href="https://pursuit.purescript.org/packages/purescript-typelevel/4.0.0/docs/Data.Typelevel.Num">Data.Typelevel.Number</a><br><a href="https://github.com/justinwoo/purescript-tanghulu">Tanghulu</a></td></tr>
<tr><td>Row</td><td><a href="content/21-Hello-World/06-Type-Level-Programming/src/">Prim.Row</a><br><a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Row">Type.Row</a><br><a href="https://pursuit.purescript.org/packages/purescript-typelevel-prelude/3.0.0/docs/Type.Row.Homogeneous">Type.Row.Homoegeneous</a><br><a href="https://pursuit.purescript.org/packages/purescript-record/1.0.0">Record</a><br><a href="https://pursuit.purescript.org/packages/purescript-heterogenous/0.1.0">Heterogenous</a>^^</td></tr>
<tr><td>RowList</td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.RowList">Prim.RowList</a></td></tr>
<tr><td>Higher-Order Functions</td><td><a href="https://pursuit.purescript.org/packages/purescript-typelevel-eval/0.2.0">Type.Eval</a></td></tr>
<tr><td>N/A</td><td><a href="https://pursuit.purescript.org/packages/purescript-type-isequal/0.1.0">Type.IsEqual</a><br> <a href="https://pursuit.purescript.org/packages/purescript-proxy/3.0.0/docs/Type.Proxy">Type.Proxy</a><br><a href="https://pursuit.purescript.org/packages/purescript-typelevel/4.0.0/docs/Data.Typelevel.Undefined">Data.Typelevel.Undefined</a></td></tr>
</tbody></table>
<p>^^ <strong>The <code>purescript-heterogenous</code> library is mind-blowing</strong> and is exlained by its author in the following video. This video is potentially difficult-to-understand but will make more sense as one gets used to more FP concepts. <strong>Around 14 minutes in, Nate gets up and moves elsewhere. So, skip to <code>16:37</code> when this occurs to avoid wasting time</strong>:
<a href="https://www.youtube.com/watch?v=oNbkpZZAhgk&amp;index=11&amp;list=WL&amp;t=0s">PS Unscripted - Heterogenous</a></p>
<h1><a class="header" href="#01-simplepurs" id="01-simplepurs">01-Simple.purs</a></h1>
<pre><code class="language-haskell">module TLP.RowList.Simple where

import Prelude

import Data.Array as Array
import Data.List.Types (List(..))
import Prim.RowList as RL
import Data.Symbol (class IsSymbol, reflectSymbol)
import Type.Proxy (Proxy(..))

                                                                              {-
Let's say we want to produce a `Show` instance that
only shows the keys of a record. Since a `Show` instance
already exists for all Records, we'll need to define
a newtype and its `Show` instance to achieve this desired behavior.                  -}

newtype ShowKeysOnly :: Row Type -&gt; Type
newtype ShowKeysOnly r = ShowKeysOnly (Record r)
                                                                              {-
Once implemented, our code should work like this in the REPL:
---
&gt; show $ ShowKeysOnly { a: 4, b: 6, c: &quot;apple&quot;, z: false }
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;z&quot;]
---

How would we implement the `Show` instance for `ShowKeysOnly`?

We implement it by defining another type class called `ShowKeysInRecord`
that computes that information for all records, not just records wrapped
in the `ShowKeysOnly`. Since this type class must work for all records,
it cannot know anything about the record itself. This type class
(and any other like it) will always use `RowList` to accomplish its goal.

`RowList` is almost always used to implement anything that involves type
classes and operating on the keys/values of any record that we know nothing of.
A `RowList` functions like a type-level list but one that is specialized to
work with row kinds.

A `RowList` kind has two type-level values:
- Nil (the base case)
- Cons (the recursive case)

At its most basic idea, it allows you to do a `Data.Foldable.foldl`-like
computation on a record where the &quot;next&quot; element is the next key/field in
that record.

Let's remember what a fold-left looks like by using List.
---
data List a
  = Nil
  | Cons a (List a)
---

Read the below function as
  Given
    1. a function that takes the previous accumulated value and the next
        element in the list and produces the next accumulated value
    2. the initial accumulated value
    3. a list of elements
  Produce the final accumulated value                                           -}
foldLeft
  :: forall element accumulatedValue
   . (accumulatedValue -&gt; element -&gt; accumulatedValue)
  -&gt; accumulatedValue
  -&gt; List element
  -&gt; accumulatedValue
foldLeft _ finalAccumulatedValue Nil =
  -- base case: we're done
  finalAccumulatedValue
foldLeft f initialOrNextAccumulatedValue (Cons nextElement restOfList) =
  -- recursive case: do one step and continue
  let
    nextAccumulatedValue = f initialOrNextAccumulatedValue nextElement
  in foldLeft f nextAccumulatedValue restOfList

{-
The first step we need to do is convert a row kind (i.e. the `r` in `{ | r }`
or `Record r`) into a list-like structure, `RowList`. This is done by using
the type class, `RL.RowToList`, a type-level function.

Once we have a `RowList`, we can simulate a fold-left at the type-level
by defining two instances, one for each value of `RowList`.
1. The first instance corresponds to the `Nil` case above: it ends
    the recursiong and returns the final version of the accumulated value.
    Most of the time, this instance is very very boring.
2. The second instance corresponds to the `Cons` case above: it computes
    the next computation and adds it to the accumulated value and then
    continues the recursion. Since this computes something using type-level
    information, there are numerous other type class constraints that
    enable such computations to occur at runtime.

Great. Let's now show an example.

We'll first define the `ShowKeysInRowList` type class. Since type classes
infer what their types are based on runtime values, we need to include a
`Proxy` runtime value in the type signature of `buildKeyList`. Otherwise,
the compiler will hav eno idea which `rowList` we're referring to.           -}
class ShowKeysInRowList :: RL.RowList Type -&gt; Constraint
class ShowKeysInRowList rowList where
  buildKeyList :: Proxy rowList -&gt; List String

-- As I said before, the base case is quite boring. It just ends the recursion.
instance ShowKeysInRowList RL.Nil where
  buildKeyList :: Proxy (RL.Nil) -&gt; List String
  buildKeyList _ = Nil

{-
The recursive case is more interesting. First, write the initial instance
boilerplate:

instance ShowKeysInRowList (RL.Cons sym k rest) where
  buildKeyList :: Proxy (RL.Cons sym k rest) -&gt; List String
  buildKeyList _ =

Second, let's implement this instance. Since the type-level
`RowList` is a `Cons`, our value-level `List` should also be a `Cons`

instance ShowKeysInRowList (RL.Cons sym k rest) where
  buildKeyList :: Proxy (RL.Cons sym k rest) -&gt; List String
  buildKeyList _ = Cons key remainingKeys
    where
    key = ???
    remainingKeys = ???

Third, we'll compute what `key` should be. We know that a `Symbol`,
a type-level `String`, can be converted into a value-level `String`
via `reflectSymbol` as defined by the `IsSymbol` type class. So,
let's add the `IsSymbol` class as a constraint to expose `reflectSymbol`
and then use that function to produce our key:

instance (IsSymbol sym) =&gt; ShowKeysInRowList (RL.Cons sym k rest) where
  buildKeyList _ = Cons key remainingKeys
    where
      key = reflectSymbol (Proxy :: Proxy sym)
      remainingKeys = ???

Fourth, we need to compute what the remaining keys are. Wait, isn't that
what we're already doing? Let's use `buildKeyList` on the rest of the
rows. Since `buildKeyList` is defined by `ShowKeysInRowList`, we need
to add that constraint, so we can use that function:

instance (IsSymbol sym, ShowKeysInRowList rest)
  =&gt; ShowKeysInRowList (RL.Cons sym k rest) where
  buildKeyList _ = Cons key remainingKeys
    where
      key = reflectSymbol (Proxy :: Proxy sym)
      remainingKeys = buildKeyList (Proxy :: Proxy rest)

And that's it! We've now defined our type class instance. You'll notice
that the constraints get a bit long. So, the final version below
will use indentation to make it easier to read (at least in my opinion):      -}

instance (
  IsSymbol sym,
  ShowKeysInRowList rest
  )  =&gt; ShowKeysInRowList (RL.Cons sym k rest) where
  buildKeyList _ = Cons key remainingKeys
    where
      key = reflectSymbol (Proxy :: Proxy sym)
      remainingKeys = buildKeyList (Proxy :: Proxy rest)

-- Let's show all three parts together now for easier readability.
-- We'll add a `2` so that the code still compiles:
class ShowKeysInRowList2 :: RL.RowList Type -&gt; Constraint
class ShowKeysInRowList2 rowList where
  buildKeyList2 :: Proxy rowList -&gt; List String

instance ShowKeysInRowList2 RL.Nil where
  buildKeyList2 :: Proxy (RL.Nil) -&gt; List String
  buildKeyList2 _ = Nil

instance (
  IsSymbol sym,
  ShowKeysInRowList2 rest
  )  =&gt; ShowKeysInRowList2 (RL.Cons sym k rest) where
  buildKeyList2 _ = Cons key remainingKeys
    where
      key = reflectSymbol (Proxy :: Proxy sym)
      remainingKeys = buildKeyList2 (Proxy :: Proxy rest)

{-
To actually implement our `Show` instance, we'll add the constraints
needed to compute these values
-}
instance (
  -- 1. First convert the `recordRows` to a `RowList`
  RL.RowToList recordRows rowList,
  -- 2. Then bring `buildKeyList2` into scope
  ShowKeysInRowList2 rowList
  ) =&gt; Show (ShowKeysOnly recordRows) where
  show (ShowKeysOnly rec) =
    -- 4. And convert the `List` into an `Array` and reuse the
    --    Array's `show` to produce our desired result.
    show $ Array.fromFoldable keyList
    where
    -- 3. Then build the key list
    keyList = buildKeyList2 (Proxy :: Proxy rowList)
                                                                              {-
Below are a few examples to prove that this works.
Run the following to confirm it for yourself:
---
spago repl
example1
example2
---                                                                           -}
example1 :: ShowKeysOnly ( a :: String, b :: Int, c :: Boolean )
example1 = ShowKeysOnly { a: &quot;&quot;, b: 0, c: false }

example2 :: ShowKeysOnly ( rowlists :: String, are :: Int, cool :: Boolean )
example2 = ShowKeysOnly { rowlists: &quot;&quot;, are: 0, cool: false }

{-
Did you notice how the output of `example2` is unexpected?
It prints
  [&quot;are&quot;,&quot;cool&quot;,&quot;rowlists&quot;]
rather than
  [&quot;rowlists&quot;,&quot;are&quot;,&quot;cool&quot;]

It seems like `RowToList` will sort the rows labels before returning them
as a new list.
-}
</code></pre>
<h1><a class="header" href="#02-advancedpurs" id="02-advancedpurs">02-Advanced.purs</a></h1>
<pre><code class="language-haskell">module TLP.RowList.Advanced where

import Prelude

import Prim.Row as Row
import Prim.RowList as RL
import Prim.Symbol (class Append)

                                                                              {-
Now that we understand how `RowList`s work, let's use them to
map row kinds. In other words, given some input rows, produce
some output rows that have been modified slightly.                            -}

-- Given an input row (and the rowlist produced by `RL.RowToList inputrows rowList`)
-- produce an output row where each label has an &quot;x&quot; appended to it.
class MapRowsAppendXToLabel :: RL.RowList Type -&gt; Row Type -&gt; Row Type -&gt; Constraint
class MapRowsAppendXToLabel rowList inputRows outputRows | rowList inputRows -&gt; outputRows

instance MapRowsAppendXToLabel RL.Nil emptyRow emptyRow
instance (
  -- 1. Use Row.Cons to get the rest of the input rows
  Row.Cons sym a remainingInputRows inputRows,
  -- 2. Append an &quot;x&quot; to the original label
  Append sym &quot;x&quot; symWithXAppended,
  -- 3. Use Row.Cons to update the current label for the output rows.
  Row.Cons symWithXAppended a remainingOutputRows outputRows,
  -- 4. Recursively compute the rest of the rows
  MapRowsAppendXToLabel remainingRowList remainingInputRows remainingOutputRows
  ) =&gt; MapRowsAppendXToLabel (RL.Cons sym a remainingRowList) inputRows outputRows

-- | Proves that the 'updated' record is the same as 'original'
-- | record but has an 'x' appended to each label
proof
  :: forall originalRowList original updated
   . RL.RowToList original originalRowList
  =&gt; MapRowsAppendXToLabel originalRowList original updated
  =&gt; { | original }
  -&gt; { | updated }
  -&gt; Unit
proof _ _ = unit
                                                                            {-
Verify the code compiles via the REPL
---
spago repl
proof1
proof2                                                                      -}
---

proof1 :: Unit
proof1 =
  proof
    { a : 4, b : &quot;&quot;, c : false }
    { ax: 4, bx: &quot;&quot;, cx: false }

proof2 :: Unit
proof2 =
  proof
    { rowlist : 4, is : &quot;&quot;, cool : false }
    { rowlistx: 4, isx: &quot;&quot;, coolx: false }

-- This will fail to compile
-- proof3 :: Unit
-- proof3 =
--   proof
--     { rowlist : 4, is : &quot;&quot;, cool : false }
--     { rowlist : 4, is : &quot;&quot;, cool : false }
</code></pre>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<h2><a class="header" href="#test-conventions" id="test-conventions">Test Conventions</a></h2>
<p>Normally, the code you test is found in the <code>src</code> folder and its corresponding test file is in the <code>test</code> folder with the following naming scheme for modules:</p>
<pre><code class="language-haskell">-- in 'src/MyModule.purs' file
module MyModule where
-- imports and source code

-- in 'test/MyModule.purs' file
module Test.MyModule where
-- imports and test code

-- in 'src/MyModule/SubModule.purs' file
module MyModule.SubModule where
-- imports and source code

-- in 'test/MyModule/SubModule.purs' file
module Test.MyModule.SubModule where
-- imports and test code
</code></pre>
<h2><a class="header" href="#breaking-conventions" id="breaking-conventions">Breaking Conventions</a></h2>
<p>This folder will place both source and test code in the <code>test</code> folder to prevent you from going back and forth between the source file and its corresponding test file.</p>
<h2><a class="header" href="#libraries-used" id="libraries-used">Libraries Used</a></h2>
<p>This folder will cover testing using three libraries. Nested bullet points indicate other libraries into which one should investigate:</p>
<ul>
<li><a href="https://github.com/purescript-spec/purescript-spec">Spec</a> - Unit Testing / Test Suites
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-spec-discovery/">spec-discovery</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-spec-reporter-xunit/">spec-reporter-xunit</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-spec-mocha/">spec-mocha</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-spec-quickcheck/">spec-quickcheck</a></li>
</ul>
</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/">Quick Check</a> - Property Testing</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-quickcheck-laws/">Quick Check Laws</a> - Property Testing for the core type classes via type-level programming</li>
</ul>
<h2><a class="header" href="#running-the-tests" id="running-the-tests">Running the Tests</a></h2>
<p>See each folder for instructions</p>
<h1><a class="header" href="#unit-testing-vs-property-testing" id="unit-testing-vs-property-testing">Unit Testing vs Property Testing</a></h1>
<h2><a class="header" href="#what-is-unit-testing" id="what-is-unit-testing">What is Unit Testing</a></h2>
<p>Unit- / behavior- / example-testing verifies that a function (e.g. <code>reverse</code>) that receives a specific value (e.g. <code>&quot;apple&quot;</code>) of some data type (e.g. <code>String</code>) will output a specific value (e.g. <code>&quot;elppa&quot;</code>) of the same/different data type. In code:</p>
<pre><code class="language-haskell">unitTest :: Boolean
unitTest = (reverse &quot;apple&quot;) == &quot;elppa&quot;
</code></pre>
<p>If we want to test <code>reverse</code> for a different value of <code>String</code> (e.g. &quot;pineapple&quot;), we would need to write a second test:</p>
<pre><code class="language-haskell">unitTest2 :: Boolean
unitTest2 = (reverse &quot;pineapple&quot;) == &quot;elppaenip&quot;
</code></pre>
<p>If the function can take <code>n</code> different intputs, we need to write <code>n</code> different unit tests.</p>
<h3><a class="header" href="#a-brief-note-on-golden-testing" id="a-brief-note-on-golden-testing">A Brief Note on Golden Testing</a></h3>
<p>A variant of unit testing is &quot;golden testing,&quot; which basically stores the expected output of a test in a separate file. It comes with the following benefits:</p>
<ul>
<li>Some characters are easier to store in a separate file rather than in source code (e.g. the <code>&quot;</code> character).</li>
<li>Storing the &quot;expected output&quot; in the test's source code can distract from what the test is even testing in cases where that output is very large. Storing it in a separate file makes it easier to focus on what the test is testing.</li>
</ul>
<p>For more details, see these links:</p>
<ul>
<li><a href="https://kseo.github.io/posts/2016-12-15-golden-tests-are-tasty.html">Golden Tests are Tasty</a></li>
<li><a href="https://ro-che.info/articles/2017-12-04-golden-tests">Golden Tests</a></li>
</ul>
<h2><a class="header" href="#why-unit-testing-fails" id="why-unit-testing-fails">Why Unit Testing Fails</a></h2>
<ol>
<li><strong>Bad &quot;time : code-coverage&quot; ratio</strong>
<ul>
<li>To verify that our code works in all possible situations, we must write <code>n</code> unit tests to verify that a function that takes <code>n</code> different inputs will output the correct <code>n</code> outputs, <strong>per function</strong>.</li>
</ul>
</li>
<li><strong>Poor tester creativity</strong>
<ul>
<li>A test-writer may forget to write or not be &quot;creative&quot; enough to realize that he/she should write the one test that exposes a bug in the code.</li>
</ul>
</li>
<li><strong>Poor data generation</strong>
<ul>
<li>Some values are hard to create, such as those that interact with a large and complicated database. If one tries to model that data and the model is off even slightly, the tests aren't verifying anything.</li>
</ul>
</li>
<li><strong>'Large' bug-exposing values don't &quot;shrink&quot; to 'small' values.</strong>
<ul>
<li>Some tests that expose a bug use a &quot;large&quot; and complicated value of some data type. Unfortunately, they don't help us figure out what is the 'smallest' version of some value that reproduces the bug.</li>
<li>For example, if one was testing a function that took numbers that are larger than 1 million, it can be hard to determine what is causing the bug with a number like 8,423,522 whereas a number like 1,000,001 might make it much clearer.</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#what-is-property-testing-and-why-it-succeeds" id="what-is-property-testing-and-why-it-succeeds">What is Property Testing and Why It Succeeds</a></h2>
<p>Property-testing verifies that a function (e.g. <code>reverse</code>) that receives <strong>any</strong> value of some data type (e.g. <code>String</code>) will output an expected value of the same/different data type; the expected value is calculated using the given input.</p>
<p>One might immediately think of this code before realizing that it doesn't work:</p>
<pre><code class="language-haskell">propertyTestFail :: String -&gt; Boolean
propertyTestFail input = (reverse input) == -- ???
</code></pre>
<p>What should the expected output be? One way to resolve this is to call reverse twice on the input and see if it matches the original input. In code:</p>
<pre><code class="language-haskell">propertyTest :: String -&gt; Boolean
propertyTest input = (reverse (reverse input)) == input
</code></pre>
<p>In a few lines, we have made it possible to test every possible value of <code>String</code> on the function <code>reverse</code>. We spent only a few seconds and got 100% coverage (solving the above Problem 1). Moreover, the test doesn't require any creativity on our part. Whether the <code>String</code> value uses alphabetical characters, or numbers, or special symbols, or even characters from Asian languages, the test covers all of them (solving the above Problem 2)</p>
<p>The only problem left remaining is the data generation. While we may have a function that can test reverse, its useless unless we can generate random <code>String</code> values. Fortunately, a good property-testing library (like QuickCheck) provides the necessary API to generate such data according to one's needs (solving the above Problem 3).</p>
<p>Lastly, Problem 4 is solved with a feature called &quot;shrinking.&quot; While a unit test cannot shrink <code>8,423,522</code> to <code>1,000,001</code>, a property test can. This feature exists in the originaly Haskell library, but unfortunately, it does not yet seem to exist in Purescript's port of the library.</p>
<h2><a class="header" href="#the-trustworthiness-of-property-testing" id="the-trustworthiness-of-property-testing">The Trustworthiness of Property Testing</a></h2>
<p>In some cases, such as <code>Boolean</code>, one has a finite number of input values to verify:</p>
<pre><code class="language-haskell">testBooleanWithAnd :: Boolean -&gt; Boolean
testBooleanWithAnd randomBoolean = (randomBoolean &amp;&amp; true) == randomBoolean
</code></pre>
<p>After proving that the above property is true for both the <code>true</code> and <code>false</code> values of <code>Boolean</code>, one does not need to retest it again with either values. In such a case, the test can be proven exhaustively and one's certainty in the code is 100%.</p>
<p>On another hand, to successfully prove that <code>reverse</code> works as expected, one would need to test an infinite number of <code>String</code> values. Since we don't have enough time for that, we usually stop testing it after 100 tests pass successfully. 100 tests does not guarantee that our function is correct as there could still be a case where it fails. However, it makes us highly confident in it. The option to increase the number of tests is always present if that's not enough for you.</p>
<h2><a class="header" href="#shrinking-integrated-vs-type-directed" id="shrinking-integrated-vs-type-directed">Shrinking: Integrated vs Type-Directed</a></h2>
<p>To see the difference between QuickCheck (which uses type-directed shrinking) and Hedgehog (which uses integrated shrinking), watch <a href="https://www.youtube.com/watch?v=AIv_9T0xKEo">Gens N' Roses: Appetite for Reduction</a>. Then, read <a href="http://www.well-typed.com/blog/2019/05/integrated-shrinking/">Integrated Shrinking</a></p>
<h2><a class="header" href="#property-testing-case-studies" id="property-testing-case-studies">Property Testing: Case Studies</a></h2>
<p>Successful cases where property-based testing found difficult-to-find bugs:</p>
<ul>
<li>(book as a collection of blog posts) <a href="https://leanpub.com/property-based-testing-in-a-screencast-editor">Komposition, a screencast editor</a></li>
<li>Property testing with side effects: <a href="https://www.parsonsmatt.org/2020/03/11/effectful_property_testing.html">Effectful Propery Testing</a></li>
</ul>
<h2><a class="header" href="#the-limits-of-property-testing" id="the-limits-of-property-testing">The Limits of Property Testing</a></h2>
<p>Usually, people who have never heard of property testing will think it is a &quot;silver bullet&quot; when it comes to writing tests. However, property testing can only cover a select number of tests cases before one must resort to unit testing. Rather than explaining it here, <a href="https://fsharpforfunandprofit.com/posts/property-based-testing-2/">here are 7 patterns where property-based testing works</a>. If a test falls outside of that pattern, one will likely need to use unit testing instead.</p>
<p>Still, before deciding that one must use unit tests, consider using state machine testing:</p>
<ul>
<li><a href="http://qfpl.io/posts/intro-to-state-machine-testing-1/">Intro to state machine testing</a></li>
<li>(haskell library) <a href="http://www.well-typed.com/blog/2019/01/qsm-in-depth/">An in-depth look at quickcheck-state-machine</a></li>
</ul>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>As much as possible, use Property Testing. When that does not suffice, consider state-machine testing. Otherwise, use unit testing.</p>
<h1><a class="header" href="#unit-1" id="unit-1">Unit</a></h1>
<p>There are two libraries for Unit Testing in Purescript:</p>
<ul>
<li><a href="https://github.com/purescript-spec/purescript-spec">Spec</a> (Aff-based testing)</li>
<li><a href="https://github.com/bodil/purescript-test-unit">test-unit</a> (Aff-based testing)</li>
</ul>
<p>I'm not sure which one is better than the other in some situation. However, I knew about Spec first, so that's what we'll be documenting.</p>
<h2><a class="header" href="#spec" id="spec">Spec</a></h2>
<p>Spec is useful for unit testing. The author already has a very clear guide in how to use it. Unfortunately, the links don't point to the correct version of the documentation. So, read through these links and then look at this code for examples:</p>
<ul>
<li><a href="https://github.com/purescript-spec/purescript-spec/blob/master/docs/writing-specs.md">Writing Specs</a></li>
<li><a href="https://github.com/purescript-spec/purescript-spec/blob/master/docs/running.md">Running Specs</a></li>
</ul>
<p>The Examples folder has two kinds of tests:</p>
<ul>
<li>Self-Contained - shows most of the functions in a single file. It shows what the different reporters output when a test gets run.</li>
<li>Modulated - shows how one might create a single library-wide spec by combining other specs. See the <code>Runner</code> file for the main entry point.</li>
</ul>
<h2><a class="header" href="#test-instructions" id="test-instructions">Test Instructions</a></h2>
<p>To run the tests in this folder, use the following commands:</p>
<pre><code class="language-bash"># Assuming you are in the top-level &quot;Testing&quot; folder

# To run each self-contained file...
spago test --main Test.Spec.Examples.SelfContained.ConsoleReporter
spago test --main Test.Spec.Examples.SelfContained.DotReporter
spago test --main Test.Spec.Examples.SelfContained.SpecReporter
spago test --main Test.Spec.Examples.SelfContained.TapReporter

# To run the Modulated runner file
spago test --main Test.Spec.Examples.Modulated.Runner

# To run the focused spec example
spago test --main Test.Spec.Examples.FocusedSpec
</code></pre>
<h1><a class="header" href="#01-console-reporterpurs" id="01-console-reporterpurs">01-Console-Reporter.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.SelfContained.ConsoleReporter where

import Prelude
import Effect (Effect)
import Effect.Aff (launchAff_)
import Test.Spec (pending, pending', describe, it)
import Test.Spec.Assertions (shouldEqual)
import Test.Spec.Reporter.Console (consoleReporter)
import Test.Spec.Runner (runSpec)

main :: Effect Unit
main = launchAff_ $ runSpec [consoleReporter] do
  describe &quot;Describe: Outer Group&quot; do
    describe &quot;Describe: Inner Group&quot; do
      it &quot;It: Test 1 - Successful&quot; do
        (1 + 1) `shouldEqual` 2
      it &quot;It: Test 2 - Failure&quot; do
        (1 + 1) `shouldEqual` 0
    it &quot;It: Test 1&quot; do
      pure unit
    pending &quot;Pending Test: need to write it; will write it later&quot;
      -- cannot have a body!
    pending' &quot;Pending Test: started writing it; will finish it later.&quot; do
      -- can have a body but it is ignored
      (1 + 1) `shouldEqual` 4 -- this will fail if it runs
</code></pre>
<h1><a class="header" href="#02-dot-reporterpurs" id="02-dot-reporterpurs">02-Dot-Reporter.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.SelfContained.DotReporter where

import Prelude
import Effect (Effect)
import Effect.Aff (launchAff_)
import Test.Spec (pending, pending', describe, it)
import Test.Spec.Assertions (shouldEqual)
import Test.Spec.Reporter.Dot (dotReporter)
import Test.Spec.Runner (runSpec)

main :: Effect Unit
main = launchAff_ $ runSpec [ dotReporter { width: 2 } ] do
  describe &quot;Describe: Outer Group&quot; do
    describe &quot;Describe: Inner Group&quot; do
      it &quot;It: Test 1 - Successful&quot; do
        (1 + 1) `shouldEqual` 2
      it &quot;It: Test 2 - Failure&quot; do
        (1 + 1) `shouldEqual` 0
    it &quot;It: Test 1&quot; do
      pure unit
    pending &quot;Pending Test: need to write it; will write it later&quot;
      -- cannot have a body!
    pending' &quot;Pending Test: started writing it; will finish it later.&quot; do
      -- can have a body but it is ignored
      (1 + 1) `shouldEqual` 4 -- this will fail if it runs
</code></pre>
<h1><a class="header" href="#03-spec-reporterpurs" id="03-spec-reporterpurs">03-Spec-Reporter.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.SelfContained.SpecReporter where

import Prelude
import Effect (Effect)
import Effect.Aff (launchAff_)
import Test.Spec (pending, pending', describe, it)
import Test.Spec.Assertions (shouldEqual)
import Test.Spec.Reporter.Spec (specReporter)
import Test.Spec.Runner (runSpec)

main :: Effect Unit
main = launchAff_ $ runSpec [specReporter] do
  describe &quot;Describe: Outer Group&quot; do
    describe &quot;Describe: Inner Group&quot; do
      it &quot;It: Test 1 - Successful&quot; do
        (1 + 1) `shouldEqual` 2
      it &quot;It: Test 2 - Failure&quot; do
        (1 + 1) `shouldEqual` 0
    it &quot;It: Test 1&quot; do
      pure unit
    pending &quot;Pending Test: need to write it; will write it later&quot;
      -- cannot have a body!
    pending' &quot;Pending Test: started writing it; will finish it later.&quot; do
      -- can have a body but it is ignored
      (1 + 1) `shouldEqual` 4 -- this will fail if it runs
</code></pre>
<h1><a class="header" href="#04-tap-reporterpurs" id="04-tap-reporterpurs">04-Tap-Reporter.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.SelfContained.TapReporter where

import Prelude
import Effect (Effect)
import Effect.Aff (launchAff_)
import Test.Spec (pending, pending', describe, it)
import Test.Spec.Assertions (shouldEqual)
import Test.Spec.Reporter.Tap (tapReporter)
import Test.Spec.Runner (runSpec)

main :: Effect Unit
main = launchAff_ $ runSpec [tapReporter] do
  describe &quot;Describe: Outer Group&quot; do
    describe &quot;Describe: Inner Group&quot; do
      it &quot;It: Test 1 - Successful&quot; do
        (1 + 1) `shouldEqual` 2
      it &quot;It: Test 2 - Failure&quot; do
        (1 + 1) `shouldEqual` 0
    it &quot;It: Test 1&quot; do
      pure unit
    pending &quot;Pending Test: need to write it; will write it later&quot;
      -- cannot have a body!
    pending' &quot;Pending Test: started writing it; will finish it later.&quot; do
      -- can have a body but it is ignored
      (1 + 1) `shouldEqual` 4 -- this will fail if it runs
</code></pre>
<h1><a class="header" href="#runnerpurs" id="runnerpurs">Runner.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.Modulated.Runner where

import Prelude
import Effect (Effect)
import Effect.Aff (launchAff_)
-- import Test.Spec (pending, pending', describe, it)
-- import Test.Spec.Assertions (shouldEqual)
import Test.Spec.Reporter.Console (consoleReporter)
-- import Test.Spec.Reporter.Dot (dotReporter)
-- import Test.Spec.Reporter.Spec (specReporter)
-- import Test.Spec.Reporter.Tap (tapReporter)
import Test.Spec.Runner (runSpec)
import Test.Spec.Examples.Modulated.Spec1 as Spec1
import Test.Spec.Examples.Modulated.Spec2 as Spec2
import Test.Spec.Examples.Modulated.Spec3 as Spec3

main :: Effect Unit
main = launchAff_ $ runSpec [consoleReporter] do
  Spec1.spec
  Spec2.spec
  Spec3.spec
</code></pre>
<h1><a class="header" href="#spec1purs" id="spec1purs">Spec1.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.Modulated.Spec1 (spec) where

import Prelude
import Test.Spec (Spec, describe, it)

spec :: Spec Unit
spec =
  describe &quot;Spec1 spec&quot; do
    it &quot;First test&quot; $ pure unit
    it &quot;Second test&quot; $ pure unit
    it &quot;Third test&quot; $ pure unit
    describe &quot;First group&quot; do
      it &quot;First test&quot; $ pure unit
      it &quot;Second test&quot; $ pure unit
      it &quot;Third test&quot; $ pure unit
    describe &quot;Second group&quot; do
      it &quot;First test&quot; $ pure unit
      it &quot;Second test&quot; $ pure unit
      it &quot;Third test&quot; $ pure unit
</code></pre>
<h1><a class="header" href="#spec2purs" id="spec2purs">Spec2.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.Modulated.Spec2 (spec) where

import Prelude
import Test.Spec (Spec, describe, it)

spec :: Spec Unit
spec =
  describe &quot;Spec2 spec&quot; do
    it &quot;First test&quot; $ pure unit
    it &quot;Second test&quot; $ pure unit
    it &quot;Third test&quot; $ pure unit
    describe &quot;First group&quot; do
      it &quot;First test&quot; $ pure unit
      it &quot;Second test&quot; $ pure unit
      it &quot;Third test&quot; $ pure unit
    describe &quot;Second group&quot; do
      it &quot;First test&quot; $ pure unit
      it &quot;Second test&quot; $ pure unit
      it &quot;Third test&quot; $ pure unit
</code></pre>
<h1><a class="header" href="#spec3purs" id="spec3purs">Spec3.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.Modulated.Spec3 (spec) where

import Prelude
import Test.Spec (Spec, describe, it)

spec :: Spec Unit
spec =
  describe &quot;Spec3 spec&quot; do
    it &quot;First test&quot; $ pure unit
    it &quot;Second test&quot; $ pure unit
    it &quot;Third test&quot; $ pure unit
    describe &quot;First group&quot; do
      it &quot;First test&quot; $ pure unit
      it &quot;Second test&quot; $ pure unit
      it &quot;Third test&quot; $ pure unit
    describe &quot;Second group&quot; do
      it &quot;First test&quot; $ pure unit
      it &quot;Second test&quot; $ pure unit
      it &quot;Third test&quot; $ pure unit
</code></pre>
<h1><a class="header" href="#focusedspecpurs" id="focusedspecpurs">FocusedSpec.purs</a></h1>
<pre><code class="language-haskell">module Test.Spec.Examples.FocusedSpec where

import Prelude
import Effect (Effect)
import Effect.Aff (launchAff_)
-- import Test.Spec (pending, pending', describe, it)
-- import Test.Spec.Assertions (shouldEqual)
import Test.Spec.Reporter.Console (consoleReporter)
-- import Test.Spec.Reporter.Dot (dotReporter)
-- import Test.Spec.Reporter.Spec (specReporter)
-- import Test.Spec.Reporter.Tap (tapReporter)
import Test.Spec.Runner (runSpec)
import Test.Spec (describe, it, focus)

main :: Effect Unit
main = launchAff_ $ runSpec [consoleReporter] do
  describe &quot;This group doesn't get run because the other group is 'focused'&quot; do
    it &quot;First unfocused test&quot; $ pure unit
    it &quot;Second unfocused test&quot; $ pure unit
    it &quot;Third unfocused test&quot; $ pure unit
  focus $ describe &quot;This group does get run because it's 'focused'&quot; do
    it &quot;First focused test&quot; $ pure unit
    it &quot;Second focused test&quot; $ pure unit
    it &quot;Third focused test&quot; $ pure unit
</code></pre>
<h1><a class="header" href="#quick-check-and-laws" id="quick-check-and-laws">Quick Check and Laws</a></h1>
<p>This folder will cover</p>
<ul>
<li>QuickCheck test syntax</li>
<li>How to generate random data via combinators and <code>Arbitrary</code></li>
<li>How to use <code>quickcheck-laws</code> to quickly check your implementation of core type classes.</li>
</ul>
<p>For a longer explanation of the original Haskell QuickCheck:</p>
<ul>
<li><a href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">A recent &quot;unofficial&quot; tutorial</a></li>
<li><a href="http://www.cse.chalmers.se/%7Erjmh/QuickCheck/manual.html">The outdated manual</a></li>
</ul>
<h2><a class="header" href="#compilation-instructions-5" id="compilation-instructions-5">Compilation Instructions</a></h2>
<p>Use these commands to compare the test results:</p>
<pre><code class="language-bash"># Unit Tests
spago test -m Test.Spec.Examples.SelfContained.ConsoleReporter
spago test -m Test.Spec.Examples.SelfContained.DotReporter
spago test -m Test.Spec.Examples.SelfContained.SpecReporter
spago test -m Test.Spec.Examples.SelfContained.TapReporter

spago test -m Test.Spec.Examples.Modulated.Runner

# Quick Check
spago test -m Test.QuickCheckSyntax
</code></pre>
<h1><a class="header" href="#gen-and-monadgen" id="gen-and-monadgen"><code>Gen</code> and <code>MonadGen</code></a></h1>
<h2><a class="header" href="#how-quickcheck-generates-random-data" id="how-quickcheck-generates-random-data">How QuickCheck Generates Random Data</a></h2>
<p>So, how does QuickCheck generate random data? Essentially, it uses a linear congruential generator to produce random numbers. Values can be created based on that number. Let's give some examples.</p>
<p>Let's say the randomly generated number is <code>x</code> where <code>x</code> is a <code>Number</code>:</p>
<ul>
<li>Primitives:
<ul>
<li>Boolean: if <code>0 &lt; x</code> and <code>x &lt; 0.5</code>, we might produce a <code>true</code> value and <code>false</code> otherwise.</li>
<li>Int: we can convert <code>x</code> to an <code>Int</code> via <code>ceil</code></li>
<li>Char: we can map <code>x</code> to an <code>Int</code> and then produce a corresponding Unicode value via <code>toCharCode</code>.</li>
<li>String: by generating numerous <code>Char</code> values, we can combine them together into a <code>String</code> value.</li>
</ul>
</li>
<li>Containers:
<ul>
<li>Maybe: given a <code>Gen a</code>, we can generate <code>Nothing</code> if <code>0 &lt; x &amp;&amp; x &lt; 0.5</code> and <code>Just a</code> otherwise.</li>
<li>Either: given a <code>Gen a</code> and a <code>Gen b</code>, we can generate <code>Left a</code> if <code>0 &lt; x &amp;&amp; x &lt; 0.5</code> and <code>Right b</code> otherwise.</li>
<li>List: given a <code>Gen a</code> and an <code>Int</code> indicating the number of values to generate, we can use the first generator to produce an <code>a</code> value and cons that onto <code>Nil</code> or the rest of the list.</li>
<li>Array: we can generate a <code>List a</code> and then use <code>fromUnfoldable</code></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#the-gen-monad-and-its-monadgen-type-class" id="the-gen-monad-and-its-monadgen-type-class">The <code>Gen</code> Monad and its <code>MonadGen</code> Type Class</a></h2>
<p>In <a href="https://pursuit.purescript.org/packages/purescript-gen/"><code>purescript-gen</code></a>, <a href="https://pursuit.purescript.org/packages/purescript-gen/docs/Control.Monad.Gen.Class">MonadGen</a> is the type class that has a default implementation via <a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck.Gen#t:Gen">Gen</a>. To see all of the definitions of the types used in <code>Gen</code>, look below:</p>
<pre><code class="language-haskell">-- This Int will always be between 1 and 2147483647,
-- which is (2^31 - 1), a Mersenne prime.
-- It is used in a linear congruential generator.
newtype Seed = Seed Int -- This will always be a positive integer
type Size = Int
type GenState = { newSeed :: Seed, size :: Size }

newtype Gen a = State GenState a
</code></pre>
<p>QuickCheck uses the <code>Gen</code> monad (i.e. generator monad) to generate random data. <code>QuickCheck.Gen</code> exports most of the package's functions (i.e. the &quot;combinators&quot; as they are called), not but all of them.</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-gen/docs/Control.Monad.Gen">Generators for <code>Int</code>, <code>Boolean</code>, and <code>Number</code></a>.</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-gen/docs/Control.Monad.Gen.Common">Generators for common FP container types</a>, such as <code>Maybe</code>, <code>Either</code>, <code>Tuple</code>, etc.</li>
</ul>
<p>Furthermore, some data types combinators exist in other libraries. For example:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-strings/docs/Data.Char.Gen">Generators for <code>Char</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Gen">Generators for <code>String</code></a></li>
</ul>
<h2><a class="header" href="#the-importance-of-the-seed-value" id="the-importance-of-the-seed-value">The Importance of the <code>Seed</code> Value</a></h2>
<p>The <code>Seed</code> value is used to produce the random data. If you run a propety test and it fails, the failure message will also include the seed used to produce that data. Once you update your code to fix the bug, how would you know whether it fixed that particular instance? You would run the test and specify that it should use that specific seed.</p>
<p>As an example, this repository includes some example programs in the <code>Projects</code> folder. One of my property tests failed, so I saved the seeds here: https://github.com/JordanMartinez/purescript-jordans-reference/issues/351.</p>
<p>I can use those seeds to help troubleshoot why these problems occurred and ensure that the bug has indeed been fixed.</p>
<h1><a class="header" href="#02-test-syntaxpurs" id="02-test-syntaxpurs">02-Test-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Test.QuickCheckSyntax where

import Prelude

import Effect (Effect)
import Effect.Console (log)

-- needed to run tests
import Effect.Exception (catchException, message)

-- new imports
-- these will be explained below
import Test.QuickCheck (
      quickCheck, quickCheck'
    , (&lt;?&gt;)
    , (==?), (===), (/=?), (/==)
    , (&lt;?), (&lt;=?), (&gt;?), (&gt;=?)

    -- needed to reduce noise in syntax
    , class Testable
    )

-- wraps the test output with the name of the test
runTest :: String -&gt; Effect Unit -&gt; Effect Unit
runTest testName test = do
  log $ &quot;=== Running test:  &quot; &lt;&gt; testName
  test
  log $ &quot;=== Test finished: &quot; &lt;&gt; testName &lt;&gt; &quot;\n\n&quot;

-- runs our tests
main :: Effect Unit
main = do
  runTest &quot;Pass - exhaustive&quot;       passingTest_exhaustive
  runTest &quot;Pass - normal threshold&quot; passingTest_normal_threshold
  runTest &quot;Pass - custom threshold&quot; passingTest_custom_threshold

  runTest &quot;Fail - no error message&quot;       error_message_None
  runTest &quot;Fail - standard error message&quot; error_message_Standard
  runTest &quot;Fail - custom error message&quot;   error_message_Custom

{-
QuickCheck cannot always infer which type we're using for our
randomly-generated data.

  -- What is the type of `a` ? Answer: any instance of Eq
  quickCheck (\a -&gt; a == a)

To fix this, we could use one of two things:                        -}
-- 1. (argName :: Type) syntax
noisySyntax1 :: Effect Unit
noisySyntax1 = quickCheck (\(i :: Int) -&gt; true)

noisySyntax2 :: Effect Unit
noisySyntax2 = quickCheck (\i -&gt; (\_ -&gt; true) (i :: Int))

-- 2. Use a function that specifies its type
intOnlyFunction :: Int -&gt; Boolean
intOnlyFunction _ = true

functionThatSpecifiesType :: Effect Unit
functionThatSpecifiesType = quickCheck (\i -&gt; intOnlyFunction i)
{-
Each adds &quot;noise&quot; to the syntax.

So, the below functions specify what the type is. When you read
these functions in actual tests, remove the &quot;_type&quot; suffix:
  - quickCheck_int        =&gt;  quickCheck
  - quickCheck'_int       =&gt;  quickCheck'

The functions appear at the bottom of the file.
-}

-- test that &quot;b &amp;&amp; true&quot; reduces to &quot;b&quot;
-- This test will not stop after 2 tries, even though that's all it needs.
passingTest_exhaustive :: Effect Unit
passingTest_exhaustive = quickCheck_boolean (\b -&gt; (b &amp;&amp; true) == b)

-- Test that &quot;+&quot; works regardless of argument order (i.e. commutative)
passingTest_normal_threshold :: Effect Unit
passingTest_normal_threshold = quickCheck_int       (\i -&gt; i + 1 == 1 + i)

-- increase confidence by increasing the number of tests
passingTest_custom_threshold :: Effect Unit
passingTest_custom_threshold = quickCheck'_int 1000 (\i -&gt; i + 1 == 1 + i)

-- A test that fails will crash our program, preventing us from
-- seeing the output of other failing tests. We'll fix this by
-- preceding such tests with `printErrorMessage`. The function appears
-- at the bottom of the file.

error_message_None :: Effect Unit
error_message_None =
  printErrorMessage $ quickCheck_int (\i -&gt; i + 1 == i)

{-
Quickcheck uses &quot;[operator]?&quot; syntax to add a standard error message

Normal without message | ==  | /=  | &lt;  | &lt;=  | &gt;  | &gt;=
Normal with    message | ==? | /=? | &lt;? | &lt;=? | &gt;? | &gt;=?
Alternative            | === | /== |
-}
error_message_Standard :: Effect Unit
error_message_Standard = do
  printErrorMessage $ quickCheck_int (\i -&gt; i + 1 ==? i)
  log &quot;&quot; -- add a blank line in-between tests
  printErrorMessage $ quickCheck_int (\i -&gt; i + 1 === i)
  log &quot;&quot;
  printErrorMessage $ quickCheck_int (\i -&gt; i     /=? i)
  log &quot;&quot;
  printErrorMessage $ quickCheck_int (\i -&gt; i     /== i)
  log &quot;&quot;
  printErrorMessage $ quickCheck_int (\i -&gt; i + 1 &lt;=? i)
  log &quot;&quot;
  printErrorMessage $ quickCheck_int (\i -&gt; i + 1  &lt;? i)
  log &quot;&quot;
  printErrorMessage $ quickCheck_int (\i -&gt; i - 1  &gt;? i)
  log &quot;&quot;
  printErrorMessage $ quickCheck_int (\i -&gt; i - 1 &gt;=? i)

error_message_Custom :: Effect Unit
error_message_Custom =
  printErrorMessage $ quickCheck_int
    (\i -&gt; i + 1 == i &lt;?&gt; show i &lt;&gt; &quot; did not equal &quot; &lt;&gt; (show $ i + 1))

-- Helper functions

printErrorMessage :: Effect Unit -&gt; Effect Unit
printErrorMessage test = catchException (\error -&gt; log $ message error) test

data Result_
  = Success_
  | Failure_ String -- error message
-- &quot;a&quot; is
--    either a Boolean, which is converted into a Result
--    or     a Result itself.

quickCheck_boolean :: forall a. Testable a =&gt; (Boolean -&gt; a) -&gt; Effect Unit
quickCheck_boolean test = quickCheck test

quickCheck_int ::  forall a. Testable a =&gt; (Int -&gt; a) -&gt; Effect Unit
quickCheck_int test = quickCheck test

-- variant that allows one to specify the number of tests
quickCheck'_int :: forall a. Testable a =&gt; Int -&gt; (Int -&gt; a) -&gt; Effect Unit
quickCheck'_int numOfTests test = quickCheck' numOfTests test
</code></pre>
<h1><a class="header" href="#03-generating-random-datapurs" id="03-generating-random-datapurs">03-Generating-Random-Data.purs</a></h1>
<pre><code class="language-haskell">-- | The focus of this file is on how to use combinators.
-- | to produce random data.
module Test.RandomDataGeneration.Combinators where

import Prelude
import Data.Maybe (fromJust)
import Effect (Effect)
import Effect.Console (log)
import Data.Array.NonEmpty as NEA
import Data.List.NonEmpty as NEL

-- new imports
-- these are all explained below
import Test.QuickCheck.Gen (
    uniform
  , choose, chooseInt, elements, shuffle
  , oneOf, frequency, suchThat
  , arrayOf, arrayOf1, listOf, vectorOf

-- all imports below this line are needed to compile
  , Gen, randomSample
  )
import Data.Int (even)
import Data.Traversable (for)
import Data.Tuple (Tuple(..))
import Partial.Unsafe (unsafePartial)

-- Prints the results of the combinators in Test.QuickCheck.Gen
main :: Effect Unit
main = do                                                                 {-
  printData &quot;explanation&quot; $
    combinator arg1 arg2 -- if args are required                          -}

  log &quot;*** Basic combinators ***&quot;

  -- see &quot;Standard Uniform Distribution&quot; section in
  -- https://www.wikiwand.com/en/Uniform_distribution_(continuous)
  printData &quot;uniform - standard uniform distribution&quot; $
    uniform

  printData &quot;chooseInt - choose a random Int between&quot; $
    chooseInt 1   10

  printData &quot;choose - choose a random Number between&quot; $
    choose    1.0 10.0

   -- oneToThree = NonEmptyArray [1, 2, 3]
  let oneToThree = unsafePartial fromJust $ NEA.fromArray [1, 2, 3]
  printData (&quot;elements - Choose an random element from the array where \
             \each element has the same probability of being chosen&quot;) $
    elements oneToThree

  let array = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  printData (&quot;shuffle - randomize the order of an array's elements \
             \(e.g. &quot; &lt;&gt; show array &lt;&gt; &quot;)&quot;) $
    shuffle array



  log &quot;*** Composable combinators ***&quot;

  printData (&quot;oneOf - Randomly choose a generator (where each generator has \
             \the same probability of being chosen) and use it to generate \
             \a random instance of the data type&quot;) $
    oneOf $ unsafePartial fromJust $ NEA.fromArray
      [ chooseInt   0   9
      , chooseInt  10  99
      , chooseInt 100 999
      ]

  let array_1 = NEA.singleton 1 -- (NonEmptyArray Int)
      array_2 = NEA.singleton 2
      array_4 = NEA.singleton 4
      lessOften = 1.0
      sometimes = 2.0
      moreOften = 4.0
  printData (&quot;frequency - Generate an instance from an array of generators \
                  \where each generator is used unequally&quot;) $
    frequency $
      NEL.cons      (Tuple lessOften (elements $ array_1)) $
      NEL.cons      (Tuple sometimes (elements $ array_2)) $
      NEL.singleton (Tuple moreOften (elements $ array_4))

  printData &quot;suchThat - Create a generator (e.g. even numbers) by filtering \
            \out invalid instances that are generated from another generator \
            \by using the given function&quot; $
    suchThat (chooseInt 1 100) even

  log &quot;*** Multiplier combinators ***&quot;

  printData &quot;arrayOf - Using a generator that creates one `a`, create \
            \an empty array of type `a` or \
            \an array of randomly-generated `a` instances&quot; $
    arrayOf $ chooseInt 0 9

  printData &quot;arrayOf1 - Using a generator that creates one `a`, create \
            \an non-empty array of randomly-generated `a` instances&quot; $
    arrayOf1 $ chooseInt 0 9

  printData &quot;vectorOf - Using a generator that creates one `a`, create \
            \a non-empty array of a specified number of randomly-generated \
            \`a` instances&quot; $
    vectorOf 10 $ chooseInt 0 9

  printData &quot;listOf - Using a generator that creates one `a`, create \
            \a non-empty list of a specified number of randomly-generated \
            \`a` instances&quot; $
    listOf 10 $ chooseInt 0 9

-- Helper functions

printData :: forall a. Show a =&gt; String -&gt; Gen a -&gt; Effect Unit
printData explanation generator = do
  log $ &quot;=== &quot; &lt;&gt; explanation
  result &lt;- randomSample generator
  void $ for result (\item -&gt; log $ show item)
  log &quot;=== Finished\n&quot;
</code></pre>
<h1><a class="header" href="#04-generating-stringspurs" id="04-generating-stringspurs">04-Generating-Strings.purs</a></h1>
<pre><code class="language-haskell">-- | The focus of this file is on using String/Char's
-- | generators to produce random String values.
module Test.RandomDataGeneration.Strings where

import Prelude

import Data.Char.Gen (genAlpha, genAlphaLowercase, genAlphaUppercase, genAsciiChar, genAsciiChar', genDigitChar, genUnicodeChar)
import Data.Enum (toEnumWithDefaults)
import Data.FoldableWithIndex (forWithIndex_)
import Data.String.Gen (genAlphaLowercaseString, genAlphaString, genAlphaUppercaseString, genAsciiString, genAsciiString', genDigitString, genString, genUnicodeString)
import Data.Traversable (fold)
import Effect (Effect)
import Effect.Console (log)
import Test.QuickCheck.Gen (Gen, chooseInt, listOf, randomSample)

-- Prints the results of the combinators in Data.Char.Gen
-- and Data.String.Gen
main :: Effect Unit
main = do                                                                 {-
  printData &quot;explanation&quot; $
    combinator arg1 arg2 -- if args are required                          -}

  log &quot;*** Basic Char combinators ***&quot;

  printData &quot;genUnicodeChar - generates a character of the Unicode basic \
            \multilingual plane. Since Asian languages take up a big chunk \
            \of the plane, most of the characters will be an Asian character&quot; $
    genUnicodeChar

  printData &quot;genAsciiChar - generates a character in the ASCII character set, \
            \excluding control codes&quot; $
    genAsciiChar

  printData &quot;genAsciiChar' - generates a character in the ASCII character set&quot; $
    genAsciiChar'

  printData &quot;genDigitChar - generates a character that is a numeric digit&quot; $
    genDigitChar

  printData &quot;genAlpha - generates a character from the basic latin alphabet&quot; $
    genAlpha

  printData &quot;genAlphaLowercase - generates a lowercase character from the \
            \basic latin alphabet&quot; $
    genAlphaLowercase

  printData &quot;genAlphaUppercase - generates an uppercase character from the \
            \basic latin alphabet&quot; $
    genAlphaUppercase


  let
    customCharGenerator :: Int -&gt; Int -&gt; Gen Char
    customCharGenerator lower upper =
      toEnumWithDefaults bottom top &lt;$&gt; chooseInt lower upper

  printData &quot;custom Char generator - generates a character between the 65 \
            \1200 character points, inclusive&quot; $
    customCharGenerator 65 1200

  log &quot;*** Basic String combinators ***&quot;

  printData &quot;genUnicodeString - generates a 1-character String of the Unicode \
            \basic multilingual plane. Since Asian languages take up a big \
            \chunk of the plane, most of the characters will be an Asian \
            \character&quot; $
    genUnicodeString

  printData &quot;genAsciiString - generates a 1-character String in the ASCII \
            \character set, excluding control codes&quot; $
    genAsciiString

  printData &quot;genAsciiString' - generates a 1-character String in the ASCII \
            \character set&quot; $
    genAsciiString'

  printData &quot;genDigitString - generates a 1-character String that is a \
            \numeric digit&quot; $
    genDigitString

  printData &quot;genAlpha - generates a 1-character String from the basic latin \
            \alphabet&quot; $
    genAlphaString

  printData &quot;genAlphaLowercase - generates a lowercase 1-character String from \
            \the basic latin alphabet&quot; $
    genAlphaLowercaseString

  printData &quot;genAlphaUppercase - generates an uppercase 1-character String \
            \from the basic latin alphabet&quot; $
    genAlphaUppercaseString

  printData &quot;custom String generator - generates a 1-character String using \
            \the character generator you provide. (In this case, the character \
            \will be between the 65 and 1200 character points, inclusive&quot; $
    genString $ customCharGenerator 65 1200

  log &quot;*** Actual String combinators ***&quot;

  let
    produceStringWith20Chars :: String -&gt; Gen String -&gt; Effect Unit
    produceStringWith20Chars msg stringGenerator = do
      printData msg $ fold &lt;$&gt; listOf 20 stringGenerator

  produceStringWith20Chars &quot;genUnicodeString&quot; genUnicodeString
  produceStringWith20Chars &quot;genAsciiString&quot; genAsciiString
  produceStringWith20Chars &quot;genAsciiString'&quot; genAsciiString'
  produceStringWith20Chars &quot;genDigitString&quot; genDigitString
  produceStringWith20Chars &quot;genAlphaString&quot; genAlphaString
  produceStringWith20Chars &quot;genAlphaLowercaseString&quot; genAlphaLowercaseString
  produceStringWith20Chars &quot;genAlphaUppercaseString&quot; genAlphaUppercaseString
  produceStringWith20Chars &quot;genString with custom Char generator&quot; $
    genString $ customCharGenerator 65 1200

-- Helper functions

printData :: forall a. Show a =&gt; String -&gt; Gen a -&gt; Effect Unit
printData explanation generator = do
  log $ &quot;=== &quot; &lt;&gt; explanation
  result &lt;- randomSample generator
  forWithIndex_ result (\index item -&gt;
    log $ &quot;Item: &quot; &lt;&gt; show index &lt;&gt; &quot;: &quot; &lt;&gt; show item)
  log &quot;=== Finished\n&quot;
</code></pre>
<h1><a class="header" href="#05-arbitrarypurs" id="05-arbitrarypurs">05-Arbitrary.purs</a></h1>
<pre><code class="language-haskell">{-
Now that we understand how to generate random data via combinators,
it's time to look at the Arbitrary type class.
-}
module Test.RandomDataGeneration.Arbitrary where

import Prelude
import Effect (Effect)
import Effect.Console (log)

-- needed to compile
import Data.Maybe (fromJust)
import Data.List.NonEmpty as NEL
import Data.Array.NonEmpty as NEA
import Data.Tuple (Tuple(..))
import Partial.Unsafe (unsafePartial)

import Test.QuickCheck (quickCheck)
import Test.QuickCheck.Gen (elements, frequency, Gen)

-- new imports
import Test.QuickCheck.Arbitrary (class Arbitrary, arbitrary)

-- Arbitrary simply defines what a given type's default generator is...

class Arbitrary_ a where
  arbitrary_ :: Gen a

-- For example, given this code...

data Fruit
  = Apple
  | Banana
  | Orange

instance Arbitrary Fruit where
  arbitrary = elements $ unsafePartial fromJust $ NEA.fromArray [ Apple, Banana, Orange]

-- ... the below (useless) code would compile
-- main :: Effect Unit
-- main = quickCheck (\(fruit :: Fruit) -&gt; true)

{-
The below explanation is largely based on the purescript-quickcheck's repo's
guide. The copyright appears at the end of this file.

Above, I said that `Arbitrary` represents a type's &quot;default generator.&quot;
What if we wanted to generate a `Fruit` instance that is more frequently
an `Apple` rather than a `Banana` or `Orange`?
In such cases, we can use `newtype`
-}

-- define our newtype
newtype FrequentApple = FrequentApple Fruit

-- helper function
constant :: Fruit -&gt; Gen FrequentApple
constant fruit = elements $ NEA.singleton $ FrequentApple fruit

-- write its instance
instance Arbitrary FrequentApple where
  arbitrary = frequency $
    NEL.cons      (Tuple 6.0 (constant Apple))  $
    NEL.cons      (Tuple 2.0 (constant Banana)) $
    NEL.singleton (Tuple 1.0 (constant Orange))

-- write a helper function for unwrapping the type
runApple :: FrequentApple -&gt; Fruit
runApple (FrequentApple fruit) = fruit

-- Then use it in a function
-- main :: Effect Unit
-- main = quickCheck (\usuallyApple -&gt; (\_ -&gt; true) $ runApple usuallyApple)


-- Likewise, we can use the type's arbitrary to create a newtype's arbitrary
newtype SmallInt = SmallInt Int

instance Arbitrary SmallInt where
  arbitrary = (SmallInt &lt;&lt;&lt; (_ / 1000)) &lt;$&gt; arbitrary -- Arbitrary Int

runInt :: SmallInt -&gt; Int
runInt (SmallInt i) = i

-- Now let's put it all together
main :: Effect Unit
main = do
  log &quot;Regular Apple&quot;
  quickCheck (\(fruit :: Fruit) -&gt; true )

  log &quot;Frequent Apple&quot;
  quickCheck (\usuallyApple -&gt; (\_ -&gt; true) $ runApple usuallyApple)

  log &quot;Small Int&quot;
  quickCheck (\(SmallInt i) -&gt; true )

-- Copyright notice of above explanation
{-
Copyright 2018 PureScript

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-}
</code></pre>
<h1><a class="header" href="#coarbitrary" id="coarbitrary">Coarbitrary</a></h1>
<p>The Dual or <code>Arbitrary</code> is <code>Coarbitrary</code>. To understand how this works, see <a href="https://stackoverflow.com/questions/47849407/coarbitrary-in-haskell#47910875">CoArbitrary in Haskell (SO Answer)</a>.</p>
<p>In case one wants to randomly generate functions, one will need to use a <code>Coarbitrary</code> constraint to implement that function's <code>Arbitrary</code> instance.</p>
<p>Implementing <code>Coarbitrary</code> isn't hard. Looking at <a href="https://github.com/purescript/purescript-quickcheck/blob/v6.1.0/src/Test/QuickCheck/Arbitrary.purs#L78"><code>Number</code>'s instance</a>, <a href="https://github.com/purescript/purescript-quickcheck/blob/v6.1.0/src/Test/QuickCheck/Arbitrary.purs#L71"><code>Boolean</code>'s instance</a>, and <a href="https://github.com/purescript/purescript-quickcheck/blob/v6.1.0/src/Test/QuickCheck/Arbitrary.purs#L102"><code>Char</code>'s instance</a>, you can start to see a pattern.</p>
<h1><a class="header" href="#problems-with-arbitrary" id="problems-with-arbitrary">Problems with Arbitrary</a></h1>
<p>In the examples so far, we have shown you how to run your tests using <code>Arbitrary</code>. The downside of <code>Arbitrary</code> is that you might want to generate a slightly different value for the same type. This approach will quickly run afoul of two problems. Both problems can be resolved by defining a newtype over the original type and an instance that differs from the original instance:</p>
<ul>
<li>the problem of Overlapping Instances</li>
<li>the problem of Orphan Instances</li>
</ul>
<p>We will provide two brief examples showing this problem below. For more context and why these two problems are bad, read to <code>FP Philosophical Foundations/Type Clases.md#Type Class Instances: Global vs Local</code> or read the beginning part of <a href="https://kseo.github.io/posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html">Avoid overlapping instances with closed type families</a>.</p>
<p><strong>The Problem of Overlapping Instances</strong>:</p>
<pre><code class="language-purescript">newtype MyRec = MyRec { a :: String, b :: Int }
instance Arbitrary MyRec where
  arbitrary = do
    a &lt;- genString
    b &lt;- chooseInt 1 100
    pure $ MyRec { a, b }

newtype MyRecVariation = MyRecVariation MyRec
instance Arbitrary MyRecVariation where
  arbitrary = do
    a &lt;- map (\str -&gt; str &lt;&gt; &quot; and more&quot;) genString
    b &lt;- chooseInt 1 200
    pure $ MyRecVariation { a, b }

main :: Effect Unit
main = do
  quickCheck \(MyRec r) -&gt; length r.a == r.b
  quickCheck \(MyRecVariation r) -&gt; ((length r.a) * 2) == r.b
</code></pre>
<p><strong>The Problem of Orphan Instances.</strong> Another problem you might experience is that a library has defined a type and its <code>Arbitrary</code> instance. However, their version of the instance isn't the implementation you want. Since the <code>Arbitrary</code> type class and the type you wish to use were both defined in modules you can't control, you can't define an instance for that type. Thus, you must use resort to the newtype solution.</p>
<p>Fortunately, quickcheck provides a way around this: we don't have to use <code>Arbitrary</code> to generate a value/test. Rather, we can use plain <code>Gen</code>:</p>
<table><thead><tr><th>Description</th><th>Uses <code>Arbitrary</code></th><th>Uses <code>Gen</code></th></tr></thead><tbody>
<tr><td>Run a test 100 times</td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheck">quickCheck</a></td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckGen">quickCheckGen</a></td></tr>
<tr><td>Run a test a specified number of times</td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheck&#x27;">quickCheck'</a></td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckGen&#x27;">quickCheckGen'</a></td></tr>
<tr><td>Run a test a specified number of times with access to the seed</td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckWithSeed">quickCheckWithSeed</a></td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckGenWithSeed">quickCheckGenWithSeed</a></td></tr>
<tr><td>Run a test a specified number of times with access to the seed, returning all the results of the test as a list</td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckPure">quickCheckPure</a></td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckGenPure">quickCheckGenPure</a></td></tr>
<tr><td>Run a test a specified number of times with access to the seed, returning all the results of the test as a list, including the seed used when running a particular test</td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckPure&#x27;">quickCheckPure'</a></td><td><a href="https://pursuit.purescript.org/packages/purescript-quickcheck/docs/Test.QuickCheck#v:quickCheckGenPure&#x27;">quickCheckGenPure'</a></td></tr>
</tbody></table>
<p>Thus, we could rewrite our above example test to...</p>
<pre><code class="language-purescript">newtype MyRec = MyRec { a :: String, b :: Int }

genMyRec :: Gen MyRec
genMyRec = do
  a &lt;- genString
  b &lt;- chooseInt 1 100
  pure $ MyRec { a, b }

genMyRecVariation :: Gen MyRec
genMyRecVariation = do
  a &lt;- map (\str -&gt; str &lt;&gt; &quot; and more&quot;) genString
  b &lt;- chooseInt 1 200
  pure $ MyRecVariation { a, b }

main :: Effect Unit
main = do
  quickCheckGen do
    (MyRec r) &lt;- genMyRec
    pure $ length r.a == r.b

  quickCheckGen do
    (MyRecVariation r) &lt;- genMyRecVariation
    pure $ ((length r.a) * 2) == r.b

  -- or just inline `genMyRecVariation` and its test
  quickCheckGen do
    a &lt;- map (\str -&gt; str &lt;&gt; &quot; and more&quot;) genString
    b &lt;- chooseInt 1 200
    pure $ length a == b
</code></pre>
<h1><a class="header" href="#08-quick-check-lawspurs" id="08-quick-check-lawspurs">08-Quick-Check-Laws.purs</a></h1>
<pre><code class="language-haskell">{-
This file will show how to use QuickCheck Laws to quickly
and easily test whether one's instances for various core
type classes are correct. To see the full list, see its documentation here:
https://pursuit.purescript.org/packages/purescript-quickcheck-laws/4.0.0

The library approach uses type-level programming to check the laws.
-}
module Test.QuickCheckLaws where

import Prelude
import Effect (Effect)
import Data.Array.NonEmpty as NEA
import Data.Maybe (fromJust)
import Test.QuickCheck.Gen (elements)
import Test.QuickCheck.Arbitrary (class Arbitrary, arbitrary)
import Partial.Unsafe (unsafePartial)

-- new imports
import Test.QuickCheck.Laws (checkLaws, A)
import Test.QuickCheck.Laws.Control as Control
import Test.QuickCheck.Laws.Data as Data

-- necessary to compile
import Type.Proxy (Proxy(..), Proxy2(..))

-- Given a type...
-- (e.g. our Box type from before)
data Box a = Box a

-- ... that implements some type classes...
-- (instances appear at the bottom of the file)

-- ... and an Arbitrary for our Box type
instance (Arbitrary a) =&gt; Arbitrary (Box a) where
  arbitrary = map pure arbitrary

-- ... and a helper function for checking all of them at once
checkBox :: Effect Unit
checkBox =
  -- checkLaws &quot;data type&quot; do
  --   type-class 1 check
  --   type-class 2 check
  --   ...

  checkLaws &quot;Box&quot; do
    -- type classes with concrete types
    Data.checkEq  prxBox
    Data.checkOrd prxBox

    -- type classes with higher-kinded types
    Data.checkFunctor        prx2Box
    Control.checkApply       prx2Box
    Control.checkApplicative prx2Box
    Control.checkBind        prx2Box
    Control.checkMonad       prx2Box
    where
    -- When using type classes like `Eq` or `Ord` that
    -- are not higher-kinded types, use `prxBox`
    -- `A` is a filler type from the laws package
    prxBox = Proxy :: Proxy (Box A)

    -- When using type classes like `Functor` or `Apply` that
    -- are higher-kinded types, use prx2Box
    prx2Box = Proxy2  Proxy2 Box

-- We can test multiple types' instances to insure they adhere to those
-- type classes' laws.
main :: Effect Unit
main = do
  checkBox

  -- Fruit's type, arbitrary, and instances appear after
  -- the &quot;Box's instances&quot; section
  checkFruit

-- Box's instances

instance (Eq a) =&gt; Eq (Box a) where
  eq (Box a1) (Box a2) = eq a1 a2

instance (Ord a) =&gt; Ord (Box a) where
  compare (Box a1) (Box a2) = compare a1 a2

instance Functor Box where
  map :: forall a b. (a -&gt; b) -&gt; Box a -&gt; Box  b
  map f (Box a) = Box (f a)

instance Apply Box where
  apply :: forall a b. Box (a -&gt; b) -&gt; Box a -&gt; Box  b
  apply (Box f) (Box a) = Box (f a)

instance Bind Box where
  bind :: forall a b. Box a -&gt; (a -&gt; Box b) -&gt; Box b
  bind (Box a) f = f a

instance Applicative Box where
  pure :: forall a. a -&gt; Box a
  pure a =  Box a

instance Monad Box

-- Fruit's type, arbitrary, and instances

data Fruit = Apple | Orange

instance Arbitrary Fruit where
  arbitrary = elements $ unsafePartial fromJust $ NEA.fromArray [Apple, Orange]

derive instance Eq Fruit

instance Ord Fruit where
  compare Apple Orange = LT
  compare Orange Apple = GT
  compare _ _ = EQ

checkFruit :: Effect Unit
checkFruit =
  checkLaws &quot;Fruit&quot; do
    Data.checkEq  prxFruit
    Data.checkOrd prxFruit

    where
    -- since Fruit is not a higher-kinded type,
    -- we don't need the filler `A` type here
    prxFruit = Proxy :: Proxy Fruit
</code></pre>
<h1><a class="header" href="#property-testing-libraries-comparison" id="property-testing-libraries-comparison">Property Testing Libraries Comparison</a></h1>
<p>Besides QuickCheck, there are two other property testing libraries in the Purescript ecosystem:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-strongcheck/docs/Test.StrongCheck.Perturb">StrongCheck</a> and its corresponding <a href="https://pursuit.purescript.org/packages/purescript-strongcheck-laws/docs/Test.StrongCheck.Laws">StrongCheck-Laws</a> package</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-jack/">Jack</a> (no longer compiles since the <code>0.12.0</code> release)</li>
</ul>
<p>Here's a comparison table between the three:</p>
<table><thead><tr><th>Feature</th><th>QuickCheck</th><th>StrongCheck</th><th>Jack</th></tr></thead><tbody>
<tr><td>Equivalent Haskell Library</td><td>QuickCheck</td><td>QuickCheck</td><td>Hedgehog</td></tr>
<tr><td>Uses Arbitrary</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Type of Shrinking</td><td>Type-Directed</td><td>Type-Directed</td><td>Integrated</td></tr>
<tr><td>Supports &quot;exhaustive&quot; testing</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Supports &quot;statistical&quot; testing</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Can generate functions</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Supports monadic tests</td><td>Yes</td><td>Yes</td><td>No</td></tr>
</tbody></table>
<p>According to @garyb, one of the core contributors to Purescript:</p>
<blockquote>
<p>Originally StrongCheck (SC) was fully stack safe where there were some cases that QuickCheck (QC) was not, but QC is now too. I wouldn't use SC now unless I needed <code>smallCheck</code> (exhaustive testing) or <code>statCheck</code> (statistical testing) as it is significantly slower, to the point of it being annoying on some tests</p>
</blockquote>
<p>Consider also reading through <a href="https://www.fpcomplete.com/blog/quickcheck-hedgehog-validity">QuickCheck, Hedgehog, and Validity</a>, an article on Haskell's different testing libraries.</p>
<p>Lastly, QuickCheck's <code>Gen</code> type and combinators are used in <code>Benchotron</code>, the Purescript benchmarking library (covered next)</p>
<h1><a class="header" href="#benchmarking" id="benchmarking">Benchmarking</a></h1>
<p>Purescript has a few benchmarking libraries:</p>
<table><thead><tr><th>Name</th><th>Status</th><th>Comments</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-benchotron/">purescript-benchotron</a></td><td>Up-to-date</td><td>Uses QuickCheck<br>Output results only in Node<br>Results are viewable only via graphs</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-minibench/2.0.0/docs/Performance.Minibench">purescript-minibench</a></td><td>Up-to-date</td><td>Provides quick estimates but not very accurate benchmarks</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-benchmark/0.1.0">purescript-benchmark</a></td><td>Outdated (PS <code>0.11.7</code>)</td><td>Doesn't require QuickCheck<br>Outputs results in Node and Browser<br>Output is full ASCII table with percentage values</td></tr>
</tbody></table>
<p>In this folder, we'll be covering <code>benchotron</code> because it works for <code>0.12.x</code> and has finer accuracy than <code>minibench</code> and includes graphs.</p>
<p>This benchotron graph...</p>
<p><img src="content/21-Hello-World/08-Benchmarking/./benchmark-results/file-name-for-output.svg" alt="benchmark results" /></p>
<p>... was the result of <a href="content/21-Hello-World/08-Benchmarking/./benchmark-results/file-name-for-output.json">this somewhat unreadable output</a></p>
<h2><a class="header" href="#compilation-instructions-6" id="compilation-instructions-6">Compilation Instructions</a></h2>
<p><code>Benchotron</code> is a Purescript library that provides bindings to <a href="https://benchmarkjs.com/"><code>Benchmark.js</code></a>. Follow these commands to set up this folder:</p>
<ol>
<li>Install <a href="https://benchmarkjs.com/"><code>Benchmark.js</code></a> locally via the command below:</li>
</ol>
<pre><code class="language-bash"># Note: This must be installed locally for the code to work.
# If you install it globally, Node won't be able to find `benchmark`.
npm install benchmark
</code></pre>
<ol start="2">
<li>Use <code>spago</code> to build the program::</li>
</ol>
<pre><code class="language-bash"># 'spago build' includes a call to 'spago install'
spago build
</code></pre>
<p>You can now use <code>benchotron</code> via spago.</p>
<h2><a class="header" href="#generating-benchmark-results" id="generating-benchmark-results">Generating benchmark results</a></h2>
<ol>
<li>Run the below command</li>
</ol>
<pre><code class="language-bash"># Since we have `&quot;benchmark/**/*.purs&quot;` included in
# the `spago.dhall` file's &quot;sources&quot; config, we can use
# the below command instead. If you don't that that,
# you'll need to add '-p &quot;benchmark/**/*.purs&quot;' as an argument below.
spago run -m Benchmarking.Syntax.Benchotron
</code></pre>
<ol start="2">
<li>It will output a file in the freshly-created <code>tmp</code> directory</li>
<li>Upload the outputted file to <a href="http://harry.garrood.me/purescript-benchotron-svg-renderer/">this link</a></li>
<li>Download the graph as an SVG or PNG</li>
</ol>
<h1><a class="header" href="#01-benchmark-syntaxpurs" id="01-benchmark-syntaxpurs">01-Benchmark-Syntax.purs</a></h1>
<pre><code class="language-haskell">module Benchmarking.Syntax.Benchotron where

import Prelude
import Effect (Effect)
import Test.QuickCheck.Arbitrary (arbitrary)
import Test.QuickCheck.Gen (vectorOf)

-- needed to run the benchmark
import Data.Foldable (foldMap, foldr)
import Data.Monoid.Additive (Additive(..))
import Data.Newtype (ala)

-- new imports
import Benchotron.Core (Benchmark, benchFn, mkBenchmark)

-- This module includes other `benchmarkToX` functions (e.g. benchmarkToFile)
-- However, there's no reason to directly use them. `runSuite`
-- uses them and provides the best interface to run
-- multiple benchmarks in one command
import Benchotron.UI.Console (runSuite)

main :: Effect Unit
main = runSuite [syntax]

syntax :: Benchmark
syntax = mkBenchmark
  { slug: &quot;file-name-for-output&quot;
  , title: &quot;Title of the benchmark&quot;
  -- Each `Int` in this `Array` will be the `n` argument in the `gen` field
  , sizes: [1000, 2000, 3000, 4000, 5000]
  , sizeInterpretation: &quot;Human-readable explanation of 'sizes': \
                        \the number of elements in an array&quot;
  -- how many times to run a benchmark for each 'size' above
  -- totalBenchmarksRun = (length sizes) * inputsPerSize
  -- If this was 2, we'd run each of the 5 benchmarks above twice
  , inputsPerSize: 1
 -- gen :: forall a. Int -&gt; Gen a
  , gen: \n -&gt; vectorOf n arbitrary
  , functions:            -- forall a r. (a -&gt; r)
      [ benchFn &quot;function name: foldr&quot;   (foldr (+) 0)
      , benchFn &quot;function name: foldmap&quot; (ala Additive foldMap)
      ]
  }
</code></pre>
<h1><a class="header" href="#next-steps" id="next-steps">Next Steps</a></h1>
<h2><a class="header" href="#style-guide-for-libraries" id="style-guide-for-libraries">Style Guide for Libraries</a></h2>
<p>If you ever want to write your own PureScript library, review the following (somewhat outdated) guidelines: <a href="https://github.com/purescript/documentation/blob/master/guides/Style-Guide.md">PureScript's Style Guide</a></p>
<h2><a class="header" href="#exploring-projects" id="exploring-projects">Exploring Projects</a></h2>
<p>Rather than combining multiple projects into this folder as was done previously, we link to projects that are standalone. This provides easier navigation through the code and encourages you to checkout the code locally to try it there.</p>
<h3><a class="header" href="#simple-projects-following-a-domain-driven-design" id="simple-projects-following-a-domain-driven-design">Simple Projects Following a Domain-Driven-Design</a></h3>
<p>The below programs were written by me when I was first learning how to design programs using modern FP architecture. This approach to writing programs tends to follow a domain-driven design by categorizing code into one of five layers:</p>
<table><thead><tr><th>Layer Level</th><th>Onion Architecture Term</th><th>General idea</th></tr></thead><tbody>
<tr><td>Layer 4</td><td>Core</td><td>Strong types with well-defined properties and their pure, total functions that operate on them</td></tr>
<tr><td>Layer 3</td><td>Domain</td><td>the &quot;business logic&quot; code which uses effects</td></tr>
<tr><td>Layer 2</td><td>API</td><td>the &quot;production&quot; or &quot;test&quot; monad which &quot;links&quot; these effects/capabilties with their corresponding implementations: a newtyped <code>ReaderT</code> and its instances</td></tr>
<tr><td>Layer 1</td><td>Infrastructure</td><td>the platform-specific framework/libraries we'll use to implement some special effects/capabilities (i.e. <code>Node.ReadLine</code>/<code>Halogen</code>/<code>StateT</code>)</td></tr>
<tr><td>Layer 0</td><td>Main<br>(no equivalent onion term)</td><td>the program's entry point<br>the &quot;base&quot; monad that runs the program (e.g. production: <code>Effect</code>/<code>Aff</code>; test: <code>Identity</code>)</td></tr>
</tbody></table>
<ul>
<li><a href="https://github.com/JordanMartinez/purescript-random-number-game">Random Number Game</a> - a very simple game that runs on the console and in the browser using the same &quot;business logic&quot;.</li>
<li><a href="https://github.com/JordanMartinez/purescript-mdbook-generator">Mdbook ToC Generator</a> - Not explained with a &quot;Design Thought Process&quot; file. A script that produces the necessary table of contents file used by <code>mdbook</code> to produce the website for this work.</li>
</ul>
<h3><a class="header" href="#other-example-projects" id="other-example-projects">Other &quot;Example Projects&quot;</a></h3>
<ul>
<li><a href="https://github.com/hdgarrood/multipac">hdgarrood's 'MultiPac' project</a></li>
<li><a href="https://github.com/thomashoneyman/purescript-halogen-realworld">thomashoneyman's 'Real World App' (Halogen version)</a></li>
<li><a href="https://github.com/jonasbuntinx/purescript-react-realworld">jonasbuntinx' - 'Real World App' (React Version)</a></li>
<li><a href="https://github.com/jaspervdj/beeraffe/">jaspervdj's 'Beeraffe' game</a></li>
<li><a href="https://github.com/AndrewBrownK/purescript-minesweeper-cli">AndrewBrownK's 'Minesweeper CLI' game</a></li>
</ul>
<h3><a class="header" href="#projects-in-non-js-backends" id="projects-in-non-js-backends">Projects in non-JS backends</a></h3>
<ul>
<li><a href="https://lettier.itch.io/lambda-lantern">Lambda Lantern</a></li>
</ul>
<h1><a class="header" href="#design-patterns" id="design-patterns">Design Patterns</a></h1>
<p>This folder is still a work-in-progress!</p>
<p>See <a href="https://github.com/JordanMartinez/purescript-jordans-reference/issues?q=is%3Aissue+is%3Aopen+label%3ADesign-Patterns">the related issues</a> regarding this folder for a more up-to-date understanding.</p>
<p>See <a href="https://williamyaoh.com/posts/2019-11-24-design-and-testing-articles.html">A list of Haskell articles on good design, good testing</a>.</p>
<p>See also this list of <a href="https://wiki.haskell.org/Research_papers/Functional_pearls">Functional Pearls</a></p>
<h1><a class="header" href="#smart-constructors" id="smart-constructors">Smart Constructors</a></h1>
<p>Smart constructors are a solution to the problem of how to create a valid value of some type when the type's definition does not allow invalid values.</p>
<h2><a class="header" href="#the-problem-2" id="the-problem-2">The Problem</a></h2>
<p>For example, one might want to use a type to specify a small integer (0 to 3). A possible solution is wrapping an <code>Int</code> in a newtype:</p>
<pre><code class="language-haskell">module Example.SmallInt (SmallInt(..)) where

newtype SmallInt = SmallInt Int
</code></pre>
<p>However, anyone can create a <code>SmallInt</code> using an <code>Int</code> value that is less than 0 or larger than 3: <code>SmallInt 5</code>.</p>
<p>As another example, consider this code:</p>
<pre><code class="language-haskell">module FlawedConstructors
  ( TheType(..)
  , example
  ) where

import Partial.Unsafe (unsafeCrashWith)

-- Let's assume that String value below
-- should only be of three kinds: &quot;apple&quot;, &quot;orange&quot;, and &quot;banana&quot;.
-- (Note: &quot;String&quot; is the wrong type for our situation. We should be using
--   something like &quot;data Fruit = Apple | Orange | Banana&quot;.
--   I'm doing this to teach a concept. Don't do this in real code.)
data TheType = DumbConstructor String

example :: TheType -&gt; Int
example (DumbConstructor &quot;apple&quot;)  = 1
example (DumbConstructor &quot;orange&quot;) = 2
example (DumbConstructor &quot;banana&quot;) = 42
example (DumbConstructor _)        = unsafeCrashWith &quot;This should never occur!&quot;
</code></pre>
<p>Since the type and its constructor are both exported, this enables a user of this module to use it incorrectly. For example, in code outside this module, one could incorrectly write:</p>
<pre><code class="language-purscript">example (DumbConstructor &quot;fire&quot;) -- crashes program with an error
</code></pre>
<h2><a class="header" href="#the-solution-1" id="the-solution-1">The Solution</a></h2>
<p>The solution is to not export the types' constructors and instead export &quot;smart constructors,&quot; which are functions that create a correct value of the type. The only way to get a value of the type is to use one of these functions:</p>
<pre><code class="language-haskell">module Example.SmallInt (SmallInt, zero, one) where

newtype SmallInt = SmallInt Int

zero :: SmallInt
zero = SmallInt 0

one :: SmallInt
one = SmallInt 1

-- the same for 'two' and 'three'
</code></pre>
<p>In our previous example, we could also write this:</p>
<pre><code class="language-haskell">module SmartConstructors
  ( TheType -- `DumbConstructor` isn't exported

  , apple   -- but the functions that wrap the constructor are
  , orange
  , banana
  ) where

import Partial.Unsafe (unsafeCrashWith)

data TheType = DumbConstructor String

apple :: TheType
apple = DumbConstructor &quot;apple&quot;

orange :: TheType
orange = DumbConstructor &quot;orange&quot;

banana :: TheType
banana = DumbConstructor &quot;banana&quot;

example :: TheType -&gt; Int
example (DumbConstructor &quot;apple&quot;)  = 1
example (DumbConstructor &quot;orange&quot;) = 2
example (DumbConstructor &quot;banana&quot;) = 42
example (DumbConstructor _) = unsafeCrashWith &quot;We can guarantee that this will never occur!&quot;
</code></pre>
<p>Since <code>DumbConstructor</code> isn't exported, one is forced to use the apple, orange, or banana smart constructors to get a value of <code>TheType</code>. Thus, it prevents one from creating incorrect <code>TheType</code> values.</p>
<pre><code class="language-haskell">preventBadValues :: Array Int
preventBadValues =
  [ example apple  -- returns 1
  , example orange -- returns 2
  , example banana -- returns 42

  , example (DumbConstructor &quot;fire&quot;) {- compiler error:
    &quot;You don't have access to that constructor!&quot; -}
  ]
</code></pre>
<h1><a class="header" href="#partial-functions" id="partial-functions">Partial Functions</a></h1>
<p>Partial functions are functions that will not always return an output for every input. An example is integer division:</p>
<ul>
<li><code>x / 1</code> produces an output: <code>x</code></li>
<li><code>x / 0</code> cannot produce an output but will throw an error.</li>
</ul>
<p>This folder is a summary of the article: <a href="http://www.parsonsmatt.org/2018/10/02/small_types.html">Keep your Types Small and Your Bugs Smaller</a></p>
<p>There are three different ways one can handle partial functions in Purescript:</p>
<ol>
<li>Crash on invalid inputs
<ul>
<li>via <code>Partial</code></li>
</ul>
</li>
<li>Return an error-container type:
<ul>
<li>via <code>Maybe a</code></li>
<li>via <code>Either String a</code></li>
<li>via <code>Either CustomErrorType a</code></li>
</ul>
</li>
<li>Use refined types
<ul>
<li>via <code>NonZeroInt</code> (or some other refined type)</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#compilation-instruction" id="compilation-instruction">Compilation Instruction</a></h2>
<p>Start the REPL, import the file's module, and pass in different arguments to the function to see what happens</p>
<h2><a class="header" href="#other-useful-links" id="other-useful-links">Other Useful Links</a></h2>
<ul>
<li><a href="https://github.com/thma/LtuPatternFactory/tree/master">Lamda The Ultimate - Pattern Factory</a> - Explains FP design patterns using OO terms.</li>
</ul>
<h1><a class="header" href="#01-via-partialpurs" id="01-via-partialpurs">01-Via-Partial.purs</a></h1>
<pre><code class="language-haskell">module PartialFunctions.ViaPartial where

import Prelude

-- new imports
-- Used when a function cannot return a valid value
import Partial (crash)

-- Used to indicate that one is using a partial function
-- in a (hopefully) safe way by passing only valid arguments to it.
-- In our example below, we will be passing invalid arguments to it.
import Partial.Unsafe (unsafePartial)

-- Run this program and divide by zero to see what happens.
unsafeDivision :: Partial =&gt; Int -&gt; Int -&gt; String
unsafeDivision _ 0 = crash &quot;You divided by zero!&quot;
unsafeDivision x y = showResult x y (x / y)
</code></pre>
<h1><a class="header" href="#02-via-maybepurs" id="02-via-maybepurs">02-Via-Maybe.purs</a></h1>
<pre><code class="language-haskell">module PartialFunctions.ViaMaybe where

import Prelude

{-
We can often turn our partial functions into total functions
by changing the output type from `OuputType` to `Maybe OutputType`:
-}

-- new imports
import Data.Maybe (Maybe(..))

data Maybe_ a   -- a type that indicates an instance of 'a' might exist
  = Nothing_      -- a box with nothing in it (empty box)
  | Just_ a       -- a box with 'just' an instance of &quot;a&quot; in it

{-
`Maybe` is often used in situations where
  - a function might return `null`.
  - we don't need to do anything with the error itself.

Using our example of division:

  | Expression | Explanation   | OO returns | FP returns |
  --------------------------------------------------------
  | 5 / 1      | Valid value   | 5          | Just 5
  | x / 0      | Invalid value | null       | Nothing

The following function, safeDivision, demonstrates this:
-}

-- No matter what arguments you pass into this,
-- you will always get a value out
safeDivision :: Int -&gt; Int -&gt; Maybe Int
safeDivision _ 0 = Nothing -- x / 0
safeDivision x y = Just (x / y)
</code></pre>
<h1><a class="header" href="#03-via-either-stringpurs" id="03-via-either-stringpurs">03-Via-Either-String.purs</a></h1>
<pre><code class="language-haskell">module PartialFunctions.ViaEitherString where

import Prelude

-- new imports
import Data.Either (Either(..))

-- `Maybe` is useful when we don't care about the error.
-- However, what if we do? In such cases, we use `Either:`

data Either_ a b  -- a type that is either 'a' or 'b'
  = Left_ a         -- the 'a' / failure type
  | Right_ b        -- the 'b' / success type

{-
In this next example, we'll use a different way to notify the user
that the user attempted to divide by zero. Rather than returning `Nothing`
for the &quot;divide by zero&quot; error, we'll return a String with the error message.
-}

safeDivision :: Int -&gt; Int -&gt; Either String Int
safeDivision _ 0 = Left &quot;Error: Attempted to divide by zero!&quot;
safeDivision x y = Right (x / y)
</code></pre>
<h1><a class="header" href="#04-via-either-errortypepurs" id="04-via-either-errortypepurs">04-Via-Either-ErrorType.purs</a></h1>
<pre><code class="language-haskell">module PartialFunctions.ViaEitherErrorType where

import Prelude

import Data.Either (Either(..))
{-
The previous file demonstrates how to use &quot;Either String a&quot; for error handling.
The problem with this approach is that the error type isn't type-safe.
In other words, why use Strings when we could define our own error types?

Creating our own error types has these benefits:
  - Less bugs / runtime errors: the program works or it fails to compile
  - Self-documenting errors: all possible errors (instances) are grouped
      under a human-readable type, not an error number that requires a lookup,
      or a String that is subject to modification

Thus, we'll define a type for our DivisionError:
-}

data DivisionError = DividedByZero

-- Then we'll make it printable to the screen
instance Show DivisionError where
  show DividedByZero = &quot;Error: you attempted to divide by zero!&quot;

-- We'll update `safeDivision` to return the error type rather than a String
safeDivision :: Int -&gt; Int -&gt; Either DivisionError Int
safeDivision _ 0 = Left DividedByZero
safeDivision x y = Right (x / y)
</code></pre>
<h1><a class="header" href="#05-via-refined-typespurs" id="05-via-refined-typespurs">05-Via-Refined-Types.purs</a></h1>
<pre><code class="language-haskell">module PartialFunctions.ViaRefinedTypes where

import Prelude

import Data.Either (Either(..))
{-
Rather than making our function take any `Int` as its second argument,
why not guarantee that the second argument is not a zero?

Thus, we can 'refine' our `Int` type using a newtype to insure
that it is non-zero:
-}

newtype NonZeroInt = NonZero Int

safeDivision :: Int -&gt; NonZeroInt -&gt; Int
safeDivision x (NonZero y) = x / y

{-
To create an instance of `NonZeroInt`, we still need to use
a function that verifies that our `Int` is really non-zero.
-}

mkNonZeroInt :: Int -&gt; Either NonZeroIntError NonZeroInt
mkNonZeroInt 0 = Left IntWasZero
mkNonZeroInt x = Right x

data NonZeroIntError = IntWasZero

-- Then we'll make it printable to the screen
instance Show NonZeroIntError where
  show IntWasZero = &quot;Error: the integer was 0.&quot;
</code></pre>
<h1><a class="header" href="#using-variant-based-errors" id="using-variant-based-errors">Using Variant-Based Errors</a></h1>
<p>See <a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html">The Problem with Typed Errors</a></p>
<h1><a class="header" href="#via-default-values" id="via-default-values">Via Default Values</a></h1>
<p>Unfortunately, the domain problem of safe division is not an example for how &quot;default value&quot; approach can convert a partial function into a total function.</p>
<p>So instead, we'll use the example of getting the first element in a linked list. In situations where the list is empty, it will throw an exception:</p>
<pre><code class="language-haskell">-- partial function
head :: List Int -&gt; Int
head Nil = -- Exception!
head (Cons head tail) = head
</code></pre>
<p>To make the function total, we can provide a value to return in such cases:</p>
<pre><code class="language-haskell">-- total function
headOrDefault :: List Int -&gt; Int -&gt; Int
headOrDefault Nil default = default -- no more exceptions!
headOrDefault (Cons head tail) _ = head
</code></pre>
<h1><a class="header" href="#what-are-phantom-types" id="what-are-phantom-types">What Are Phantom Types</a></h1>
<p>Phantom Types come in two forms:</p>
<ol>
<li>a data type without any values</li>
<li>a generic type that is declared in type's definition that is never used in its data constructors</li>
</ol>
<pre><code class="language-haskell">-- 1. ReadOnly has no values
data ReadOnly

-- 2. `unusedType` is never used in Data's data constructor
data Data unusedType = Data
</code></pre>
<h2><a class="header" href="#why-are-phantomtypes-useful" id="why-are-phantomtypes-useful">Why Are PhantomTypes Useful?</a></h2>
<p>See <a href="https://stackoverflow.com/questions/28247543/motivation-behind-phantom-types/28250226#28250226">Motivation behind Phantom Types</a> for a quick overview before looking below for some examples.</p>
<ul>
<li>Use a phantom type to restrict what a developer can do with a type
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-st/4.0.0/docs/Control.Monad.ST.Internal#t:ST">ST</a> uses a <a href="https://pursuit.purescript.org/packages/purescript-st/4.0.0/docs/Control.Monad.ST.Internal#k:Region">Region</a> type to prevent local mutation from escaping some scope.</li>
</ul>
</li>
<li>Use a phantom type to restrict how a developer can use a function
<ul>
<li>See <a href="content/31-Design-Patterns/03-Phantom-Types/./02-Restricting-Argument-Types.purs">&quot;Restricting ArgumentTypes.purs&quot;</a></li>
<li>See <a href="https://github.com/slamdata/purescript-pathy#introduction">Pathy</a>, which uses them to track the distinctions of relative/absolute file paths and of file/directory</li>
</ul>
</li>
<li>Use phantom types to estimate the state of &quot;the real world&quot; in a monadic computation:
<ul>
<li>Search for an explanation of Indexed Monads</li>
</ul>
</li>
<li>Use phantom types to &quot;save&quot; proofs
<ul>
<li>Watch <a href="https://www.youtube.com/watch?v=2cAxOJEiL00">Ghosts of Departed Proofs</a> (not the best video quality, but very interesting ideas)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#02-restricting-argument-typespurs" id="02-restricting-argument-typespurs">02-Restricting-Argument-Types.purs</a></h1>
<pre><code class="language-haskell">-- This file demonstrates how the second form of phantom types
-- can restrict us to writing better and safer code
module KeyValueProblem
  (
    Attribute
  , attribute
  ) where

newtype Attribute = Attribute { key :: String, value :: String }

-- convenience constructor
attribute :: String -&gt; String -&gt; Attribute
attribute key value = Attribute { key, value }

infix 4 attribute as :=

-- This will succesfully compile when it shouldn't, leading to problems
-- later on during runtime.
example :: Array Attribute
example =
  [ &quot;width&quot;  := &quot;not a valid number&quot;
  , &quot;height&quot; := &quot;not a valid number&quot;
  , &quot;style&quot;  := &quot;not a valid style&quot;
  ]

-- The problem is that the `width` function should specify
-- a valid type for its second parameter, one that can also be turned
-- into a String.
-- Let's show an example that doesn't use Phantom Types first
-- before showing why they are a better solution

module FirstPossibleSolution
  (
    Attribute

  , width
  , height
  , style

  , Style(..)
  ) where

newtype Attribute = Attribute { key :: String, value :: String }

-- This time, we're not going to export the smart constructor 'attribute'
-- Rather, we'll change its type signture and export wrappers around it

-- assume there are instances of Show for Int and Style
class Show a where
  show :: a -&gt; String

-- Read &quot;given a string and any value that can be turned into a string&quot;
attribute :: forall a. Show a =&gt; String -&gt; a -&gt; Attribute
attribute key value = Attribute { key: key, value: show value }

-- new smart constructor
width :: Int -&gt; Attribute
width = attribute &quot;width&quot;

-- new smart constructor
height :: Int -&gt; Attribute
height = attribute &quot;height&quot;

data Style = Normal | Bold | Italic

-- new smart constructor
style :: Style -&gt; Attribute
style = attribute &quot;style&quot;

-- This gets rid of our runtime issues, but it makes things less readable
-- as we have now lost the &quot;key := value&quot; syntax.
-- Now, we have to use a less-readible &quot;key value&quot; syntax
example :: Array Attribute
example =
  [ width 40
  , height 200
  , style Bold
  ]

-- How can we get the &quot;key := value&quot; syntax back? We want a syntax like
-- `width := 400`. To get that, attribute needs to somehow force the second
-- parameter to be a specific type based on the first parameter it receives.
--
-- This is where Phantom Types come to the rescue
module PhantomTypes
  (
    Attribute

  , width
  , height
  , style

  , Style(..)
  ) where

newtype Attribute = Attribute { key :: String, value :: String }

-- assume there are instances of Show for Int and Style
class Show a where
  show :: a -&gt; String

-- A phantom type is a type defined in the type
-- but not used in its instances / constructors
data TheType phantomType = Constructor String

-- In our case, we can write:
newtype AttributeKey desiredValueType = AttributeKey String

-- Let's update attribute to use the phantom type to restrict
-- what the second parameter can be in our function. Recall that
-- &quot;a&quot; in this situation means &quot;desired value type&quot;:
attribute :: forall a. Show a =&gt; AttributeKey a -&gt; a -&gt; Attribute
attribute (AttributeKey key) value =
  Attribute { key: key, value: show value }

infix 4 attribute as :=

-- Now, we can update width's type signature to force its
-- expected argument to be an int
width :: AttributeKey Int
width = AttributeKey &quot;width&quot;

height :: AttributeKey Int
height = AttributeKey &quot;height&quot;

data Style = Normal | Bold | Italic
-- and the same for style
style :: AttributeKey Style
style = AttributeKey &quot;style&quot;

-- Alright!
example :: Array Attribute
example =
  [ width  := 40
  , height := 200
  , style  := Bold
  ]
</code></pre>
<h1><a class="header" href="#records-use-type-data-or-newtype" id="records-use-type-data-or-newtype">Records: Use Type, Data, or Newtype?</a></h1>
<p>Short answer: use <code>type</code></p>
<p><strong>Type:</strong> ideal, but defining typeclass instances on it requires defining it for all records, which is usually not what you want.</p>
<pre><code class="language-haskell">type TypedRecord = { anInt :: Int }
</code></pre>
<p><strong>Newtype:</strong> use if you need a type class instance and you only need to wrap a single record</p>
<pre><code class="language-haskell">newtype NewtypedRecord = NR { anInt :: Int }
</code></pre>
<p><strong>Data:</strong> use if you need a type class instance and you need to wrap a record AND something else. Unfortunately, this will perform unboxing during runtime.</p>
<pre><code class="language-haskell">data DataRecord = DR { anInt :: Int } { aString :: String }
</code></pre>
<h1><a class="header" href="#a-better-todo" id="a-better-todo">A Better TODO</a></h1>
<p>Many times, when we are modeling an application's domain, we are focusing on the type signatures for the function's we'll need instead of how we'll implement them. Thus, we might end up writing something like this:</p>
<pre><code class="language-haskell">-- TODO: implement this later
someFunctionName :: Int -&gt; Int -&gt; SpecialDomainType
someFunctionName _ = unsafeCoerce
</code></pre>
<p>It might be better to output a compiler warning at the type-level and throw an exception at the value-level:</p>
<pre><code class="language-haskell">someFunctionName :: Warn (Text &quot;Implement someFunctionName later&quot;) =&gt;
                    Int -&gt; Int -&gt; SpecialDomainType
someFunctionName _ = unsafeThrow &quot;Implement someFunctionName later&quot;
</code></pre>
<p><a href="https://pursuit.purescript.org/packages/purescript-exceptions/4.0.0/docs/Effect.Exception.Unsafe#v:unsafeThrow">unsafeThrow</a> is found in the <code>purescript-exceptions</code> package.</p>
<h1><a class="header" href="#boolean-blindness" id="boolean-blindness">Boolean Blindness</a></h1>
<p>Watch <a href="https://www.youtube.com/watch?v=xR9ayZ5c4JA">Stephen Pimentel- Boolean Blindness Explained for Beginners in Haskell- C 2019</a></p>
<h1><a class="header" href="#fairbairn-threshold" id="fairbairn-threshold">Fairbairn Threshold</a></h1>
<blockquote>
<p>The Fairbairn threshold is the point at which the effort of looking up or keeping track of the definition is outweighed by the effort of rederiving it or inlining it. (Source: https://wiki.haskell.org/Fairbairn_threshold)</p>
</blockquote>
<p>Or, why it's not worth it to try to reduce boilerplate by naming every possible variation of something.</p>
<pre><code class="language-haskell">-- This is more modular and can easily be adjusted when things change
          map (_ + 1)               (Just 4)   == 5
     map (map (_ + 1))        (Just (Just 4))  == 5
map (map (map (_ + 1))) (Just (Just (Just 4))) == 5

-- Rather than these variations, which aren't worth the work of looking up later
-- because the implementation can readily be rewritten/inlined
map1 f =           map f
map2 f =      map (map f)
map3 f = map (map (map f))
</code></pre>
<h1><a class="header" href="#keyword-argument-pattern" id="keyword-argument-pattern">Keyword Argument Pattern</a></h1>
<p>This is used in a number of libraries throughout PureScript. For example:</p>
<ul>
<li>Halogen's <code>H.defaultEval</code> value</li>
<li>node-child-process's <code>pipe</code> value</li>
<li>Affjax's <code>defaultRequest</code> value</li>
</ul>
<p>The basic idea is that the library author provides a record that stores default values that do nothing, so that end-users can override only the values they need in a record update:</p>
<pre><code class="language-purescript">-- Library author writes this...

type Options =
  { directory :: String
  , port :: Int
  , logLevel :: LogLevel
  }

defaultOptions :: Options
defaultOptions =
  { directory: &quot;.&quot;
  , port: 8080
  , logLevel: Error
  }

-- User overrides where they need it
foo :: Effect Unit
foo = do
  doSomethingWith $ defaultOptions { port = 2020 }
  doSomethingWith $ defaultOptions { directory = &quot;app/&quot;, logLevel: Warn }
</code></pre>
<p>See <a href="https://www.kovach.me/Superpowered_keyword_args_in_Haskell.html">Superpowered keyword args in Haskell - Ben Kovach</a></p>
<h1><a class="header" href="#project-prelude" id="project-prelude">Project Prelude</a></h1>
<p>If you ever find yourself thinking, &quot;I wish <code>&lt;ModuleName&gt;</code> was in <code>Prelude</code>,&quot; or &quot;I wish I didn't have to import <code>&lt;ModuleName&gt;</code> in each PureScript file,&quot; this design pattern is for you.</p>
<p>PureScript files can often have a lot of lines for just the import statements. While it makes it easier to see which function is being used in a given file, it can be tedious to import everything, even with tooling that enables auto-importing.</p>
<p>However, most projects and applications will define a project-specific Prelude to be used just in that project. Rather than typing something like this in each of your files:</p>
<pre><code class="language-purescript">import Prelude

import Effect (Effect)
import Effect.Class (class MonadEffect, liftEffect)
import Effect.Aff (Aff, launchAff_)
import Effect.Aff.Class (class MonadAff, liftAff)
import Control.Monad.Reader.Class (class MonadReader, ask, local)
import Control.Monad.State.Class (class MonadState, get, put, modify_)
import Data.Array ((:), (!!))
import Data.Bifunctor (class Bifunctor, bimap, lmap, rmap)
import Data.Maybe (Maybe(..), maybe, fromJust)
import Data.Newtype (class Newtype, un)
import Data.Generic.Rep (class Generic)
import Data.Either (Either(..), either, fromLeft, fromRight)
import Data.Foldable (foldl, fold, foldr, any, all, sum, product, foldM, for_, traverse_)
import Data.Traversable (for, traverse, scanl, scanr)

-- actual code below this
</code></pre>
<p>You might type this in your file:</p>
<pre><code class="language-purescript">import AppPrelude

-- actual code below this
</code></pre>
<p>where <code>AppPrelude.purs</code> looks like this:</p>
<pre><code class="language-purescript">module AppPrelude (module Exports) where

-- Export the things we care about
import Effect (Effect) as Exports
import Effect.Class (class MonadEffect, liftEffect) as Exports
import Effect.Aff (Aff, launchAff_) as Exports
import Effect.Aff.Class (class MonadAff, liftAff) as Exports
import Control.Monad.Reader.Class (class MonadReader, ask, local) as Exports
import Control.Monad.State.Class (class MonadState, get, put, modify_) as Exports
import Data.Array ((:), (!!)) as Exports
import Data.Bifunctor (class Bifunctor, bimap, lmap, rmap) as Exports
import Data.Maybe (Maybe(..), maybe, fromJust) as Exports
import Data.Newtype (class Newtype, un) as Exports
import Data.Generic.Rep (class Generic) as Exports
import Data.Either (Either(..), either, fromLeft, fromRight) as Exports
import Data.Foldable (foldl, fold, foldr, any, all, sum, product, foldM, for_, traverse_) as Exports
import Data.Traversable (for, traverse, scanl, scanr) as Exports

-- Re-export what the Prelude module (as of prelude v4.1.1) rexports:
https://github.com/purescript/purescript-prelude/blob/v4.1.1/src/Prelude.purs
import Control.Applicative (class Applicative, pure, liftA1, unless, when) as Exports
import Control.Apply (class Apply, apply, (*&gt;), (&lt;*), (&lt;*&gt;)) as Exports
import Control.Bind (class Bind, bind, class Discard, discard, ifM, join, (&lt;=&lt;), (=&lt;&lt;), (&gt;=&gt;), (&gt;&gt;=)) as Exports
import Control.Category (class Category, identity) as Exports
import Control.Monad (class Monad, ap, liftM1, unlessM, whenM) as Exports
import Control.Semigroupoid (class Semigroupoid, compose, (&lt;&lt;&lt;), (&gt;&gt;&gt;)) as Exports

import Data.Boolean (otherwise) as Exports
import Data.BooleanAlgebra (class BooleanAlgebra) as Exports
import Data.Bounded (class Bounded, bottom, top) as Exports
import Data.CommutativeRing (class CommutativeRing) as Exports
import Data.DivisionRing (class DivisionRing, recip) as Exports
import Data.Eq (class Eq, eq, notEq, (/=), (==)) as Exports
import Data.EuclideanRing (class EuclideanRing, degree, div, mod, (/), gcd, lcm) as Exports
import Data.Field (class Field) as Exports
import Data.Function (const, flip, ($), (#)) as Exports
import Data.Functor (class Functor, flap, map, void, ($&gt;), (&lt;#&gt;), (&lt;$), (&lt;$&gt;), (&lt;@&gt;)) as Exports
import Data.HeytingAlgebra (class HeytingAlgebra, conj, disj, not, (&amp;&amp;), (||)) as Exports
import Data.Monoid (class Monoid, mempty) as Exports
import Data.NaturalTransformation (type (~&gt;)) as Exports
import Data.Ord (class Ord, compare, (&lt;), (&lt;=), (&gt;), (&gt;=), comparing, min, max, clamp, between) as Exports
import Data.Ordering (Ordering(..)) as Exports
import Data.Ring (class Ring, negate, sub, (-)) as Exports
import Data.Semigroup (class Semigroup, append, (&lt;&gt;)) as Exports
import Data.Semiring (class Semiring, add, mul, one, zero, (*), (+)) as Exports
import Data.Show (class Show, show) as Exports
import Data.Unit (Unit, unit) as Exports
import Data.Void (Void, absurd) as Exports
</code></pre>
<h1><a class="header" href="#internal-modules" id="internal-modules">Internal Modules</a></h1>
<p>Modules that end with <code>Internal</code> are modules that one shouldn't use in most cases. They tend to provide access to the &quot;guts&quot; of things without the same guarantees or safety as non-<code>Internal</code>modules. However, they can be necessary when one module needs access to something (e.g. for performance reasons) that must exist in another module.</p>
<p>See these links for more info:</p>
<ul>
<li><a href="https://stackoverflow.com/a/9191622">SO answer</a></li>
<li><a href="https://stackoverflow.com/a/9198453">SO answer</a></li>
<li><a href="https://github.com/purescript/purescript-strings/pull/130">PR concerning the <code>NonEmptyString</code> constructor being exposed</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/b4n87p/what_to_make_internal/">Reddit thread</a></li>
</ul>
<h1><a class="header" href="#generics" id="generics">Generics</a></h1>
<p>Have you ever written boilerplate when implementing an instance for a type class (e.g. <code>Show</code>) and thought, &quot;Surely, there must be a better/faster way!&quot; Generics is the answer to your problems.</p>
<p>Here's the basic idea behind Generics:</p>
<ol>
<li>You, the end developer, define a data type in your application and use the compiler to derive a <code>Generic</code> type class instance.</li>
<li>A library developer defines a function that can implement an instance for a given type class (e.g. <code>Show</code>, <code>BoundedEnum</code>, etc.) for all possible types.</li>
<li>You use the library developer's function to implement your data type's instance for a type class.</li>
</ol>
<p>Great! So how does it work?</p>
<p>The compiler can define two functions, <code>to</code> and <code>from</code>. <code>to</code> converts your data type (i.e. <code>MyType</code>) to a new data type (let's say <code>CompilerRepresentationType</code> for lack of a better name) that has a different structure than your data type but stores the same information. <code>from</code> converts a value of <code>CompilerRepresentationType</code> back into a value of <code>MyType</code>.
These two functions abide by one law: <code>(from (to myDataTypeValue)) == myDataTypeValue</code></p>
<p>The library developer writes a function that can implement an instance for the desired type class (e.g. <code>Show</code>, <code>BoundedEnum</code>) that works on <code>CompilerRepresentationType</code>. Generics works by first converting your data type into <code>CompilerRepresentationType</code>, then uses the library developer's function to implement the instance, and then converts the resulting value of the <code>CompilerRepresentationType</code> type back into your original type (i.e. <code>MyType</code>).</p>
<p>Put visually, read things from left to right as a timeline of events:</p>
<pre><code>MyType --&gt; CompilerRepresentationType ==&gt; CompilerRepresentationType ~~&gt; MyType
</code></pre>
<p>where
<code>--&gt;</code> is where the compiler converts your type into the &quot;same-info, different structure&quot; type via the derived <code>to</code> function from the <code>Generic</code> type class
<code>==&gt;</code> is the library developer's function that implements the instance
<code>~~&gt;</code> is where the compiler converts the &quot;same-info, different structure&quot; type back into your type via the derived <code>from</code> function from the <code>Generic</code> type class</p>
<p>To understand how the compiler produces <code>CompilerRepresentationType</code> and how the library developer writes their function, read <a href="https://harry.garrood.me/blog/write-your-own-generics/">@hdgarrood's &quot;Making full use of PureScript's Generic type class&quot;</a></p>
<h1><a class="header" href="#stack-safety" id="stack-safety">Stack Safety</a></h1>
<h2><a class="header" href="#an-example-of-stack-unsafe-code" id="an-example-of-stack-unsafe-code">An Example of Stack-Unsafe Code</a></h2>
<p>In FP, we often use recursive functions to solve problems:</p>
<ul>
<li>changing all elements in a container-like type (e.g. <code>List</code>, <code>Tree</code>, <code>Array</code>, etc.) from one thing to another</li>
<li>running some computation and, if it fails, retrying it again until it succeeds</li>
</ul>
<p>For example, the below <code>factorial</code> function calculates its result by calling itself recursively.</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n = n * (factorial (n - 1))
</code></pre>
<p>However, this design choice comes with an annoying problem: stack-safety. While this recursive function will theoretically always &quot;return,&quot; the number of stacks it takes depends on its input. Unfortunately, computers have limited resources and cannot always provide the total number of stacks such a function needs. If we call <code>factorial</code> with a &quot;large&quot; enough input (e.g. <code>99999</code>), the computer will &quot;blow the stack&quot; and produce a StackOverflow runtime error.</p>
<p>So, how do we prevent this?</p>
<h2><a class="header" href="#tail-call-optimization-for-pure-functions-via-the-last-branch" id="tail-call-optimization-for-pure-functions-via-the-last-branch">Tail-Call Optimization for Pure Functions via the Last Branch</a></h2>
<p>Our first defense against this is &quot;tail-call optimization.&quot; In short, we indicate that a recursive function should be converted into a stack-friendly <code>while</code> loop. When writing simple recursive functions, we can trigger the tail-call optimization only if we call the function recursively in the final &quot;branch.&quot; For example, if we rewrote the above computation to store the &quot;accumulated value&quot; as another argument to the function, then we could call the function recursively in the last branch:</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n = go n 1
  where
  go :: StartingInt -&gt; AccumulatedInt -&gt; AccumulatedInt
  go 1 finalResult = finalResult
  go loopsRemaining accumulatedSoFar =
    go (loopsRemaining - 1) (loopsRemaining * accumulatedSoFar)
</code></pre>
<p>If we called <code>factorial 4</code>, this is how the code would execute where each line is another loop in the <code>while</code> loop:</p>
<pre><code>go 4 1
go (4 - 1) (4 * 1)
go (4 - 1 - 1) (3 * 4 * 1)
go (4 - 1 - 1 - 1) (2 * 3 * 4 * 1)
go (4 - 1 - 1 - 1 - 1) (1 * 2 * 3 * 4 * 1)
go (1) (24)
24
</code></pre>
<h2><a class="header" href="#tail-call-optimization-for-pure-functions-via-multiple-branches" id="tail-call-optimization-for-pure-functions-via-multiple-branches">Tail-Call Optimization for Pure Functions via Multiple Branches</a></h2>
<p>The above recursive function is stack-safe only because the recursion occurs once in the last pattern match branch. However, what if we had multiple branches where we needed to call it recursively? In such situations, the tail-call optimization won't be triggered.</p>
<p>Recursive functions always have a &quot;base case&quot; that ends the recursion and a &quot;recursive case&quot; that continues it. In PureScript, we use a special function called <a href="https://pursuit.purescript.org/packages/purescript-tailrec/4.0.0/docs/Control.Monad.Rec.Class#v:tailRec"><code>tailRec</code></a> alongside of a data type called <code>Step</code> to achieve stack-safety at the cost of some performance. <code>Step</code> indicates whether our function has finished (base case) or needs to continue looping (recursive case):</p>
<pre><code class="language-haskell">data Step accumulatedValue finalValue
  -- recursive case: keep looping
  = Loop accumulatedValue
  -- base case: we're done; it's time to return a value
  | Done finalValue
</code></pre>
<p>Here is our previous stack-safe <code>factorial</code> function:</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n = go n 1
  where
  go :: StartingInt -&gt; AccumulatedInt -&gt; AccumulatedInt
  go 1 finalResult = finalResult
  go loopsRemaining accumulatedSoFar =
    go (loopsRemaining - 1) (loopsRemaining * accumulatedSoFar)
</code></pre>
<p>Here is the same implementation via <code>tailRec</code>:</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n = tailRec go { loopsRemaining: n, accumulatedSoFar: 1 }
  where
  go ::      { loopsRemaining :: Int, accumulatedSoFar :: Int }
     -&gt; Step { loopsRemaining :: Int, accumulatedSoFar :: Int } Int
  go { loopsRemaining: 1,         accumulatedSoFar: acc } = Done acc
  go { loopsRemaining: remaining, accumulatedSoFar: acc } =
    Loop { loopsRemaining: remaining - 1, accumulatedSoFar: remaining * acc }
</code></pre>
<p>Let's write the same function but utilize more branches without losing stack-safety. In the below example, if one calls <code>factorial 1</code>, <code>factorial 2</code>, or <code>factorial 3</code>, the function will return in one &quot;loop.&quot; If one calls <code>factorial n</code> where <code>n</code> is greater than 3, the function will return in 2 less loops than our previous implementation at the cost of more checks per loop:</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n = tailRec go { loopsRemaining: n, accumulatedSoFar: 1 }
  where
  go ::      { loopsRemaining :: Int, accumulatedSoFar :: Int }
     -&gt; Step { loopsRemaining :: Int, accumulatedSoFar :: Int } Int
  go { loopsRemaining: 1,         accumulatedSoFar: acc } = Done acc
  go { loopsRemaining: 2,         accumulatedSoFar: acc } = Done (2 * acc)
  go { loopsRemaining: 3,         accumulatedSoFar: acc } = Done (6 * acc)
  go { loopsRemaining: remaining, accumulatedSoFar: acc } =
    Loop { loopsRemaining: remaining - 1, accumulatedSoFar: remaining * acc }
</code></pre>
<h2><a class="header" href="#tail-call-optimization-for-monadic-computations" id="tail-call-optimization-for-monadic-computations">Tail-Call Optimization for Monadic Computations</a></h2>
<p>But what happens when we need to run a side-effectful monadic computation recursively? For example, let's say we wanted to print the same message to the console a specific number of times and then stop:</p>
<pre><code class="language-haskell">printMessageAndLoop :: Int -&gt; Effect Unit
printMessageAndLoop 0 = pure unit
printMessageAndLoop loopsRemaining = do
  log &quot;Printing a message to the console!&quot;
  printMessageAndLoop (loopsRemaining - 1)

main :: Effect Unit
main = printMessageAndLoop 10000
</code></pre>
<p>Fortunately, we can use the <a href="https://pursuit.purescript.org/packages/purescript-tailrec/4.0.0/docs/Control.Monad.Rec.Class#t:MonadRec"><code>MonadRec</code> type class' <code>tailRecM</code> function</a>.</p>
<p>The only change from above is that now we wrap the returned <code>Step</code> data type in the monadic type.</p>
<p>In other words:</p>
<pre><code class="language-haskell">tailRec  go initialValue
  where
  go ::             Accumulator
     -&gt;        Step Accumulator Output

-- now becomes
tailRecM go initialValue
  where
  go ::             Accumulator
     -&gt; monad (Step Accumulator Output)
</code></pre>
<p>Once again, our original stack-unsafe code:</p>
<pre><code class="language-haskell">printMessageAndLoop :: Effect Unit
printMessageAndLoop 0 = pure unit
printMessageAndLoop loopsRemaining = do
  log &quot;Printing a message to the console!&quot;
  printMessageAndLoop (loopsRemaining - 1)

main :: Effect Unit
main = printMessageAndLoop 10000
</code></pre>
<p>Now our modified stack-safe code:</p>
<pre><code class="language-haskell">printMessageAndLoop ::              { loopsRemaining :: Int }
                    -&gt; Effect (Step { loopsRemaining :: Int } Unit )
printMessageAndLoop 0 = pure (Done unit)
printMessageAndLoop { loopsRemaining } = do
  log &quot;Printing a message to the console!&quot;
  pure (Loop { loopsRemaining: loopsRemaining - 1 })

main :: Effect Unit
main = tailRecM printMessageAndLoop { loopsRemaining: 10000 }
</code></pre>
<h3><a class="header" href="#using-purescript-safely" id="using-purescript-safely">Using <code>PureScript-Safely</code></a></h3>
<p>Let's say you wrote some recursive code and then later realized that it's not stack-safe. Let's also say that you have to use <code>MonadRec</code> to make it stack-safe. If you want to make the code stack-safe without modifying it, you could use the <a href="https://pursuit.purescript.org/packages/purescript-safely/4.0.0"><code>purescript-safely</code></a> library.</p>
<p>As <code>@hdgarrood</code> points out:</p>
<blockquote>
<p>The benefit is that you can take existing code which uses monadic recursion in a potentially stack-unsafe way and have it work without having to modify that code. (<a href="https://discourse.purescript.org/t/how-to-avoid-stack-overflow-with-monads/1209/13">source</a>)</p>
</blockquote>
<p>For example, see <a href="https://pursuit.purescript.org/packages/purescript-safely/4.0.0/docs/Control.Safely#v:safely">safely</a>.</p>
<p>However, this comes with a tradeoff. <code>@hdgarrood</code> also states:</p>
<blockquote>
<p>[purescript-safely] is probably one of the simplest ways of making a recursive monadic computation stack-safe, but probably has some of the highest overheads too. (<a href="https://discourse.purescript.org/t/how-to-avoid-stack-overflow-with-monads/1209/8">source</a>)</p>
</blockquote>
<h3><a class="header" href="#three-caveats-of-using-tailrecm" id="three-caveats-of-using-tailrecm">Three Caveats of Using <code>tailRecM</code></a></h3>
<p>There are two main drawbacks to <code>MonadRec</code>:</p>
<ul>
<li>Performance: there's additional overhead because we have to box and unbox the <code>Loop</code>/<code>Done</code> data constructors</li>
<li>Support: as <code>MonadRec</code>'s documentation implies, not all monadic types support tail-call optimization. Only some monadic types can do this.</li>
</ul>
<p>The third caveat is that <code>tailRecM</code> isn't always heap-safe. Responding to another's question on the FP Slack channel:</p>
<blockquote>
<p>the <code>tailRecM</code> basically moves the stack usage you'd usually get for recursion onto the heap. If you use too much, you run out of heapspace. I'd suggest taking a heap snapshot before [your code] explodes (I think there's an <code>--inspect</code> flag for node) and seeing what's taking up that space.
If it's the JSON structure you're building up, you'll need to write it out in chunks, so you can free up some memory for your process. Or if it's the <code>tailRecM</code> allocations, you can look into not using <code>tailRecM</code> and using <code>Ref</code>s + <code>whileE</code>/<code>forE</code> to write <code>Effect</code> code that doesn't hold on to thunks.</p>
</blockquote>
<p>We'll cover the <code>Ref</code>s + <code>whileE</code>/<code>forE</code> in a later section.</p>
<h2><a class="header" href="#use-trampoline" id="use-trampoline">Use <code>Trampoline</code></a></h2>
<p>Another solution is to use laziness. <strong>Note: this approach still trades stack for heap and is possibly head-unsafe.</strong></p>
<p>You'll &quot;suspend&quot; the computation in a &quot;thunk&quot; (i.e. <code>let thunk = \_ -&gt; valueWeNeed</code>) that we can later evaluate by &quot;forcing the thunk&quot; (i.e. <code>thunk unit</code>). Such a solution is provided via <a href="https://pursuit.purescript.org/packages/purescript-free/5.2.0/docs/Control.Monad.Trampoline#t:Trampoline"><code>Trampoline</code></a></p>
<p>Putting it into more familiar terms:</p>
<table><thead><tr><th><code>Step a b</code> data constructor</th><th><code>Trampoline</code>'s corresponding function</th></tr></thead><tbody>
<tr><td><code>Done finalValue</code></td><td><code>done finalValue</code></td></tr>
<tr><td><code>Loop accumulator</code></td><td><code>delay \_ -&gt; accumulator</code></td></tr>
</tbody></table>
<p>Similarly, <code>tailRecM</code> corresponds to <code>runTrampoline</code>.</p>
<h2><a class="header" href="#use-mutable-state-refs-and-whileeuntilefore" id="use-mutable-state-refs-and-whileeuntilefore">Use Mutable State (<code>Ref</code>s) and <code>whileE</code>/<code>untilE</code>/<code>forE</code></a></h2>
<p>As the previous comment suggested, you might want to call a spade a spade and just admit that you need to use mutable state. In such a situation, look at...</p>
<ul>
<li>the <a href="https://pursuit.purescript.org/packages/purescript-refs/4.1.0/docs/Effect.Ref#t:Ref"><code>Ref</code></a> type and its related functions</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-effect/2.0.1/docs/Effect#v:whileE"><code>whileE</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-effect/2.0.1/docs/Effect#v:untilE"><code>untilE</code></a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-effect/2.0.1/docs/Effect#v:forE"><code>forE</code></a></li>
</ul>
<h2><a class="header" href="#a-note-on-aff" id="a-note-on-aff">A Note on <code>Aff</code></a></h2>
<p><code>Aff</code> is stack-safe by default. So, we don't need to pay for the overhead of <code>Step</code>.</p>
<h1><a class="header" href="#applicative-data-validation" id="applicative-data-validation">Applicative Data Validation</a></h1>
<p>Or how to validate data using Applicatives.</p>
<p>The following provides a quicker summary of the <a href="https://book.purescript.org/chapter7.html">same chapter in Purescript By Example</a>. However, one should read the chapter if they are not already familiar with this concept.</p>
<h2><a class="header" href="#possible-choices" id="possible-choices">Possible Choices</a></h2>
<p>Data Validation usually &quot;returns&quot; two of four values:</p>
<ol>
<li>the validated data</li>
<li>the first error encountered, whether or not the yet-to-be-validated data after it was valid or not, and...
<ul>
<li>a) ... we don't care what the error was</li>
<li>b) ... we do care what the error was</li>
</ul>
</li>
<li>all the errors encountered after attempting to validate all parts of the data</li>
</ol>
<p>Which Applicative type we use depends on what which of the two values we want:</p>
<table><thead><tr><th>What we want</th><th>What we use</th></tr></thead><tbody>
<tr><td>1 &amp; 2a</td><td>Maybe</td></tr>
<tr><td>1 &amp; 2b</td><td>Either</td></tr>
<tr><td>1 &amp; 3</td><td><a href="https://pursuit.purescript.org/packages/purescript-validation/4.0.0/docs/Data.Validation.Semigroup#t:V"><code>V</code></a></td></tr>
</tbody></table>
<p>The difference between <code>Either</code> and <code>V</code> is their implementation of <code>Apply</code>. Either's <a href="https://github.com/purescript/purescript-either/blob/v4.0.0/src/Data/Either.purs#L44-L78"><code>apply</code></a> does not combine two errors together via a <code>Semigroup</code> constraint like <code>V</code>'s <a href="https://github.com/purescript/purescript-either/blob/v4.0.0/src/Data/Either.purs#L44-L78"><code>apply</code></a></p>
<h2><a class="header" href="#the-pattern" id="the-pattern">The Pattern</a></h2>
<p>To validate data, it follows this idea:</p>
<pre><code class="language-haskell">mkData :: forall a b. a -&gt; a -&gt; b
mkData arg1 arg2 = B_Constructor arg1 arg2

isValidM :: Arg -&gt; Maybe Unit
isValidM invalidArg = Nothing
isValidM validArg = pure unit

isValidE :: Arg -&gt; Either Error Unit
isValidE invalidArg = Left Error
isValidE validArg = pure unit

isValidV :: Arg -&gt; V (Array Error) Unit
isValidV invalidArg = V $ Left Error
isValidV validArg = pure unit

validateData :: Args -&gt; Maybe ValidData
validateData :: Args -&gt; Either Error ValidData
validateData :: Args -&gt; V (Array Error) ValidData
validateData a =
  mkData &lt;$&gt; (isValid a.arg1 *&gt; pure a.arg1)
         &lt;*&gt; (isValid a.arg2 *&gt; pure a.arg2)
    --   &lt;*&gt; (isValid a.argN *&gt; pure a.argN)
</code></pre>
<hr>
<p>I'm not sure how useful this will be, but I thought I'd put it here:
<a href="https://ro-che.info/articles/2019-03-02-lazy-validation-applicative">Lazy Validation</a></p>
<h1><a class="header" href="#parsing" id="parsing">Parsing</a></h1>
<p>This file will store various links related to parsing.</p>
<h2><a class="header" href="#regular-expressions-and-why-fpers-dont-use-them" id="regular-expressions-and-why-fpers-dont-use-them">Regular Expressions and why FPers don't use them</a></h2>
<p>Regular Expressions are infamous for being hard to read, hard to write, and hard to document. Parser combinators provide a solution to the same goals of regular expressions. They sacrifice a small amount of performance to be much easier to read, write, and document.</p>
<h2><a class="header" href="#left-recursion-problem" id="left-recursion-problem">Left Recursion Problem</a></h2>
<p>See https://github.com/glebec/left-recursion for a clear explanation of this problem and its solution</p>
<h1><a class="header" href="#serialization-via-codecs" id="serialization-via-codecs">Serialization via Codecs</a></h1>
<p>There are generally two ways to do serialization in FP languages</p>
<ol>
<li>Use type classes (e.g. <code>purescript-argonaut-*</code> / <code>simple-json</code>)</li>
<li>Use handwritten profunctor-based code (e.g. <code>purescript-codec-*</code>)</li>
</ol>
<p>Of the two approaches, I prefer the second one, largely because of the reasons explained in <a href="http://code.slipthrough.net/2018/03/13/thoughts-on-typeclass-codecs/">Thoughts on Type Class Codecs</a>.</p>
<h1><a class="header" href="#zipper" id="zipper">Zipper</a></h1>
<h2><a class="header" href="#the-problem-3" id="the-problem-3">The Problem</a></h2>
<p>Examples of this problem are easier to explain than providing an initial definition:</p>
<ul>
<li>a way to track a player's position in a maze and efficiently update this position to a new valid position. Updating the position to an invalid position should be illegal.</li>
<li>a way to navigate through a computer's file system by changing directories, one directory at a time. Moreover, we should be able to rename a directory efficiently.</li>
</ul>
<p>In other words, one needs to be able to do a few things:</p>
<ul>
<li>store the current &quot;position&quot;</li>
<li>modify the current &quot;position&quot;</li>
<li>change the current &quot;position&quot; to some other &quot;position&quot; by following some &quot;path&quot;</li>
<li>do this efficiently and with an API that prevents invalid positions.</li>
</ul>
<h2><a class="header" href="#the-solution-2" id="the-solution-2">The Solution</a></h2>
<p>This solution is called the <code>Zipper</code>.</p>
<p>There are libraries the implement this for variuos types. Reading through the code can help you understand it pretty quickly:</p>
<table><thead><tr><th>Type</th><th>Library</th></tr></thead><tbody>
<tr><td><code>List</code></td><td><a href="https://github.com/paluh/purescript-pointed-list">purescript-pointed-list</a></td></tr>
</tbody></table>
<p>For an non-code explanation on this concept, see these links:</p>
<ul>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Zippers">Haskell Wikibook's explanation</a>, which includes pictures to help understand how this idea in general works.</li>
<li><a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">The original paper</a></li>
<li><a href="http://learnyouahaskell.com/zippers">Learn You a Haskell for Great Good</a>'s explanation</li>
<li><a href="https://wiki.haskell.org/Zipper">The Haskell Wiki's article on it</a>, which includes a large number of additional resources</li>
</ul>
<h3><a class="header" href="#cursors" id="cursors">Cursors</a></h3>
<p>Cursors are one such application of this concept. See this <a href="https://cs-syd.eu/posts/2018-10-28-cursor-list">post</a> that clearly explains the problem and solution it solves.</p>
<p>Then, see my conclusion to an exploration of defining a cursor-based data structure that supports multiple carets/selections <a href="https://gist.github.com/JordanMartinez/526c5b09b33ffe97932d7990b0470043#file-multi-caret-selection-textcontent-purs-L381">here</a> with the full exploration <a href="https://gist.github.com/JordanMartinez/526c5b09b33ffe97932d7990b0470043">here</a></p>
<h1><a class="header" href="#optics" id="optics">Optics</a></h1>
<p>To understand what problem optics solve and why they are an essential tool in the FP toolbox, read Thomas Honeyman's <a href="https://thomashoneyman.com/articles/practical-profunctor-lenses-optics/">Practical Profunctor Lenses &amp; Optics in PureScript</a>.</p>
<p>To learn how to use lenses...</p>
<ul>
<li>with an explanation behind how it works, read <a href="https://leanpub.com/optics-by-example/">Optics by Example</a>. Although the language used is Haskell, much of it will transfer over. I'd recommend this book over the below one, which came out earlier.</li>
<li>without much explanation behind how it works, read <a href="https://leanpub.com/lenses">Lenses for the Mere Mortal: Purescript Edition</a>.</li>
</ul>
<p>Below are other resources that are more reference material than clear explanations to beginners:</p>
<ul>
<li><a href="http://oleg.fi/gists/posts/2017-04-18-glassery.html">Oleg's Glassery post</a></li>
<li>The <a href="https://docs.racket-lang.org/lens/index.html">Racket Programming Languages's Lenses Guide</a>.</li>
<li><a href="https://cs.ttu.ee/events/nwpt2019/abstracts/paper14.pdf">Profunctor Optics, a Categorical Update (Extended Abstract)</a></li>
</ul>
<h2><a class="header" href="#lenses" id="lenses">Lenses</a></h2>
<p><strong>Note: due to Thomas' above blog post, the below section will be removed in the next major release.</strong></p>
<p>Since FP data types cannot be subclassed like OO data types, one will often define a shared component and then define its 'subclasses' as having that shared component:</p>
<pre><code class="language-haskell">type Shape = { fill :: Color }
type Square = { width :: Number
              , height :: Number
              , shape :: Shape
              }
type Circle = { radius :: Number
              , shape :: Shape
              }
</code></pre>
<p>As a result, when we wish to update the <code>shape</code> part of a Square or Circle, we need to deal with all that nesting:</p>
<pre><code class="language-haskell">-- for example...
user.config.personal.privacy.email { isPublic = false }
</code></pre>
<p>This leads to a lot of boilerplate but the concept is easily abstracted into Lenses.</p>
<h1><a class="header" href="#recursion-schemes" id="recursion-schemes">Recursion Schemes</a></h1>
<p>See <a href="http://comonad.com/reader/2009/recursion-schemes/">Edward Kmett's &quot;Recursion Schemes: A Field Guide&quot;</a> for a more-readable definition of the &quot;xxx-morphism&quot; terminology (e.g. hylomorphism).</p>
<p>See <a href="https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/">Introduction to Recursion Schemes</a>, a 4-part series that very clearly explains how they work and what they are. Papers referenced are below:</p>
<ul>
<li><a href="https://research.utwente.nl/en/publications/functional-programming-with-bananas-lenses-envelopes-and-barbed-w">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a></li>
<li><a href="http://cs.ioc.ee/%7Etarmo/papers/inf99.pdf">Primitive (Co)Recursion and Course-of-Value(Co)Iteration, Categorically</a></li>
</ul>
<p>See <a href="https://recursion-schemes-by-example.chrispenner.ca/articles/recursive/basic-catamorphisms">Basic Catamorphisms</a>
See <a href="https://recursion-schemes-by-example.chrispenner.ca/articles/recursive/f-algebras">F-Algebras</a></p>
<p>See <a href="https://github.com/vil1/recursion-schemes-cookbook">Recursion Scheme Cookbook</a>, a documentation project that helps explain SlamData's <a href="https://github.com/slamdata/purescript-matryoshka">Matyroshka (purescript)</a> library.</p>
<h1><a class="header" href="#defunctionalization" id="defunctionalization">Defunctionalization</a></h1>
<p>Or converting recursive stack-unsafe code into stack-safe code</p>
<p>See these resources:</p>
<ul>
<li><a href="https://www.joachim-breitner.de/blog/778-Don%E2%80%99t_think%2C_just_defunctionalize">Don't Think, Just Defunctionalize</a></li>
<li><a href="https://blog.poisson.chat/posts/2019-10-26-reasonable-continuations.html">The reasonable effectivness of the ConT monad</a></li>
<li><a href="https://web.archive.org/web/20201107223338/http://www.pathsensitive.com/2019/07/the-best-refactoring-youve-never-heard.html">The best refactoring you've never heard of</a></li>
</ul>
<h1><a class="header" href="#church-encoding" id="church-encoding">Church Encoding</a></h1>
<p>See these links:</p>
<ul>
<li><a href="https://programmable.computer/posts/church_encoding.html">Scrap Your Constructors: Church Encoding Algebraic Types</a></li>
<li><a href="https://www.haskellforall.com/2021/01/the-visitor-pattern-is-essentially-same.html">The visitor pattern is essentially the same thing as Church encoding </a></li>
</ul>
<h1><a class="header" href="#gadts" id="gadts">GADTs</a></h1>
<p>GADTs or Generalized Algebraic Data Types have already been explained elsewhere:</p>
<ul>
<li><a href="https://www.cs.ox.ac.uk/files/3060/gadtless.pdf">The Original Paper</a></li>
<li><a href="http://code.slipthrough.net/2016/08/10/approximating-gadts-in-purescript/">The Purescript Approximation</a></li>
<li><a href="https://hgiasac.github.io/posts/2018-12-18-PureScript-GADTs-Alternatives---Recap.html">PureScript GADTs Alternative - Recap</a></li>
</ul>
<h1><a class="header" href="#42-existential-typespurs" id="42-existential-typespurs">42-Existential-Types.purs</a></h1>
<pre><code class="language-haskell">{-
Note: Certain uses of Existential Types seem to be an Anti-Pattern.

See this post for more details:
https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/

-}
module Patterns.ExistentialTypes where

import Prelude

import Unsafe.Coerce (unsafeCoerce)

data NonPublicState
  = Because_You_Will_Screw_Up_Something_Internally
  | Because_You_Should_Not_Have_Access_To_It
  | Because_We_Want_To_Reduce_The_Number_Of_Generic_Types

type ActualDataTypeUsedInThisProject genericType1 genericType2 =
  { anInt :: Int
  , exposed :: genericType1
  , hidden :: genericType2
  , private :: NonPublicState }

data ExposedDataTypeUsedByEndDevelopers (anInt :: Type) exposed

mkData :: forall a b. ActualDataTypeUsedInThisProject a b -&gt; ExposedDataTypeUsedByEndDevelopers Int a
mkData = unsafeCoerce

unData :: forall exposed r
        . (forall hidden. ActualDataTypeUsedInThisProject exposed hidden -&gt; r)
        -&gt; ExposedDataTypeUsedByEndDevelopers Int exposed
        -&gt; r
unData = unsafeCoerce

changePrivateData :: forall a. (NonPublicState -&gt; NonPublicState) -&gt; ExposedDataTypeUsedByEndDevelopers Int a
changePrivateData f = unData \actualDataType -&gt;
  mkData
    { anInt: actualDataType.anInt
    , exposed: actualDataType.exposed
    , hidden: actualDataType.hidden
    -- change the state of 'private'
    , private: f actualDataType.private
    }
</code></pre>
<h1><a class="header" href="#higher-kinded-data" id="higher-kinded-data">Higher-Kinded Data</a></h1>
<h2><a class="header" href="#reviewing-higher-kinded-types" id="reviewing-higher-kinded-types">Reviewing Higher-Kinded Types</a></h2>
<p>We have higher-kinded types in PureScript (e.g. anything that requires another type to be specified before it becomes a concrete type):</p>
<pre><code class="language-haskell">-- higher-kinded by 1
data List :: Type -&gt; Type
data List a
  = Nil
  | Cons a (List a)

-- higher-kinded by 2
data Either :: Type -&gt; Type -&gt; Type
data Either e a
  = Left e
  | Right a
</code></pre>
<p>In other words, we never have just <code>List</code>s. Rather, we always have a <code>List</code> of <code>String</code>s or a <code>List</code> of <code>Int</code>s. The <code>a</code> type needs to be specified before we can use this value in most contexts.</p>
<p>We can apply this idea in a different manner called &quot;higher-kinded data&quot;. I first saw this in a blog post called <a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">Higher-Kinded Data</a>, saw its usage in Thomas Honeyman's <code>halogen-formless</code>, and then saw <code>@kritzcreek</code>'s comment on the various types one could define with them (shown later in this file). We'll document the pattern below and why you might want to use it.</p>
<pre><code class="language-haskell">-- Given this type...
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)
</code></pre>
<p>We can specify <code>f</code> to a number of different types, thereby defining multiple types in-line with little effort.</p>
<h2><a class="header" href="#basic-types" id="basic-types">Basic Types</a></h2>
<h3><a class="header" href="#using-unlift-a-to-ignore-the-f-type-parameter" id="using-unlift-a-to-ignore-the-f-type-parameter">Using <code>Unlift a</code> to Ignore the <code>f</code> Type Parameter</a></h3>
<pre><code class="language-haskell">-- Given a type that satisfies the (Type -&gt; Type) kind signature
-- but is the same type as the `a` type parameter...
type Unlift a = a

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value is an `Int`.
type HKD_Unlift = HKD Unlift
</code></pre>
<h3><a class="header" href="#using-const-a-b-to-ignoreoverride-the-int-type-parameter" id="using-const-a-b-to-ignoreoverride-the-int-type-parameter">Using <code>Const a b</code> to Ignore/Override the <code>Int</code> Type Parameter</a></h3>
<pre><code class="language-haskell">-- Given a type that ignores its second type parameter
type Const a b = a

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value is a `Boolean`
type HKD_ConstBoolean = HKD (Const Boolean)
</code></pre>
<h2><a class="header" href="#common-types" id="common-types">Common Types</a></h2>
<h3><a class="header" href="#using-maybe-a-to-make-the-int-type-parameter-optional" id="using-maybe-a-to-make-the-int-type-parameter-optional">Using <code>Maybe a</code> to Make the <code>Int</code> Type Parameter Optional</a></h3>
<pre><code class="language-haskell">-- Given a type that may contain a value
type Maybe a
  = Nothing
  | Just a

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value might be an `a` or not.
type HKD_Maybe = HKD Maybe
</code></pre>
<h3><a class="header" href="#using-either-e-to-provide-an-alternative-to-the-int-type-parameter" id="using-either-e-to-provide-an-alternative-to-the-int-type-parameter">Using <code>Either e</code> to Provide an Alternative to the <code>Int</code> Type Parameter</a></h3>
<pre><code class="language-haskell">-- Given a type that may contain a value
type Either e a
  = Left e
  | Right a

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value might be an `String` or an `Int`.
type HKD_Either = HKD (Either String)
</code></pre>
<h3><a class="header" href="#using-list-a-to-provide-0-or-more-int-values" id="using-list-a-to-provide-0-or-more-int-values">Using <code>List a</code> to Provide 0 or more <code>Int</code> values</a></h3>
<pre><code class="language-haskell">-- Given a type that may contain a value
type List a
  = Nil
  | Cons a (List a)

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value is 0 or more `Int`s.
type HKD_List = HKD List
</code></pre>
<h3><a class="header" href="#using-nonempty-f-a-to-provide-1-or-more-int-values" id="using-nonempty-f-a-to-provide-1-or-more-int-values">Using <code>NonEmpty f a</code> to Provide 1 or more <code>Int</code> values</a></h3>
<pre><code class="language-haskell">-- Given a type that may contain a value
newtype NonEmpty f a = NonEmpty a (f a)

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value is 1 or more `Int`s.
type HKD_List = HKD (NonEmpty List)
</code></pre>
<h2><a class="header" href="#more-complex-types" id="more-complex-types">More Complex Types</a></h2>
<h3><a class="header" href="#using-function-a-b-to-produce-int-values-given-some-argument" id="using-function-a-b-to-produce-int-values-given-some-argument">Using <code>Function a b</code> to Produce <code>Int</code> Values Given Some Argument</a></h3>
<pre><code class="language-haskell">-- Given a type that produces a value when given an argument
data Function a b

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value is a function that takes a `String` to produce an `Int`.
type HKD_List = HKD (Function String)

-- or using short-hand syntax
type HKD_List = HKD ((-&gt;) String)
</code></pre>
<h3><a class="header" href="#using-op-a-b-to-produce-some-value-given-an-int-argument" id="using-op-a-b-to-produce-some-value-given-an-int-argument">Using <code>Op a b</code> to Produce Some Value Given an <code>Int</code> Argument</a></h3>
<pre><code class="language-haskell">-- Given a type that produces a value when given an argument
newtype Op a b = Op (b -&gt; a)

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value is a function that takes an `Int` to produce a `String`
type HKD_List = HKD (Op String)
</code></pre>
<h3><a class="header" href="#using-compose-f-g-a-to-model-miscellaenous-types-using-int" id="using-compose-f-g-a-to-model-miscellaenous-types-using-int">Using <code>Compose f g a</code> to Model Miscellaenous Types Using <code>Int</code></a></h3>
<pre><code class="language-haskell">-- Given a type that may contain a value
newtype Compose f g a = Compose (f (g a))

-- and our Higher-Kinded Data type
newtype HKD :: (Type -&gt; Type) -&gt; Type
newtype HKD f = HKD (f Int)

-- the runtime value is `Nothing`, or `Just int`.
type HKD_ComposeMaybeMaybe = HKD (Compose Maybe Unlift)

-- the runtime value is `Nothing`, or `Just boolean`.
type HKD_ComposeMaybeMaybe = HKD (Compose Maybe (Const Boolean))

-- the runtime value is `Nothing`, `Just Nothing`, or `Just int`.
type HKD_ComposeMaybeMaybe = HKD (Compose Maybe Maybe)

-- the runtime value is `Nothing`, `Just (Left string)`, or `Just (Right int)`.
type HKD_ComposeMaybeMaybe = HKD (Compose Maybe (Either String))

-- the runtime value is `Nothing`, `Just Nil`, or `Just intList`.
type HKD_ComposeMaybeMaybe = HKD (Compose Maybe List)

-- the runtime value is `Nil`, `Cons Nothing Nil`, `Cons (Just i) Nil`, or `...`
type HKD_ComposeMaybeMaybe = HKD (Compose List Maybe)
</code></pre>
<p>You can see how <code>Compose</code> makes it possible to do some interesting things.</p>
<h3><a class="header" href="#using-row-kinds-record-and-variant-to-model-product-and-sum-types" id="using-row-kinds-record-and-variant-to-model-product-and-sum-types">Using <code>Row</code> kinds, <code>Record</code>, and <code>Variant</code> to Model Product and Sum Types</a></h3>
<p>Recall that product types (e.g. a AND b) and sum types (e.g. a OR b) are modeled by <code>Record</code> and <code>Variant</code>. So, what happens when we define a higher-kinded-data type that takes <code>rows</code> as the argument that it passes into <code>f</code>? It looks like this:</p>
<pre><code class="language-haskell">data Record :: Row Type -&gt; Type

data Variant :: Row Type -&gt; Type

newtype HKD_Row f = HKD_Row (f (name :: String, age :: Int))

-- the runtime value is a `String` value and an `Int` value
--   { name :: String, age :: Int}`
type HKD_Row_Record = HKD_Row Record

-- the runtime value is either a `String` value or an `Int` value
type HKD_Row_Variant = HKD_Row Variant
</code></pre>
<h2><a class="header" href="#examples-demonstrating-why-one-would-use-higher-kinded-data" id="examples-demonstrating-why-one-would-use-higher-kinded-data">Examples Demonstrating Why One Would Use Higher-Kinded data?</a></h2>
<h3><a class="header" href="#reducing-boilerplate-1" id="reducing-boilerplate-1">Reducing Boilerplate</a></h3>
<p>Now that we have an understanding for how these work, what happens if we interleave two higher-kinded data types together? We find that we get a number of types for free.</p>
<pre><code class="language-haskell">type AllTypes recordOrVariant f =
  recordOrVariant ( name :: f String, age :: f Int )

-- { name :: String, age :: Age }
type PersonRecord = AllTypes Record Unlift

-- { name :: Boolean, age :: Boolean }
type PersonDisplayLabels = AllTypes Record (Const Boolean)

-- { name :: Maybe String, age :: Maybe Age }
type PersonSearchLabels = AllTypes Record Maybe

-- Variant (name :: String, age :: Age)
type PersonSingleLabel = AllTypes Variant Unlift

-- Variant (name :: Boolean, age :: Boolean)
type PersonToggleLabel = AllTypes Variant (Const Boolean)
</code></pre>
<h3><a class="header" href="#reusing-labels-in-rows-for-multiple-things" id="reusing-labels-in-rows-for-multiple-things">Reusing Labels in Rows for Multiple Things</a></h3>
<p>What if we used a version of <code>Unlift</code> that &quot;selects&quot; which type to use among multiple types? <code>Halogen Formless</code> uses this trick to use the same labels to refer to different things depending on the context (e.g. the input value, the output value, the error, etc.):</p>
<pre><code class="language-haskell">data InvalidName = InvalidName
data NotPositiveAge = NotPositiveAge
newtype Name = Name String
newtype Age = Age Int

-- Same as `Unlift` but it only &quot;selects&quot; the correct type
type ErrorType  e i o = e
type InputType  e i o = i
type OutputType e i o = o

type AllTypes :: (Row Type -&gt; Type) -&gt; (Type -&gt; Type) -&gt; Type
type AllTypes recordOrVariant f =
  recordOrVariant
    ( name :: f InvalidName String Name
    , age :: f NotPositiveAge Int Age
  --  label :: f errorType inputType outputType
    )

type FormOutputvalues = AllTypes Record OutputType
type FormErrorsIfAny = AllTypes Record (Compose Maybe ErrorType)
type FormInputValues = AllTypes Record InputType

getName :: FormOutputvalues
getName rec = rec.name

getNameInput :: FormInputValues
getNameInput rec = rec.name

onNameError :: forall m. Monad m =&gt; FormErrorsIfAny -&gt; m Unit
onNameError rec = case rec.name of
  Nothing -&gt; pure unit -- no error!
  Just error -&gt; throwError error
</code></pre>
<h1><a class="header" href="#hyperfunctions" id="hyperfunctions">Hyperfunctions</a></h1>
<p><a href="https://doisinkidney.com/posts/2021-03-14-hyperfunctions.html">Hyperfunctions</a> are an interesting idea, but I do not have much else to say in regards to it.</p>
<h1><a class="header" href="#type-classes-1" id="type-classes-1">Type Classes</a></h1>
<h2><a class="header" href="#why-are-purescripts-type-classes-so-granular" id="why-are-purescripts-type-classes-so-granular">Why Are PureScript's Type Classes So Granular?</a></h2>
<p>See Phil's explanation of <a href="https://blog.functorial.com/posts/2015-12-06-Counterexamples.html">Counterexamples of Type Classes</a></p>
<h2><a class="header" href="#automatically-deriving-instances" id="automatically-deriving-instances">Automatically Deriving Instances</a></h2>
<p>This was the conversation I had with monoidmusician on the Slack channel about <code>purescript-generics-rep</code> and what need it satisfies for deriving type class instances. I've edited it for clarity:</p>
<blockquote>
<p>Me: I have quick question about deriving type class instances via the <code>purescript-generics-rep</code> library. Type classes can be derived in a few ways if the underlying types already have an instance. For example, if I have <code>data T = T Int</code>, I can use <code>derive instance Eq/Show/etc. T</code>. If I have <code>newtype T = T Int</code>, I can use <code>derive newtype instance [rest of the stuff]</code>. What does <code>purescript-generics-rep</code> add that is not already covered by those two?</p>
</blockquote>
<blockquote>
<p>monoidmusician: <code>generics-rep</code> lets you work with the representations of sum and product types (all ADTs basically, not just those with one constructor with one field) in a type-safe way
one of the coolest uses Ive found is deriving optics, but you need some background in lenses and prisms to understand whats happening and the benefits of it: https://pursuit.purescript.org/packages/purescript-generics-rep-optics/0.1.0</p>
</blockquote>
<blockquote>
<p>Me: So <code>data T = T Int</code> works, but as soon as I add another parameter (e.g. <code>data T = T Int Int Int</code>), then <code>derive instance ...</code> stops working and I need to use the generics-rep library?</p>
</blockquote>
<blockquote>
<p>monoidmusician: not so much ... the builtin typeclasses will let you derive most ADTs, thats not the issue, but you cant newtype derive if its not a newtype (one constuctor with one field), so <code>generics-rep</code> covers other typeclasses (like <code>BoundedEnum</code> I think? I forget)
this is my bullet-point overview of deriving methods:</p>
<ul>
<li>newtypes only apply to ADTs with one constructor with one field (hint: its best if you use a newtype whenever you can)</li>
<li>newtype deriving only applies to newtypes (of course), and it directly inherits the same behavior</li>
<li>the regular deriving covers a large variety of ADTs (even recursive ones), but only a few classes (<code>Eq</code>, <code>Ord</code>, <code>Functor</code>, ...)</li>
<li>generics-rep covers a similarly large number of ADTs, and it adds to the number of derivable classes (<code>Bounded</code>, <code>Enum</code>, <code>Monoid</code>, ...), but it cannot handle higher-kinds, so <code>Functor</code> is out</li>
<li>for classes such as <code>Eq</code> and <code>Functor</code> in particular, the instances are reasonably unique, so behavior will usually be the same across the deriving methods, but performance will change, usually with: newtype &gt; derive &gt; generics-rep ... this also remedies the caveat I mentioned above about [a newtype derived instance] directly inherits the same behavior</li>
</ul>
<p>also note that each generic class aimed at deriving will put different constraints on what kind of ADTs it will handle: for instance, <code>GenericMonoid</code> only handles empty ADTs and product shapes whose fields are all monoids</p>
</blockquote>
<p>See <a href="https://purescript-simple-json.readthedocs.io/en/latest/generics-rep.html">Justin Woo's short tutorial on it</a> and its <a href="https://pursuit.purescript.org/packages/purescript-generics-rep/6.1.0">documentation</a> and the corresponding <a href="https://pursuit.purescript.org/packages/purescript-generics-rep-optics/1.1.0">optics</a> library</p>
<h2><a class="header" href="#relationships-1" id="relationships-1">Relationships</a></h2>
<p>This SVG file (WIP, but still helpful) shows the relationships between the type classes (inheritance hierarchy, dual relationships, usage frequency, and package location) throughout the ecosystem:</p>
<p><img src="content/91-Type-Classes/./assets/Type-Class-Relationships.svg" alt="typeclass-relationships" title="Type Class Relationships" /></p>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<p>There is also an Excel file (<a href="content/91-Type-Classes/./assets/Type-Class-Functions.xlsx">Type-Class-Functions.xlsx</a>) that documents the functions of said type classes using a chart like so (<strong>Note: the following chart is long-vertically and short-horizontally to reduce horizontal scrolling. In the real chart, this is inverted</strong>):</p>
<table><thead><tr><th></th><th>Example1</th><th>Example2</th></tr></thead><tbody>
<tr><td>package<br>(the 'purescript-' prefix is omitted, so 'prelude' is really 'purescript-prelude')</td><td>prelude</td><td>prelude</td></tr>
<tr><td>Type class name</td><td>Functor</td><td>Functor</td></tr>
<tr><td>Function Definition<br>(Either defined in the initial type class (I) or dervied using that function (D))</td><td>I</td><td>D</td></tr>
<tr><td>Alias symbol<br>(If no symbol exists, then there is no alias)</td><td>&lt;$&gt;</td><td>$&gt;</td></tr>
<tr><td>Alias infix direction &amp; precedence<br>(<code>direction</code> is either left (L) or right (R)<br><code>precedence</code> is 1..9)</td><td>L 4</td><td>L 4</td></tr>
<tr><td>Type Parameter<br>(what the type that follows the type class (e.g. <code>Functor f</code>))</td><td>f</td><td>f</td></tr>
<tr><td>Function Name</td><td>map</td><td>voidLeft</td></tr>
<tr><td>Constraints<br>(These usually appear in derived functions, but may also appear in initial functions)</td><td></td><td>Functor f</td></tr>
<tr><td>Return type</td><td>f b</td><td>f b</td></tr>
<tr><td>Arg 1</td><td>(a -&gt; b)</td><td>f a</td></tr>
<tr><td>Arg 2</td><td>f a</td><td>a</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>Arg N</td><td>...</td><td>...</td></tr>
</tbody></table>
<h2><a class="header" href="#laws-11" id="laws-11">Laws</a></h2>
<p>TODO</p>
<h2><a class="header" href="#category-theory" id="category-theory">Category Theory</a></h2>
<ul>
<li>See Bortosz Mileski's
<ul>
<li>(unofficial) <a href="https://github.com/hmemcpy/milewski-ctfp-pdf">PDF / Hard back of all his blog posts</a></li>
<li><a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">blogs</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">videos</a></li>
</ul>
</li>
<li>Tom Leinster's <a href="https://arxiv.org/abs/1612.09375">Basic Category Theory</a> (intended audience: people with &quot;relatively little mathematics background)</li>
</ul>
<h1><a class="header" href="#external-explanations" id="external-explanations">External Explanations</a></h1>
<h2><a class="header" href="#contravariant" id="contravariant">Contravariant</a></h2>
<ul>
<li>George Wilson's <a href="https://www.youtube.com/watch?v=IJ_bVVsQhvc">Contravariant Functors: The Other Side of the Coin</a></li>
</ul>
<h2><a class="header" href="#comonad" id="comonad">Comonad</a></h2>
<ul>
<li>Chris Penner's <a href="https://github.com/ChrisPenner/comonads-by-example">Comonads by Example</a> (I highly recommend it).</li>
<li>Gabriel Gonzalez's <a href="http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html">You Could have Invented Comonad</a></li>
<li>Phil Freeman's <a href="https://blog.functorial.com/posts/2016-08-07-Comonads-As-Spaces.html">Comonads as Spaces</a></li>
<li>Nihil Shah's <a href="https://www.youtube.com/watch?v=ydZ_fLwo9yI">Cofree Comonads and their Uses</a></li>
</ul>
<h2><a class="header" href="#indexedmonad-ie-ixmonad" id="indexedmonad-ie-ixmonad">IndexedMonad (i.e. <code>IxMonad</code>)</a></h2>
<p>An IndexedMonad uses the compiler to ensure:</p>
<ol>
<li>monadic computations occur in the proper order</li>
<li>one monadic computation will change what the final output will be</li>
</ol>
<p>Links:</p>
<ul>
<li>Kwan's <a href="https://kseo.github.io/posts/2017-01-12-indexed-monads.html">Indexed Monad overview</a></li>
<li><code>What I wish I knew when Learning Haskell</code>'s <a href="http://dev.stephendiehl.com/hask/#indexed-monads">Indexed Monad section</a></li>
<li>Justin Woo's <a href="https://qiita.com/kimagure/items/a0ee7313e8c7690bf3f5">Using IxMonad to enforce good hamburger building in PureScript</a></li>
</ul>
<p>Real-world problem where it would help: <code>purescript-selda</code>, a library that allows one to write type-safe database queries, would prevent some aggregate queries from working when they are invalid. The (<a href="https://github.com/Kamirus/purescript-selda/blob/master/selda.pdf">thesis' (PDF)</a>) relevant sections are 2.3, 2.4,  and 5 (paragraph 5 and down).</p>
<h1><a class="header" href="#functors" id="functors">Functors</a></h1>
<h2><a class="header" href="#variance-of-functors" id="variance-of-functors">Variance of Functors</a></h2>
<p>This is a summary of <a href="https://typeclasses.com/contravariance">this post</a> and <a href="https://www.schoolofhaskell.com/user/commercial/content/covariance-contravariance">this post</a>.</p>
<p>When we look a <code>Function</code>'s definition, we see that it is higher-kinded by two, that is, two types need to be defined before we can have a concrete type:</p>
<pre><code class="language-haskell">foreign import data Function :: Type -&gt; Type -&gt; Type

infix ? Function as -&gt;

-- Rather than writing `Function input output`
-- we write `input -&gt; output`
no_sugar :: Function Input Output

syntax_sugar :: Input -&gt; Output

generic_on_input :: forall a. a -&gt; Output

generic_on_output :: forall b. Input -&gt; b

generic_on_both :: forall a b. a -&gt; b
</code></pre>
<p>A type can be a <code>Functor</code> if it is higher-kinded by one. In the below example, we specify its input type and leave the output type to be defined in <code>map</code>:</p>
<pre><code class="language-haskell">                   -- (input -&gt;)
instance Functor (Function input) where
                              -- (input -&gt; a)     -&gt; (input -&gt; b)
  map :: forall a b. (a -&gt; b) -&gt; Function input a -&gt; Function input b
  map aToB inputToA = (\input -&gt; aToB (inputToA input))
</code></pre>
<p>However, what if we specified the output type of <code>Function</code> in the instance head and left the input type to be defined in <code>map</code>? If so, it would look like this:</p>
<pre><code class="language-haskell">type FlippedFunc output input = (input -&gt; output)
                   -- (-&gt; output)
instance Functor (FlippedFunc output) where
                              -- (a -&gt; output)        -&gt; (b -&gt; output)
  map :: forall a b. (a -&gt; b) -&gt; FlippedFunc output a -&gt; FlippedFunc output b
  map inputA_To_InputB inputA_To_Output = -- this isn't possible to implement!
</code></pre>
<p>We cannot define an instance of <code>Functor</code> in this way because the first argument in <code>map</code> changes an <code>a</code> value to a <code>b</code> value. However, if we flipped the direction of the arrow, we could write the function's body:</p>
<pre><code class="language-haskell">type FlippedFunc output input = (input -&gt; output)

                         -- (-&gt; output)
instance SomethingElse (FlippedFunc output) where
                                  -- (a -&gt; output)        -&gt; (b -&gt; output)
  map_ish :: forall a b. (b -&gt; a) -&gt; FlippedFunc output a -&gt; FlippedFunc output b
  map_ish inputB_To_InputA inputA_To_Output =
    (\inputB -&gt; inputA_To_Output (inputB_To_InputA inputB))
</code></pre>
<p>The above type class is called <a href="https://pursuit.purescript.org/packages/purescript-contravariant/4.0.0/docs/Data.Functor.Contravariant#t:Contravariant"><code>Contravariant</code></a> and <code>map_ish</code> is called <code>cmap</code>.</p>
<h3><a class="header" href="#functor-re-examined" id="functor-re-examined">Functor Re-examined</a></h3>
<p>The above two type classes, <code>Functor</code> and <code>Contravariant</code>, are the same except for the direction of the arrow in the <code>map</code>/<code>cmap</code>'s first function argument. The former is called <code>Functor</code> instead of <code>Covariant</code> because it appears more often than the latter.</p>
<table><thead><tr><th>Real Name</th><th>Purescript Name</th><th>Frequency of Appearance</th><th>Usage</th></tr></thead><tbody>
<tr><td>Covariant Functor</td><td>Functor</td><td>Very frequent</td><td>Changes the output of a function</td></tr>
<tr><td>Contravariant Functor</td><td>Contravariant</td><td>Infrequent</td><td>Changes the input of a function</td></tr>
</tbody></table>
<h3><a class="header" href="#positive-and-negative-position" id="positive-and-negative-position">Positive and Negative Position</a></h3>
<p>However, there are actually special names for the input and output types:</p>
<blockquote>
<p><strong>Positive</strong> position: the type variable is the result/output/range/codomain of the function
<strong>Negative</strong> position: the type variable is the argument/input/domain of the function</p>
</blockquote>
<p>Or to put it into meta-language: <code>negativePosition -&gt; positivePosition</code></p>
<p>These terms are used so that one can ultimately determine whether a given type is a Covariant or Contravariant Functor by the rules of multplication:</p>
<p>| position 1 | position 2 | end position
| + | + | + |
| - | - | + |
| - | + | - |
| + | - | - |</p>
<p>To understand how this works in practice, see <a href="https://sanj.ink/posts/2020-06-13-contravariant-functors-are-weird.html">Contravariant Functors are Weird</a></p>
<h2><a class="header" href="#the-2-different-functors" id="the-2-different-functors">The 2+ Different Functors</a></h2>
<p>As explained in <code>../Variance of Functors.md</code>, there are two different kinds of <code>Functor</code>s: covariant Functors and contravariant Functors.</p>
<p>However, one also hears about <code>Bifunctor</code>, <code>Profunctor</code>, and <code>Invariant</code>. These are just different ways of combining those different kinds of functors together:</p>
<table><thead><tr><th>Name</th><th>Type Class' function name</th><th>Meaning</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.Functor#t:Functor">Functor</a></td><td><code>map</code>/ <code>&lt;$&gt;</code>/<code>&lt;#&gt;</code></td><td>Maps 1 type with a Covariant Functor</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-contravariant/4.0.0/docs/Data.Functor.Contravariant">Contravariant</a></td><td><code>cmap</code>/<code>&gt;$&lt;</code>/<code>&gt;#&lt;</code></td><td>Maps 1 type with a Contravariant Functor</td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-bifunctors/4.0.0/docs/Data.Bifunctor#t:Bifunctor">Bifunctor</a></td><td><code>bimap</code></td><td><ul><li>1st Type: <strong>Covariant map</strong> (e.g. <code>map</code>)</li><li>2nd Type: <strong>Covariant map</strong> (e.g. <code>map</code>)</li></ul></td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-profunctor/4.0.0/docs/Data.Profunctor">Profunctor</a></td><td><code>dimap</code></td><td><ul><li>1st Type: <strong>Contravariant map</strong> (e.g. <code>cmap</code>)</li><li>2nd Type: <strong>Covariant map</strong> (e.g. <code>map</code>)</li></ul></td></tr>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-invariant/4.1.0/docs/Data.Functor.Invariant#t:Invariant">Invariant</a></td><td><code>imap</code></td><td>Maps 1 type with either/both a Covariant Functor or/and a Contravariant Functor</td></tr>
</tbody></table>
<p>See also <a href="https://typeclasses.com/profunctors">this Profunctor</a> explanation</p>
<h1><a class="header" href="#group-like" id="group-like">Group-Like</a></h1>
<p><a href="https://www.wikiwand.com/en/Semigroup#/Generalizations">This image</a> summarizes how the various group-related type classes relate.</p>
<h1><a class="header" href="#type-level-programming-1" id="type-level-programming-1">Type-Level Programming</a></h1>
<p>The Prim module has sub modules that are not imported by default. Within these modules, Prim defines a few more things for type-level programming. These type classes' instances are <a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#compiler-solvable-type-classes">derived by the compiler</a></p>
<h2><a class="header" href="#type-level-types-values-and-proxies-1" id="type-level-types-values-and-proxies-1">Type-Level Types, Values, and Proxies</a></h2>
<p>In the below table, <strong>&quot;ValueTypeN&quot; was abbreviated to VTN</strong></p>
<table><thead><tr><th>Value-Level Type</th><th>Value-Level Value(s)</th><th>Kind Name<br>(Corresponding TypeLevel Type)</th><th>Kind Values</th></tr></thead><tbody>
<tr><td><a href="https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.Ordering">Ordering</a></td><td><code>LT</code> <code>GT</code> <code>EQ</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.Ordering">Ordering</a></td><td><code>LT</code> <code>GT</code> <code>EQ</code></td></tr>
<tr><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#t:String">String</a></td><td><code>&quot;literal string&quot;</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#k:Symbol">Symbol</a></td><td><code>&quot;literal symbol&quot;</code></td></tr>
<tr><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#t:Record">Record</a><br>(closest idea)</td><td><code>Record (keyN :: VTN, ...)</code></td><td>Row</td><td><code>(keyN :: VTN, ...)</code></td></tr>
<tr><td><a href="https://pursuit.purescript.org/builtins/docs/Prim#t:Boolean">Boolean</a></td><td><code>true</code>/<code>false</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.Boolean">Boolean</a></td><td><code>True</code>/<code>False</code></td></tr>
<tr><td>List ( keyN :: VTN, ... )<br>(analogy; not real type)</td><td><code>Nil</code><br><br><code>Cons a (ListR a)</code></td><td><a href="https://pursuit.purescript.org/builtins/docs/Prim.RowList#k:RowList">RowList</a></td><td><code>Nil</code><br><br><code>Cons :: Symbol -&gt; Type -&gt; RowList</code></td></tr>
</tbody></table>
<h2><a class="header" href="#real-world-examples" id="real-world-examples">Real-World examples</a></h2>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-alphasucc/0.1.0">purescript-alphasucc</a></li>
<li><a href="https://github.com/owickstrom/purescript-hypertrout">purescript-trout</a> -  Type-Level Routing. Used in <a href="https://github.com/owickstrom/purescript-hypertrout">purescript-hypertrout</a>.</li>
<li><a href="https://github.com/justinwoo/purescript-kushikatsu">purescript-kushikatsu</a> - Simple type-level routing</li>
<li><a href="https://github.com/justinwoo/purescript-chirashi">purescript-chirashi</a> - An easy way to work with Errors by inserting a Variant, and reading it out later.</li>
<li><a href="https://pursuit.purescript.org/packages/purescript-variant/5.0.0">purescript-variant</a></li>
<li><a href="https://pursuit.purescript.org/packages/purescript-typelevel-eval/0.2.0">purescript-typelevel-eval</a></li>
</ul>
<h2><a class="header" href="#ideas" id="ideas">Ideas</a></h2>
<ul>
<li><a href="https://chrispenner.ca/posts/typesafe-api-versioning">Type-Safe Versioned APIs</a>. This idea could be combined with the onion architecture and <code>Run</code></li>
</ul>
<h1><a class="header" href="#utility-functions" id="utility-functions">Utility Functions</a></h1>
<p>This file contains functions that use type classes but which are not included in a package that defines such type classes. One can think of these as &quot;extra&quot; derived functions:</p>
<ul>
<li><a href="https://pursuit.purescript.org/packages/purescript-monad-loops/0.5.0">Monad Loops</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
